//! Fluent API builder for CIL instruction assembly.
//!
//! This module provides a high-level, fluent API for assembling CIL instructions with
//! enhanced ergonomics and type safety. The fluent builder wraps the core instruction
//! encoder while providing convenient methods for common instruction patterns and
//! automatic operand type selection.
//!
//! # Architecture
//!
//! The fluent API is built around the [`InstructionAssembler`] struct, which provides
//! method-specific encoding functions that automatically handle operand types and
//! instruction selection. This approach reduces the verbosity of manual instruction
//! encoding while maintaining full control over the generated bytecode.
//!
//! # Key Components
//!
//! - [`InstructionAssembler`] - Main fluent API for instruction assembly
//! - Automatic operand size optimization (e.g., `ldarg.0` vs `ldarg.s` vs `ldarg`)
//! - Type-safe method signatures that prevent invalid operand combinations
//! - Integration with the label resolution system from the core encoder
//!
//! # Usage Examples
//!
//! ## Basic Instruction Assembly
//!
//! ```rust,no_run
//! use dotscope::assembly::InstructionAssembler;
//!
//! let mut assembler = InstructionAssembler::new();
//!
//! // Arithmetic operations
//! assembler
//!     .ldarg_0()?
//!     .ldarg_1()?
//!     .add()?
//!     .ret()?;
//!
//! let bytecode = assembler.finish()?;
//! # Ok::<(), dotscope::Error>(())
//! ```
//!
//! ## Control Flow with Labels
//!
//! ```rust,no_run
//! use dotscope::assembly::InstructionAssembler;
//!
//! let mut assembler = InstructionAssembler::new();
//!
//! assembler
//!     .ldarg_0()?
//!     .brfalse_s("false_case")?
//!     .ldc_i4_1()?
//!     .br_s("end")?
//!     .label("false_case")?
//!     .ldc_i4_0()?
//!     .label("end")?
//!     .ret()?;
//!
//! let bytecode = assembler.finish()?;
//! # Ok::<(), dotscope::Error>(())
//! ```
//!
//! ## Method Implementation Example
//!
//! ```rust,no_run
//! use dotscope::assembly::InstructionAssembler;
//!
//! // Simple addition method: int Add(int a, int b) => a + b;
//! let mut assembler = InstructionAssembler::new();
//!
//! assembler
//!     .ldarg_1()? // Load first parameter (a)
//!     .ldarg_2()? // Load second parameter (b)
//!     .add()?     // Add them
//!     .ret()?;    // Return result
//!
//! let method_body = assembler.finish()?;
//! # Ok::<(), dotscope::Error>(())
//! ```

use crate::{
    assembly::{encoder::InstructionEncoder, Immediate, Operand},
    metadata::token::Token,
    Result,
};

/// High-level fluent API for assembling CIL instructions.
///
/// This struct provides a convenient, chainable interface for generating CIL bytecode
/// with automatic operand size optimization and type safety. It wraps the core
/// [`InstructionEncoder`] while providing specialized methods for common instruction
/// patterns used in .NET method bodies.
///
/// # Design Philosophy
///
/// The fluent API prioritizes:
/// - **Ergonomics**: Method names match CIL mnemonics for familiarity
/// - **Type Safety**: Invalid operand combinations are prevented at compile time
/// - **Optimization**: Automatic selection of the most efficient instruction encoding
/// - **Completeness**: Coverage of all commonly used CIL instructions
///
/// # Automatic Optimizations
///
/// The assembler automatically selects the most efficient instruction encodings:
/// - `ldarg_0()` through `ldarg_3()` use single-byte opcodes when possible
/// - `ldarg_s(index)` uses short form for indices 0-255
/// - `ldarg(index)` uses full form for larger indices
/// - Similar optimizations apply to `ldloc`, `stloc`, `starg`, and constant loading
///
/// # Examples
///
/// ## Simple Method Body
///
/// ```rust,no_run
/// use dotscope::assembly::InstructionAssembler;
///
/// // Generate: return arg0 + arg1;
/// let mut asm = InstructionAssembler::new();
/// asm.ldarg_0()?
///    .ldarg_1()?
///    .add()?
///    .ret()?;
///
/// let bytecode = asm.finish()?;
/// # Ok::<(), dotscope::Error>(())
/// ```
///
/// ## Conditional Logic
///
/// ```rust,no_run
/// use dotscope::assembly::InstructionAssembler;
///
/// // Generate: return arg0 > 0 ? 1 : 0;
/// let mut asm = InstructionAssembler::new();
/// asm.ldarg_0()?
///    .ldc_i4_0()?
///    .bgt_s("positive")?
///    .ldc_i4_0()?
///    .ret()?
///    .label("positive")?
///    .ldc_i4_1()?
///    .ret()?;
///
/// let bytecode = asm.finish()?;
/// # Ok::<(), dotscope::Error>(())
/// ```
pub struct InstructionAssembler {
    /// Core encoder for instruction generation with built-in stack tracking
    encoder: InstructionEncoder,
}

impl InstructionAssembler {
    /// Create a new instruction assembler.
    ///
    /// Initializes a fresh assembler ready for instruction emission. The assembler
    /// maintains internal state for bytecode generation and label resolution.
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut assembler = InstructionAssembler::new();
    /// // Ready for instruction assembly
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    #[must_use]
    pub fn new() -> Self {
        Self {
            encoder: InstructionEncoder::new(),
        }
    }

    /// Finalize assembly and return the complete bytecode with stack information.
    ///
    /// This method completes the assembly process by resolving all label references
    /// and generating the final CIL bytecode. After calling this method, the
    /// assembler cannot be used for further instruction emission.
    ///
    /// # Returns
    ///
    /// A tuple containing:
    /// - The complete CIL bytecode with all labels resolved
    /// - The maximum stack depth required during execution
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Any referenced labels are undefined
    /// - Branch offsets exceed the allowed range for their instruction type
    /// - Stack underflow occurred during assembly (negative stack depth)
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut assembler = InstructionAssembler::new();
    /// assembler.ldc_i4_1()?.ret()?; // Pushes 1, then returns
    ///
    /// let (bytecode, max_stack) = assembler.finish()?;
    /// assert_eq!(bytecode, vec![0x17, 0x2A]); // ldc.i4.1, ret
    /// assert_eq!(max_stack, 1); // Maximum stack depth was 1
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    pub fn finish(self) -> Result<(Vec<u8>, u16)> {
        self.encoder.finalize()
    }

    /// Get the current maximum stack depth without finalizing the assembly.
    ///
    /// This method allows checking the maximum stack depth that has been reached
    /// so far during assembly without consuming the assembler.
    ///
    /// # Returns
    ///
    /// The maximum stack depth reached so far during instruction assembly.
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut assembler = InstructionAssembler::new();
    /// assembler.ldc_i4_1()?; // Pushes 1 item
    /// assert_eq!(assembler.max_stack_depth(), 1);
    ///
    /// assembler.ldc_i4_2()?; // Pushes another item
    /// assert_eq!(assembler.max_stack_depth(), 2);
    ///
    /// assembler.add()?; // Pops 2, pushes 1 (net: -1)
    /// assert_eq!(assembler.max_stack_depth(), 2); // Max is still 2
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    #[must_use]
    pub fn max_stack_depth(&self) -> u16 {
        self.encoder.max_stack_depth()
    }

    /// Get the current stack depth without finalizing the assembly.
    ///
    /// This method returns the current number of items on the evaluation stack.
    /// Useful for debugging or validation during assembly.
    ///
    /// # Returns
    ///
    /// The current stack depth (number of items on evaluation stack).
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut assembler = InstructionAssembler::new();
    /// assert_eq!(assembler.current_stack_depth(), 0);
    ///
    /// assembler.ldc_i4_1()?; // Pushes 1 item
    /// assert_eq!(assembler.current_stack_depth(), 1);
    ///
    /// assembler.ldc_i4_2()?; // Pushes another item
    /// assert_eq!(assembler.current_stack_depth(), 2);
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    #[must_use]
    pub fn current_stack_depth(&self) -> i16 {
        self.encoder.current_stack_depth()
    }

    /// Get the position of a defined label.
    ///
    /// This method allows accessing label positions before finalization,
    /// which is useful for exception handler offset calculation.
    ///
    /// # Parameters
    ///
    /// * `label_name` - The name of the label to look up
    ///
    /// # Returns
    ///
    /// The byte position of the label if it exists, otherwise None.
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut asm = InstructionAssembler::new();
    /// asm.nop()?.label("test_label")?;
    ///
    /// if let Some(position) = asm.get_label_position("test_label") {
    ///     println!("Label 'test_label' is at byte position {}", position);
    /// }
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    #[must_use]
    pub fn get_label_position(&self, label_name: &str) -> Option<u32> {
        self.encoder.get_label_position(label_name)
    }

    /// Define a label at the current position.
    ///
    /// Labels mark positions in the bytecode that can be referenced by branch
    /// instructions. Each label must have a unique name within the assembler scope.
    ///
    /// # Parameters
    ///
    /// * `name` - Unique label name
    ///
    /// # Errors
    ///
    /// Returns an error if a label with the same name has already been defined.
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut asm = InstructionAssembler::new();
    /// asm.nop()?
    ///    .label("loop_start")?
    ///    .ldarg_0()?
    ///    .br_s("loop_start")?;
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    pub fn label(&mut self, name: &str) -> Result<&mut Self> {
        self.encoder.define_label(name)?;
        Ok(self)
    }

    /// Emit a NOP (no operation) instruction.
    ///
    /// The NOP instruction performs no operation and advances to the next instruction.
    /// It's commonly used for padding, debugging, or placeholder purposes.
    ///
    /// **Opcode**: `0x00`
    /// **Stack**: `... → ...` (no change)
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut asm = InstructionAssembler::new();
    /// asm.nop()?.ret()?;
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    pub fn nop(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("nop", None)?;
        Ok(self)
    }

    /// Emit a RET (return) instruction.
    ///
    /// The RET instruction returns from the current method, optionally returning
    /// a value if the method signature specifies a return type.
    ///
    /// **Opcode**: `0x2A`
    /// **Stack**: `retVal → ...` (if returning value) or `... → ...` (if void)
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// // Void method
    /// let mut asm = InstructionAssembler::new();
    /// asm.ret()?;
    ///
    /// // Method returning a value
    /// let mut asm2 = InstructionAssembler::new();
    /// asm2.ldc_i4_const(42)?.ret()?;
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    pub fn ret(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ret", None)?;
        Ok(self)
    }

    /// Load argument 0 onto the stack.
    ///
    /// This is an optimized single-byte instruction for loading the first argument
    /// (typically 'this' in instance methods, or the first parameter in static methods).
    ///
    /// **Opcode**: `0x02`
    /// **Stack**: `... → ..., arg0`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut asm = InstructionAssembler::new();
    /// asm.ldarg_0()?.ret()?; // Return first argument
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    pub fn ldarg_0(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldarg.0", None)?;
        Ok(self)
    }

    /// Load argument 1 onto the stack.
    ///
    /// Optimized single-byte instruction for loading the second argument.
    ///
    /// **Opcode**: `0x03`
    /// **Stack**: `... → ..., arg1`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldarg_1(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldarg.1", None)?;
        Ok(self)
    }

    /// Load argument 2 onto the stack.
    ///
    /// Optimized single-byte instruction for loading the third argument.
    ///
    /// **Opcode**: `0x04`
    /// **Stack**: `... → ..., arg2`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldarg_2(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldarg.2", None)?;
        Ok(self)
    }

    /// Load argument 3 onto the stack.
    ///
    /// Optimized single-byte instruction for loading the fourth argument.
    ///
    /// **Opcode**: `0x05`
    /// **Stack**: `... → ..., arg3`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldarg_3(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldarg.3", None)?;
        Ok(self)
    }

    /// Load argument by index (short form).
    ///
    /// Load an argument by its index using the short form instruction, which
    /// uses a single byte for the index (0-127 due to signed byte encoding).
    ///
    /// **Opcode**: `0x0E`
    /// **Stack**: `... → ..., argN`
    ///
    /// # Parameters
    ///
    /// * `index` - Argument index (0-127)
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut asm = InstructionAssembler::new();
    /// asm.ldarg_s(5)?.ret()?; // Load argument 5
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldarg_s(&mut self, index: i8) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("ldarg.s", Some(Operand::Immediate(Immediate::Int8(index))))?;
        Ok(self)
    }

    /// Load argument by index (full form).
    ///
    /// Load an argument by its index using the full form instruction, which
    /// supports the complete range of argument indices (0-65535).
    ///
    /// **Opcode**: `0x09`
    /// **Stack**: `... → ..., argN`
    ///
    /// # Parameters
    ///
    /// * `index` - Argument index (0-65535)
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut asm = InstructionAssembler::new();
    /// asm.ldarg(1000)?.ret()?; // Load argument 1000
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldarg(&mut self, index: i16) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("ldarg", Some(Operand::Immediate(Immediate::Int16(index))))?;
        Ok(self)
    }

    /// Load local variable 0 onto the stack.
    ///
    /// Optimized single-byte instruction for loading the first local variable.
    ///
    /// **Opcode**: `0x06`
    /// **Stack**: `... → ..., local0`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldloc_0(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldloc.0", None)?;
        Ok(self)
    }

    /// Load local variable 1 onto the stack.
    ///
    /// **Opcode**: `0x07`
    /// **Stack**: `... → ..., local1`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldloc_1(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldloc.1", None)?;
        Ok(self)
    }

    /// Load local variable 2 onto the stack.
    ///
    /// **Opcode**: `0x08`
    /// **Stack**: `... → ..., local2`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldloc_2(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldloc.2", None)?;
        Ok(self)
    }

    /// Load local variable 3 onto the stack.
    ///
    /// **Opcode**: `0x09`
    /// **Stack**: `... → ..., local3`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldloc_3(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldloc.3", None)?;
        Ok(self)
    }

    /// Load local variable by index (short form).
    ///
    /// **Opcode**: `0x11`
    /// **Stack**: `... → ..., localN`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldloc_s(&mut self, index: i8) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("ldloc.s", Some(Operand::Immediate(Immediate::Int8(index))))?;
        Ok(self)
    }

    /// Load local variable by index (full form).
    ///
    /// **Opcode**: `0x0C`
    /// **Stack**: `... → ..., localN`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldloc(&mut self, index: i16) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("ldloc", Some(Operand::Immediate(Immediate::Int16(index))))?;
        Ok(self)
    }

    /// Store value into local variable 0.
    ///
    /// **Opcode**: `0x0A`
    /// **Stack**: `..., value → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn stloc_0(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("stloc.0", None)?;
        Ok(self)
    }

    /// Store value into local variable 1.
    ///
    /// **Opcode**: `0x0B`
    /// **Stack**: `..., value → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn stloc_1(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("stloc.1", None)?;
        Ok(self)
    }

    /// Store value into local variable 2.
    ///
    /// **Opcode**: `0x0C`
    /// **Stack**: `..., value → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn stloc_2(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("stloc.2", None)?;
        Ok(self)
    }

    /// Store value into local variable 3.
    ///
    /// **Opcode**: `0x0D`
    /// **Stack**: `..., value → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn stloc_3(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("stloc.3", None)?;
        Ok(self)
    }

    /// Store value into local variable by index (short form).
    ///
    /// **Opcode**: `0x13`
    /// **Stack**: `..., value → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn stloc_s(&mut self, index: i8) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("stloc.s", Some(Operand::Immediate(Immediate::Int8(index))))?;
        Ok(self)
    }

    /// Store value into local variable by index (full form).
    ///
    /// **Opcode**: `0x0E`
    /// **Stack**: `..., value → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn stloc(&mut self, index: i16) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("stloc", Some(Operand::Immediate(Immediate::Int16(index))))?;
        Ok(self)
    }

    /// Load constant -1 onto the stack.
    ///
    /// **Opcode**: `0x15`
    /// **Stack**: `... → ..., -1`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_i4_m1(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldc.i4.m1", None)?;
        Ok(self)
    }

    /// Load constant 0 onto the stack.
    ///
    /// **Opcode**: `0x16`
    /// **Stack**: `... → ..., 0`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_i4_0(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldc.i4.0", None)?;
        Ok(self)
    }

    /// Load constant 1 onto the stack.
    ///
    /// **Opcode**: `0x17`
    /// **Stack**: `... → ..., 1`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_i4_1(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldc.i4.1", None)?;
        Ok(self)
    }

    /// Load constant 2 onto the stack.
    ///
    /// **Opcode**: `0x18`
    /// **Stack**: `... → ..., 2`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_i4_2(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldc.i4.2", None)?;
        Ok(self)
    }

    /// Load constant 3 onto the stack.
    ///
    /// **Opcode**: `0x19`
    /// **Stack**: `... → ..., 3`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_i4_3(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldc.i4.3", None)?;
        Ok(self)
    }

    /// Load constant 4 onto the stack.
    ///
    /// **Opcode**: `0x1A`
    /// **Stack**: `... → ..., 4`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_i4_4(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldc.i4.4", None)?;
        Ok(self)
    }

    /// Load constant 5 onto the stack.
    ///
    /// **Opcode**: `0x1B`
    /// **Stack**: `... → ..., 5`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_i4_5(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldc.i4.5", None)?;
        Ok(self)
    }

    /// Load constant 6 onto the stack.
    ///
    /// **Opcode**: `0x1C`
    /// **Stack**: `... → ..., 6`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_i4_6(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldc.i4.6", None)?;
        Ok(self)
    }

    /// Load constant 7 onto the stack.
    ///
    /// **Opcode**: `0x1D`
    /// **Stack**: `... → ..., 7`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_i4_7(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldc.i4.7", None)?;
        Ok(self)
    }

    /// Load constant 8 onto the stack.
    ///
    /// **Opcode**: `0x1E`
    /// **Stack**: `... → ..., 8`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_i4_8(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldc.i4.8", None)?;
        Ok(self)
    }

    /// Load a small constant using the short form.
    ///
    /// **Opcode**: `0x1F`
    /// **Stack**: `... → ..., value`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_i4_s(&mut self, value: i8) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("ldc.i4.s", Some(Operand::Immediate(Immediate::Int8(value))))?;
        Ok(self)
    }

    /// Load a 32-bit integer constant.
    ///
    /// **Opcode**: `0x20`
    /// **Stack**: `... → ..., value`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_i4(&mut self, value: i32) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("ldc.i4", Some(Operand::Immediate(Immediate::Int32(value))))?;
        Ok(self)
    }

    /// Load a 64-bit integer constant.
    ///
    /// **Opcode**: `0x21`
    /// **Stack**: `... → ..., value`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_i8(&mut self, value: i64) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("ldc.i8", Some(Operand::Immediate(Immediate::Int64(value))))?;
        Ok(self)
    }

    /// Load a 32-bit floating point constant.
    ///
    /// **Opcode**: `0x22`
    /// **Stack**: `... → ..., value`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_r4(&mut self, value: f32) -> Result<&mut Self> {
        self.encoder.emit_instruction(
            "ldc.r4",
            Some(Operand::Immediate(Immediate::Float32(value))),
        )?;
        Ok(self)
    }

    /// Load a 64-bit floating point constant.
    ///
    /// **Opcode**: `0x23`
    /// **Stack**: `... → ..., value`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_r8(&mut self, value: f64) -> Result<&mut Self> {
        self.encoder.emit_instruction(
            "ldc.r8",
            Some(Operand::Immediate(Immediate::Float64(value))),
        )?;
        Ok(self)
    }

    /// Add two values.
    ///
    /// **Opcode**: `0x58`
    /// **Stack**: `..., value1, value2 → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn add(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("add", None)?;
        Ok(self)
    }

    /// Subtract value2 from value1.
    ///
    /// **Opcode**: `0x59`
    /// **Stack**: `..., value1, value2 → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn sub(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("sub", None)?;
        Ok(self)
    }

    /// Multiply two values.
    ///
    /// **Opcode**: `0x5A`
    /// **Stack**: `..., value1, value2 → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn mul(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("mul", None)?;
        Ok(self)
    }

    /// Divide value1 by value2.
    ///
    /// **Opcode**: `0x5B`
    /// **Stack**: `..., value1, value2 → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn div(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("div", None)?;
        Ok(self)
    }

    /// Compute remainder of value1 divided by value2.
    ///
    /// **Opcode**: `0x5C`
    /// **Stack**: `..., value1, value2 → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn rem(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("rem", None)?;
        Ok(self)
    }

    /// Unconditional branch (short form).
    ///
    /// **Opcode**: `0x2B`
    /// **Stack**: `... → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn br_s(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("br.s", label)?;
        Ok(self)
    }

    /// Branch if false (short form).
    ///
    /// **Opcode**: `0x2C`
    /// **Stack**: `..., value → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn brfalse_s(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("brfalse.s", label)?;
        Ok(self)
    }

    /// Branch if true (short form).
    ///
    /// **Opcode**: `0x2D`
    /// **Stack**: `..., value → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn brtrue_s(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("brtrue.s", label)?;
        Ok(self)
    }

    /// Branch if equal (short form).
    ///
    /// **Opcode**: `0x2E`
    /// **Stack**: `..., value1, value2 → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn beq_s(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("beq.s", label)?;
        Ok(self)
    }

    /// Branch if greater or equal (short form).
    ///
    /// **Opcode**: `0x2F`
    /// **Stack**: `..., value1, value2 → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn bge_s(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("bge.s", label)?;
        Ok(self)
    }

    /// Branch if greater than (short form).
    ///
    /// **Opcode**: `0x30`
    /// **Stack**: `..., value1, value2 → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn bgt_s(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("bgt.s", label)?;
        Ok(self)
    }

    /// Branch if less or equal (short form).
    ///
    /// **Opcode**: `0x31`
    /// **Stack**: `..., value1, value2 → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ble_s(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("ble.s", label)?;
        Ok(self)
    }

    /// Branch if less than (short form).
    ///
    /// **Opcode**: `0x32`
    /// **Stack**: `..., value1, value2 → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn blt_s(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("blt.s", label)?;
        Ok(self)
    }

    /// Branch if not equal (short form).
    ///
    /// **Opcode**: `0x33`
    /// **Stack**: `..., value1, value2 → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn bne_un_s(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("bne.un.s", label)?;
        Ok(self)
    }

    /// Call a method.
    ///
    /// **Opcode**: `0x28`
    /// **Stack**: `..., arg1, arg2, ... argN → ..., returnValue` (if not void)
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn call(&mut self, method_token: Token) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("call", Some(Operand::Token(method_token)))?;
        Ok(self)
    }

    /// Call a virtual method.
    ///
    /// **Opcode**: `0x6F`
    /// **Stack**: `..., obj, arg1, arg2, ... argN → ..., returnValue` (if not void)
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn callvirt(&mut self, method_token: Token) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("callvirt", Some(Operand::Token(method_token)))?;
        Ok(self)
    }

    /// Duplicate the top stack value.
    ///
    /// **Opcode**: `0x25`
    /// **Stack**: `..., value → ..., value, value`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn dup(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("dup", None)?;
        Ok(self)
    }

    /// Pop the top stack value.
    ///
    /// **Opcode**: `0x26`
    /// **Stack**: `..., value → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn pop(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("pop", None)?;
        Ok(self)
    }

    /// Load a constant value with automatic instruction selection.
    ///
    /// This method automatically selects the most efficient instruction for loading
    /// the given constant value, choosing between `ldc.i4.m1`, `ldc.i4.0` through
    /// `ldc.i4.8`, `ldc.i4.s`, and `ldc.i4` based on the value.
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut asm = InstructionAssembler::new();
    /// asm.ldc_i4_const(5)?;    // Uses ldc.i4.5 (single byte)
    /// asm.ldc_i4_const(100)?;  // Uses ldc.i4.s (two bytes)
    /// asm.ldc_i4_const(1000)?; // Uses ldc.i4 (five bytes)
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_i4_const(&mut self, value: i32) -> Result<&mut Self> {
        match value {
            -1 => self.ldc_i4_m1(),
            0 => self.ldc_i4_0(),
            1 => self.ldc_i4_1(),
            2 => self.ldc_i4_2(),
            3 => self.ldc_i4_3(),
            4 => self.ldc_i4_4(),
            5 => self.ldc_i4_5(),
            6 => self.ldc_i4_6(),
            7 => self.ldc_i4_7(),
            8 => self.ldc_i4_8(),
            v if i8::try_from(v).is_ok() => self.ldc_i4_s(
                i8::try_from(v).map_err(|_| malformed_error!("Constant value too large for i8"))?,
            ),
            v => self.ldc_i4(v),
        }
    }

    /// Load an argument with automatic instruction selection.
    ///
    /// This method automatically selects the most efficient instruction for loading
    /// the given argument, choosing between `ldarg.0` through `ldarg.3`, `ldarg.s`,
    /// and `ldarg` based on the index.
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut asm = InstructionAssembler::new();
    /// asm.ldarg_auto(0)?;   // Uses ldarg.0 (single byte)
    /// asm.ldarg_auto(5)?;   // Uses ldarg.s (two bytes)
    /// asm.ldarg_auto(500)?; // Uses ldarg (three bytes)
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldarg_auto(&mut self, index: u16) -> Result<&mut Self> {
        match index {
            0 => self.ldarg_0(),
            1 => self.ldarg_1(),
            2 => self.ldarg_2(),
            3 => self.ldarg_3(),
            i if i <= 127 => self.ldarg_s(
                i8::try_from(i).map_err(|_| malformed_error!("Argument index too large for i8"))?,
            ),
            i => self.ldarg(
                i16::try_from(i)
                    .map_err(|_| malformed_error!("Argument index too large for i16"))?,
            ),
        }
    }

    /// Store to a local with automatic instruction selection.
    ///
    /// This method automatically selects the most efficient instruction for storing
    /// to the given local variable, choosing between `stloc.0` through `stloc.3`,
    /// `stloc.s`, and `stloc` based on the index.
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn stloc_auto(&mut self, index: u16) -> Result<&mut Self> {
        match index {
            0 => self.stloc_0(),
            1 => self.stloc_1(),
            2 => self.stloc_2(),
            3 => self.stloc_3(),
            i if i <= 127 => self.stloc_s(
                i8::try_from(i).map_err(|_| malformed_error!("Local index too large for i8"))?,
            ),
            i => self.stloc(
                i16::try_from(i).map_err(|_| malformed_error!("Local index too large for i16"))?,
            ),
        }
    }

    /// Load from a local with automatic instruction selection.
    ///
    /// This method automatically selects the most efficient instruction for loading
    /// from the given local variable, choosing between `ldloc.0` through `ldloc.3`,
    /// `ldloc.s`, and `ldloc` based on the index.
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldloc_auto(&mut self, index: u16) -> Result<&mut Self> {
        match index {
            0 => self.ldloc_0(),
            1 => self.ldloc_1(),
            2 => self.ldloc_2(),
            3 => self.ldloc_3(),
            i if i <= 127 => self.ldloc_s(
                i8::try_from(i).map_err(|_| malformed_error!("Local index too large for i8"))?,
            ),
            i => self.ldloc(
                i16::try_from(i).map_err(|_| malformed_error!("Local index too large for i16"))?,
            ),
        }
    }

    /// Bitwise AND operation.
    ///
    /// **Opcode**: `0x5F`
    /// **Stack**: `..., value1, value2 → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn and(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("and", None)?;
        Ok(self)
    }

    /// Bitwise OR operation.
    ///
    /// **Opcode**: `0x60`
    /// **Stack**: `..., value1, value2 → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn or(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("or", None)?;
        Ok(self)
    }

    /// Bitwise XOR operation.
    ///
    /// **Opcode**: `0x61`
    /// **Stack**: `..., value1, value2 → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn xor(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("xor", None)?;
        Ok(self)
    }

    /// Bitwise NOT operation.
    ///
    /// **Opcode**: `0x66`
    /// **Stack**: `..., value → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn not(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("not", None)?;
        Ok(self)
    }

    /// Shift left operation.
    ///
    /// **Opcode**: `0x62`
    /// **Stack**: `..., value, shiftAmount → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn shl(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("shl", None)?;
        Ok(self)
    }

    /// Shift right operation.
    ///
    /// **Opcode**: `0x63`
    /// **Stack**: `..., value, shiftAmount → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn shr(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("shr", None)?;
        Ok(self)
    }

    /// Unsigned shift right operation.
    ///
    /// **Opcode**: `0x64`
    /// **Stack**: `..., value, shiftAmount → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn shr_un(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("shr.un", None)?;
        Ok(self)
    }

    /// Negate value.
    ///
    /// **Opcode**: `0x65`
    /// **Stack**: `..., value → ..., -value`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn neg(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("neg", None)?;
        Ok(self)
    }

    /// Convert to int8, with overflow check.
    ///
    /// **Opcode**: `0x68`
    /// **Stack**: `..., value → ..., int8`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn conv_i1(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("conv.i1", None)?;
        Ok(self)
    }

    /// Convert to int16, with overflow check.
    ///
    /// **Opcode**: `0x69`
    /// **Stack**: `..., value → ..., int16`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn conv_i2(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("conv.i2", None)?;
        Ok(self)
    }

    /// Convert to int32, with overflow check.
    ///
    /// **Opcode**: `0x69`
    /// **Stack**: `..., value → ..., int32`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn conv_i4(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("conv.i4", None)?;
        Ok(self)
    }

    /// Convert to int64, with overflow check.
    ///
    /// **Opcode**: `0x6B`
    /// **Stack**: `..., value → ..., int64`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn conv_i8(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("conv.i8", None)?;
        Ok(self)
    }

    /// Convert to float32.
    ///
    /// **Opcode**: `0x6C`
    /// **Stack**: `..., value → ..., float32`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn conv_r4(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("conv.r4", None)?;
        Ok(self)
    }

    /// Convert to float64.
    ///
    /// **Opcode**: `0x6C`
    /// **Stack**: `..., value → ..., float64`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn conv_r8(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("conv.r8", None)?;
        Ok(self)
    }

    /// Convert to uint8, with overflow check.
    ///
    /// **Opcode**: `0xD2`
    /// **Stack**: `..., value → ..., uint8`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn conv_u1(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("conv.u1", None)?;
        Ok(self)
    }

    /// Convert to uint16, with overflow check.
    ///
    /// **Opcode**: `0xD1`
    /// **Stack**: `..., value → ..., uint16`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn conv_u2(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("conv.u2", None)?;
        Ok(self)
    }

    /// Convert to uint32, with overflow check.
    ///
    /// **Opcode**: `0x6E`
    /// **Stack**: `..., value → ..., uint32`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn conv_u4(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("conv.u4", None)?;
        Ok(self)
    }

    /// Convert to uint64, with overflow check.
    ///
    /// **Opcode**: `0x6F`
    /// **Stack**: `..., value → ..., uint64`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn conv_u8(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("conv.u8", None)?;
        Ok(self)
    }

    /// Compare equal.
    ///
    /// **Opcode**: `0xFE01`
    /// **Stack**: `..., value1, value2 → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ceq(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ceq", None)?;
        Ok(self)
    }

    /// Compare greater than.
    ///
    /// **Opcode**: `0xFE02`
    /// **Stack**: `..., value1, value2 → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn cgt(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("cgt", None)?;
        Ok(self)
    }

    /// Compare greater than (unsigned).
    ///
    /// **Opcode**: `0xFE03`
    /// **Stack**: `..., value1, value2 → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn cgt_un(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("cgt.un", None)?;
        Ok(self)
    }

    /// Compare less than.
    ///
    /// **Opcode**: `0xFE04`
    /// **Stack**: `..., value1, value2 → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn clt(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("clt", None)?;
        Ok(self)
    }

    /// Compare less than (unsigned).
    ///
    /// **Opcode**: `0xFE05`
    /// **Stack**: `..., value1, value2 → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn clt_un(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("clt.un", None)?;
        Ok(self)
    }

    /// Load null reference.
    ///
    /// **Opcode**: `0x14`
    /// **Stack**: `... → ..., null`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldnull(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldnull", None)?;
        Ok(self)
    }

    /// Load string literal.
    ///
    /// **Opcode**: `0x72`
    /// **Stack**: `... → ..., string`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldstr(&mut self, string_token: Token) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("ldstr", Some(Operand::Token(string_token)))?;
        Ok(self)
    }

    /// Create new object instance.
    ///
    /// **Opcode**: `0x73`
    /// **Stack**: `..., arg1, arg2, ... argN → ..., obj`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn newobj(&mut self, constructor_token: Token) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("newobj", Some(Operand::Token(constructor_token)))?;
        Ok(self)
    }

    /// Cast class check.
    ///
    /// **Opcode**: `0x74`
    /// **Stack**: `..., obj → ..., obj2`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn castclass(&mut self, type_token: Token) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("castclass", Some(Operand::Token(type_token)))?;
        Ok(self)
    }

    /// Instance of check.
    ///
    /// **Opcode**: `0x75`
    /// **Stack**: `..., obj → ..., result`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn isinst(&mut self, type_token: Token) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("isinst", Some(Operand::Token(type_token)))?;
        Ok(self)
    }

    /// Load field.
    ///
    /// **Opcode**: `0x7B`
    /// **Stack**: `..., obj → ..., value`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldfld(&mut self, field_token: Token) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("ldfld", Some(Operand::Token(field_token)))?;
        Ok(self)
    }

    /// Store field.
    ///
    /// **Opcode**: `0x7D`
    /// **Stack**: `..., obj, value → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn stfld(&mut self, field_token: Token) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("stfld", Some(Operand::Token(field_token)))?;
        Ok(self)
    }

    /// Load static field.
    ///
    /// **Opcode**: `0x7E`
    /// **Stack**: `... → ..., value`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldsfld(&mut self, field_token: Token) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("ldsfld", Some(Operand::Token(field_token)))?;
        Ok(self)
    }

    /// Store static field.
    ///
    /// **Opcode**: `0x80`
    /// **Stack**: `..., value → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn stsfld(&mut self, field_token: Token) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("stsfld", Some(Operand::Token(field_token)))?;
        Ok(self)
    }

    /// Throw exception.
    ///
    /// **Opcode**: `0x7A`
    /// **Stack**: `..., obj → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn throw(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("throw", None)?;
        Ok(self)
    }

    /// End of finally block.
    ///
    /// **Opcode**: `0xDC`
    /// **Stack**: `... → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn endfinally(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("endfinally", None)?;
        Ok(self)
    }

    /// Load element from array.
    ///
    /// **Opcode**: `0x8F`
    /// **Stack**: `..., array, index → ..., value`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldelem_i4(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldelem.i4", None)?;
        Ok(self)
    }

    /// Store element to array.
    ///
    /// **Opcode**: `0x9C`
    /// **Stack**: `..., array, index, value → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn stelem_i4(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("stelem.i4", None)?;
        Ok(self)
    }

    /// Load array length.
    ///
    /// **Opcode**: `0x8E`
    /// **Stack**: `..., array → ..., length`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldlen(&mut self) -> Result<&mut Self> {
        self.encoder.emit_instruction("ldlen", None)?;
        Ok(self)
    }

    /// Create new array.
    ///
    /// **Opcode**: `0x8D`
    /// **Stack**: `..., numElems → ..., array`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn newarr(&mut self, element_type_token: Token) -> Result<&mut Self> {
        self.encoder
            .emit_instruction("newarr", Some(Operand::Token(element_type_token)))?;
        Ok(self)
    }

    /// Unconditional branch (long form).
    ///
    /// **Opcode**: `0x38`
    /// **Stack**: `... → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn br(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("br", label)?;
        Ok(self)
    }

    /// Branch if false (long form).
    ///
    /// **Opcode**: `0x39`
    /// **Stack**: `..., value → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn brfalse(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("brfalse", label)?;
        Ok(self)
    }

    /// Branch if true (long form).
    ///
    /// **Opcode**: `0x3A`
    /// **Stack**: `..., value → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn brtrue(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("brtrue", label)?;
        Ok(self)
    }

    /// Leave protected region for exception handling (short form).
    ///
    /// **Opcode**: `0xDE`
    /// **Stack**: `... → ...`
    ///
    /// Exits a protected region of code, unconditionally transferring control
    /// to a specific target instruction (typically at the end of a finally clause).
    /// This is used in structured exception handling.
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn leave_s(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("leave.s", label)?;
        Ok(self)
    }

    /// Leave protected region for exception handling (long form).
    ///
    /// **Opcode**: `0xDD`
    /// **Stack**: `... → ...`
    ///
    /// Exits a protected region of code, unconditionally transferring control
    /// to a specific target instruction (typically at the end of a finally clause).
    /// This is used in structured exception handling.
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn leave(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("leave", label)?;
        Ok(self)
    }

    /// Branch if equal (long form).
    ///
    /// **Opcode**: `0x3B`
    /// **Stack**: `..., value1, value2 → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn beq(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("beq", label)?;
        Ok(self)
    }

    /// Branch if greater or equal (long form).
    ///
    /// **Opcode**: `0x3C`
    /// **Stack**: `..., value1, value2 → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn bge(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("bge", label)?;
        Ok(self)
    }

    /// Branch if greater than (long form).
    ///
    /// **Opcode**: `0x3D`
    /// **Stack**: `..., value1, value2 → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn bgt(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("bgt", label)?;
        Ok(self)
    }

    /// Branch if less or equal (long form).
    ///
    /// **Opcode**: `0x3E`
    /// **Stack**: `..., value1, value2 → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ble(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("ble", label)?;
        Ok(self)
    }

    /// Branch if less than (long form).
    ///
    /// **Opcode**: `0x3F`
    /// **Stack**: `..., value1, value2 → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn blt(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("blt", label)?;
        Ok(self)
    }

    /// Branch if not equal (long form).
    ///
    /// **Opcode**: `0x40`
    /// **Stack**: `..., value1, value2 → ...`
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn bne_un(&mut self, label: &str) -> Result<&mut Self> {
        self.encoder.emit_branch("bne.un", label)?;
        Ok(self)
    }

    /// Load a boolean constant (0 or 1).
    ///
    /// Maps to `ldc.i4.0` for false and `ldc.i4.1` for true.
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut asm = InstructionAssembler::new();
    /// asm.ldc_bool(true)?;   // Uses ldc.i4.1
    /// asm.ldc_bool(false)?;  // Uses ldc.i4.0
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    pub fn ldc_bool(&mut self, value: bool) -> Result<&mut Self> {
        if value {
            self.ldc_i4_1()
        } else {
            self.ldc_i4_0()
        }
    }

    /// Common pattern: load argument, check if null, branch if not null.
    ///
    /// This is a convenience method that combines three common instructions
    /// used for null checking patterns.
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut asm = InstructionAssembler::new();
    /// asm.check_null_and_branch(0, "not_null")?;  // if (arg0 != null) goto not_null
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    pub fn check_null_and_branch(&mut self, arg_index: u16, label: &str) -> Result<&mut Self> {
        self.ldarg_auto(arg_index)?.ldnull()?.bne_un_s(label)
    }

    /// Common pattern: compare two arguments and branch.
    ///
    /// Loads two arguments and performs an equality comparison with branching.
    ///
    /// # Errors
    ///
    /// Returns an error if instruction encoding fails.
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use dotscope::assembly::InstructionAssembler;
    ///
    /// let mut asm = InstructionAssembler::new();
    /// asm.compare_args_and_branch(0, 1, "equal")?;  // if (arg0 == arg1) goto equal
    /// # Ok::<(), dotscope::Error>(())
    /// ```
    pub fn compare_args_and_branch(
        &mut self,
        arg1: u16,
        arg2: u16,
        label: &str,
    ) -> Result<&mut Self> {
        self.ldarg_auto(arg1)?.ldarg_auto(arg2)?.beq_s(label)
    }
}

impl Default for InstructionAssembler {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fluent_api_basic() -> Result<()> {
        let mut asm = InstructionAssembler::new();

        asm.nop()?.ret()?;

        let (bytecode, _max_stack) = asm.finish()?;
        assert_eq!(bytecode, vec![0x00, 0x2A]); // nop, ret

        Ok(())
    }

    #[test]
    fn test_arithmetic_method() -> Result<()> {
        let mut asm = InstructionAssembler::new();

        // Simple addition: return arg0 + arg1
        asm.ldarg_0()?.ldarg_1()?.add()?.ret()?;

        let (bytecode, _max_stack) = asm.finish()?;
        assert_eq!(bytecode, vec![0x02, 0x03, 0x58, 0x2A]); // ldarg.0, ldarg.1, add, ret

        Ok(())
    }

    #[test]
    fn test_conditional_logic() -> Result<()> {
        let mut asm = InstructionAssembler::new();

        // if (arg0 > 0) return 1; else return 0;
        asm.ldarg_0()?
            .ldc_i4_0()?
            .bgt_s("positive")?
            .ldc_i4_0()?
            .ret()?
            .label("positive")?
            .ldc_i4_1()?
            .ret()?;

        let (bytecode, _max_stack) = asm.finish()?;
        // ldarg.0 (0x02), ldc.i4.0 (0x16), bgt.s (0x30) + offset, ldc.i4.0 (0x16), ret (0x2A), ldc.i4.1 (0x17), ret (0x2A)
        assert_eq!(bytecode.len(), 8); // Total should be 8 bytes
        assert_eq!(bytecode[0], 0x02); // ldarg.0
        assert_eq!(bytecode[1], 0x16); // ldc.i4.0
        assert_eq!(bytecode[2], 0x30); // bgt.s

        Ok(())
    }

    #[test]
    fn test_constant_optimization() -> Result<()> {
        let mut asm = InstructionAssembler::new();

        asm.ldc_i4_const(-1)? // ldc.i4.m1
            .ldc_i4_const(5)? // ldc.i4.5
            .ldc_i4_const(42)? // ldc.i4.s 42
            .ldc_i4_const(1000)?; // ldc.i4 1000

        let (bytecode, _max_stack) = asm.finish()?;
        assert_eq!(bytecode[0], 0x15); // ldc.i4.m1
        assert_eq!(bytecode[1], 0x1B); // ldc.i4.5
        assert_eq!(bytecode[2], 0x1F); // ldc.i4.s
        assert_eq!(bytecode[3], 42); // value
        assert_eq!(bytecode[4], 0x20); // ldc.i4

        Ok(())
    }

    #[test]
    fn test_argument_optimization() -> Result<()> {
        let mut asm = InstructionAssembler::new();

        asm.ldarg_auto(0)? // ldarg.0
            .ldarg_auto(1)? // ldarg.1
            .ldarg_auto(5)? // ldarg.s 5
            .ldarg_auto(500)?; // ldarg 500

        let (bytecode, _max_stack) = asm.finish()?;
        assert_eq!(bytecode[0], 0x02); // ldarg.0
        assert_eq!(bytecode[1], 0x03); // ldarg.1
        assert_eq!(bytecode[2], 0x0E); // ldarg.s
        assert_eq!(bytecode[3], 5); // index
        assert_eq!(bytecode[4], 0xFE); // ldarg prefix
        assert_eq!(bytecode[5], 0x09); // ldarg opcode
        assert_eq!(bytecode[6], 244); // 500 & 0xFF (low byte)
        assert_eq!(bytecode[7], 1); // (500 >> 8) & 0xFF (high byte)

        Ok(())
    }

    #[test]
    fn test_local_variable_operations() -> Result<()> {
        let mut asm = InstructionAssembler::new();

        asm.ldarg_0()?
            .stloc_0()? // Store arg0 to local 0
            .ldloc_0()? // Load local 0
            .ret()?;

        let (bytecode, _max_stack) = asm.finish()?;
        assert_eq!(bytecode, vec![0x02, 0x0A, 0x06, 0x2A]); // ldarg.0, stloc.0, ldloc.0, ret

        Ok(())
    }

    #[test]
    fn test_stack_operations() -> Result<()> {
        let mut asm = InstructionAssembler::new();

        asm.ldarg_0()?
            .dup()? // Duplicate the value
            .pop()? // Remove one copy
            .ret()?;

        let (bytecode, _max_stack) = asm.finish()?;
        assert_eq!(bytecode, vec![0x02, 0x25, 0x26, 0x2A]); // ldarg.0, dup, pop, ret

        Ok(())
    }

    #[test]
    fn test_bitwise_operations() -> Result<()> {
        let mut asm = InstructionAssembler::new();

        asm.ldarg_0()?
            .ldarg_1()?
            .and()? // Bitwise AND
            .ldarg_0()?
            .ldarg_1()?
            .or()? // Bitwise OR
            .xor()? // XOR the results
            .ret()?;

        let (bytecode, _max_stack) = asm.finish()?;
        // ldarg.0 (0x02), ldarg.1 (0x03), and (0x5F), ldarg.0 (0x02), ldarg.1 (0x03), or (0x60), xor (0x61), ret (0x2A)
        assert_eq!(
            bytecode,
            vec![0x02, 0x03, 0x5F, 0x02, 0x03, 0x60, 0x61, 0x2A]
        );

        Ok(())
    }

    #[test]
    fn test_comparison_operations() -> Result<()> {
        let mut asm = InstructionAssembler::new();

        asm.ldarg_0()?
            .ldarg_1()?
            .ceq()? // Compare equal
            .ret()?;

        let (bytecode, _max_stack) = asm.finish()?;
        // ldarg.0 (0x02), ldarg.1 (0x03), ceq (0xFE 0x01), ret (0x2A)
        assert_eq!(bytecode, vec![0x02, 0x03, 0xFE, 0x01, 0x2A]);

        Ok(())
    }

    #[test]
    fn test_conversion_operations() -> Result<()> {
        let mut asm = InstructionAssembler::new();

        asm.ldarg_0()?
            .conv_i4()? // Convert to int32
            .conv_r8()? // Convert to double
            .ret()?;

        let (bytecode, _max_stack) = asm.finish()?;
        // ldarg.0 (0x02), conv.i4 (0x69), conv.r8 (0x6C), ret (0x2A)
        assert_eq!(bytecode, vec![0x02, 0x69, 0x6C, 0x2A]);

        Ok(())
    }

    #[test]
    fn test_boolean_constants() -> Result<()> {
        let mut asm = InstructionAssembler::new();

        asm.ldc_bool(true)? // Should use ldc.i4.1
            .ldc_bool(false)? // Should use ldc.i4.0
            .ret()?;

        let (bytecode, _max_stack) = asm.finish()?;
        // ldc.i4.1 (0x17), ldc.i4.0 (0x16), ret (0x2A)
        assert_eq!(bytecode, vec![0x17, 0x16, 0x2A]);

        Ok(())
    }

    #[test]
    fn test_null_operations() -> Result<()> {
        let mut asm = InstructionAssembler::new();

        asm.ldnull()? // Load null
            .ldarg_0()?
            .ceq()? // Compare with argument
            .ret()?;

        let (bytecode, _max_stack) = asm.finish()?;
        // ldnull (0x14), ldarg.0 (0x02), ceq (0xFE 0x01), ret (0x2A)
        assert_eq!(bytecode, vec![0x14, 0x02, 0xFE, 0x01, 0x2A]);

        Ok(())
    }

    #[test]
    fn test_long_form_branches() -> Result<()> {
        let mut asm = InstructionAssembler::new();

        asm.ldarg_0()?
            .brfalse("end")? // Long form branch
            .ldc_i4_1()?
            .label("end")?
            .ret()?;

        let (bytecode, _max_stack) = asm.finish()?;
        assert_eq!(bytecode.len(), 8); // Should have correct length with long branch
        assert_eq!(bytecode[0], 0x02); // ldarg.0
        assert_eq!(bytecode[1], 0x39); // brfalse (long form)

        Ok(())
    }

    #[test]
    fn test_convenience_methods() -> Result<()> {
        let mut asm = InstructionAssembler::new();

        // Test null check pattern
        asm.check_null_and_branch(0, "not_null")?
            .ldc_i4_0()? // null case
            .ret()?
            .label("not_null")?
            .ldc_i4_1()? // not null case
            .ret()?;

        let (bytecode, _max_stack) = asm.finish()?;
        assert_eq!(bytecode[0], 0x02); // ldarg.0
        assert_eq!(bytecode[1], 0x14); // ldnull
        assert_eq!(bytecode[2], 0x33); // bne.un.s

        Ok(())
    }

    #[test]
    fn test_field_operations_with_tokens() -> Result<()> {
        use crate::metadata::token::Token;

        let field_token = Token::new(0x04000001); // Example field token
        let mut asm = InstructionAssembler::new();

        asm.ldarg_0()?
            .ldfld(field_token)? // Load field
            .ret()?;

        let (bytecode, _max_stack) = asm.finish()?;
        assert_eq!(bytecode[0], 0x02); // ldarg.0
        assert_eq!(bytecode[1], 0x7B); // ldfld

        Ok(())
    }
}
