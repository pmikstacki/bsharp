//! Roundtrip tests for CIL instruction assembly and disassembly.
//!
//! These tests verify that our encoder and disassembler work perfectly together by:
//! 1. Assembling instructions using InstructionAssembler or InstructionEncoder
//! 2. Disassembling the generated bytecode using the disassembler  
//! 3. Verifying that the disassembled instructions match the expected results
//!
//! This ensures perfect consistency between assembly and disassembly operations.

use dotscope::{
    assembly::{
        decode_stream, FlowType, Immediate, InstructionAssembler, InstructionEncoder, Operand,
    },
    Parser, Result,
};

/// Test basic arithmetic instructions roundtrip correctly.
#[test]
fn test_arithmetic_instructions_roundtrip() -> Result<()> {
    let mut asm = InstructionAssembler::new();
    asm.ldarg_0()?.ldarg_1()?.add()?.ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Expected bytecode: [0x02, 0x03, 0x58, 0x2A]
    assert_eq!(bytecode, vec![0x02, 0x03, 0x58, 0x2A]);

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;
    assert_eq!(instructions.len(), 4);

    assert_eq!(instructions[0].mnemonic, "ldarg.0");
    assert_eq!(instructions[0].offset, 0);

    assert_eq!(instructions[1].mnemonic, "ldarg.1");
    assert_eq!(instructions[1].offset, 1);

    assert_eq!(instructions[2].mnemonic, "add");
    assert_eq!(instructions[2].offset, 2);

    assert_eq!(instructions[3].mnemonic, "ret");
    assert_eq!(instructions[3].offset, 3);
    assert_eq!(instructions[3].flow_type, FlowType::Return);

    Ok(())
}

/// Test constant loading instructions with various optimizations.
#[test]
fn test_constant_loading_roundtrip() -> Result<()> {
    let mut asm = InstructionAssembler::new();
    asm.ldc_i4_0()? // Optimized form
        .ldc_i4_1()? // Optimized form
        .ldc_i4_8()? // Optimized form
        .ldc_i4_const(42)? // Should use ldc.i4.s
        .ldc_i4_const(1000)? // Should use ldc.i4
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;
    assert_eq!(instructions.len(), 6);

    assert_eq!(instructions[0].mnemonic, "ldc.i4.0");
    assert_eq!(instructions[1].mnemonic, "ldc.i4.1");
    assert_eq!(instructions[2].mnemonic, "ldc.i4.8");
    assert_eq!(instructions[3].mnemonic, "ldc.i4.s");
    assert_eq!(instructions[4].mnemonic, "ldc.i4");
    assert_eq!(instructions[5].mnemonic, "ret");

    Ok(())
}

/// Test local variable operations roundtrip correctly.
#[test]
fn test_local_variable_roundtrip() -> Result<()> {
    let mut asm = InstructionAssembler::new();
    asm.ldloc_0()?.stloc_1()?.ldloc_s(5)?.stloc_s(10)?.ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;
    assert_eq!(instructions.len(), 5);

    assert_eq!(instructions[0].mnemonic, "ldloc.0");
    assert_eq!(instructions[1].mnemonic, "stloc.1");
    assert_eq!(instructions[2].mnemonic, "ldloc.s");
    assert_eq!(instructions[3].mnemonic, "stloc.s");
    assert_eq!(instructions[4].mnemonic, "ret");

    Ok(())
}

/// Test branch instructions with label resolution.
#[test]
fn test_branch_instructions_roundtrip() -> Result<()> {
    let mut asm = InstructionAssembler::new();
    asm.ldarg_0()?
        .brfalse_s("false_case")?
        .ldc_i4_1()?
        .br_s("end")?
        .label("false_case")?
        .ldc_i4_0()?
        .label("end")?
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;
    assert_eq!(instructions.len(), 6); // Labels don't generate instructions

    assert_eq!(instructions[0].mnemonic, "ldarg.0");
    assert_eq!(instructions[1].mnemonic, "brfalse.s");
    assert_eq!(instructions[1].flow_type, FlowType::ConditionalBranch);
    assert_eq!(instructions[2].mnemonic, "ldc.i4.1");
    assert_eq!(instructions[3].mnemonic, "br.s");
    assert_eq!(instructions[3].flow_type, FlowType::UnconditionalBranch);
    assert_eq!(instructions[4].mnemonic, "ldc.i4.0");
    assert_eq!(instructions[5].mnemonic, "ret");

    Ok(())
}

/// Test low-level encoder with various operand types.
#[test]
fn test_encoder_operand_types_roundtrip() -> Result<()> {
    let mut encoder = InstructionEncoder::new();
    encoder.emit_instruction("nop", None)?;
    encoder.emit_instruction("ldarg.s", Some(Operand::Immediate(Immediate::Int8(1))))?;
    encoder.emit_instruction("ldc.i4.s", Some(Operand::Immediate(Immediate::Int8(42))))?;
    encoder.emit_instruction("ldc.i4", Some(Operand::Immediate(Immediate::Int32(12345))))?;
    encoder.emit_instruction(
        "ldc.i8",
        Some(Operand::Immediate(Immediate::Int64(999999999))),
    )?;
    encoder.emit_instruction("ret", None)?;

    let (bytecode, _max_stack) = encoder.finalize()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;
    assert_eq!(instructions.len(), 6);

    assert_eq!(instructions[0].mnemonic, "nop");
    assert_eq!(instructions[1].mnemonic, "ldarg.s");
    assert_eq!(instructions[2].mnemonic, "ldc.i4.s");
    assert_eq!(instructions[3].mnemonic, "ldc.i4");
    assert_eq!(instructions[4].mnemonic, "ldc.i8");
    assert_eq!(instructions[5].mnemonic, "ret");

    Ok(())
}

/// Test complex control flow with multiple branches and labels.
#[test]
fn test_complex_control_flow_roundtrip() -> Result<()> {
    let mut asm = InstructionAssembler::new();
    asm.ldarg_0()?
        .ldc_i4_0()?
        .beq_s("zero_case")?
        .ldarg_0()?
        .ldc_i4_1()?
        .beq_s("one_case")?
        .ldc_i4_m1()? // Default case
        .br_s("end")?
        .label("zero_case")?
        .ldc_i4_const(100)?
        .br_s("end")?
        .label("one_case")?
        .ldc_i4_const(200)?
        .label("end")?
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify structure
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;

    // Find all branch instructions and verify they have proper flow types
    let branches: Vec<_> = instructions
        .iter()
        .filter(|instr| {
            matches!(
                instr.flow_type,
                FlowType::ConditionalBranch | FlowType::UnconditionalBranch
            )
        })
        .collect();

    assert!(branches.len() >= 4); // beq.s, beq.s, br.s, br.s

    // Verify the structure makes sense
    assert_eq!(instructions.last().unwrap().mnemonic, "ret");
    assert_eq!(instructions.last().unwrap().flow_type, FlowType::Return);

    Ok(())
}

/// Test argument loading optimizations.
#[test]
fn test_argument_loading_optimizations() -> Result<()> {
    let mut asm = InstructionAssembler::new();
    asm.ldarg_auto(0)? // Should use ldarg.0
        .ldarg_auto(1)? // Should use ldarg.1
        .ldarg_auto(2)? // Should use ldarg.2
        .ldarg_auto(3)? // Should use ldarg.3
        .ldarg_auto(5)? // Should use ldarg.s
        .ldarg_auto(300)? // Should use ldarg
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify optimizations were applied correctly
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;
    assert_eq!(instructions.len(), 7);

    assert_eq!(instructions[0].mnemonic, "ldarg.0");
    assert_eq!(instructions[1].mnemonic, "ldarg.1");
    assert_eq!(instructions[2].mnemonic, "ldarg.2");
    assert_eq!(instructions[3].mnemonic, "ldarg.3");
    assert_eq!(instructions[4].mnemonic, "ldarg.s");
    assert_eq!(instructions[5].mnemonic, "ldarg");
    assert_eq!(instructions[6].mnemonic, "ret");

    Ok(())
}

/// Test stack operations roundtrip correctly.
#[test]
fn test_stack_operations_roundtrip() -> Result<()> {
    let mut asm = InstructionAssembler::new();
    asm.ldc_i4_const(42)?
        .dup()? // Duplicate top of stack
        .ldc_i4_const(10)?
        .add()?
        .pop()? // Remove one value
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;

    let dup_instr = instructions.iter().find(|i| i.mnemonic == "dup").unwrap();
    let pop_instr = instructions.iter().find(|i| i.mnemonic == "pop").unwrap();

    // Stack operations should have correct flow types
    assert_eq!(dup_instr.flow_type, FlowType::Sequential);
    assert_eq!(pop_instr.flow_type, FlowType::Sequential);

    Ok(())
}

/// Test extended instructions (0xFE prefix) roundtrip correctly.
#[test]
fn test_extended_instructions_roundtrip() -> Result<()> {
    let mut encoder = InstructionEncoder::new();
    encoder.emit_instruction("ldarg", Some(Operand::Immediate(Immediate::Int16(10))))?;
    encoder.emit_instruction("ldloc", Some(Operand::Immediate(Immediate::Int16(5))))?;
    encoder.emit_instruction("ret", None)?;

    let (bytecode, _max_stack) = encoder.finalize()?;

    // Extended instructions should start with 0xFE prefix
    assert_eq!(bytecode[0], 0xFE); // First extended instruction prefix
    assert_eq!(bytecode[1], 0x09); // ldarg opcode
    assert_eq!(bytecode[4], 0xFE); // Second extended instruction prefix
    assert_eq!(bytecode[5], 0x0C); // ldloc opcode

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;
    assert_eq!(instructions.len(), 3);

    assert_eq!(instructions[0].mnemonic, "ldarg");
    assert_eq!(instructions[1].mnemonic, "ldloc");
    assert_eq!(instructions[2].mnemonic, "ret");

    Ok(())
}

/// Test method call instructions roundtrip correctly.
#[test]
fn test_method_calls_roundtrip() -> Result<()> {
    use dotscope::metadata::token::Token;

    let method_token = Token::new(0x0A000001); // Example method token

    let mut asm = InstructionAssembler::new();
    asm.ldarg_0()?
        .call(method_token)?
        .callvirt(method_token)?
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;
    assert_eq!(instructions.len(), 4);

    assert_eq!(instructions[0].mnemonic, "ldarg.0");
    assert_eq!(instructions[1].mnemonic, "call");
    assert_eq!(instructions[1].flow_type, FlowType::Call);
    assert_eq!(instructions[2].mnemonic, "callvirt");
    assert_eq!(instructions[2].flow_type, FlowType::Call);
    assert_eq!(instructions[3].mnemonic, "ret");

    Ok(())
}

/// Test floating point constant loading.
#[test]
fn test_floating_point_constants_roundtrip() -> Result<()> {
    let mut encoder = InstructionEncoder::new();
    encoder.emit_instruction(
        "ldc.r4",
        Some(Operand::Immediate(Immediate::Float32(std::f32::consts::PI))),
    )?;
    encoder.emit_instruction(
        "ldc.r8",
        Some(Operand::Immediate(Immediate::Float64(std::f64::consts::E))),
    )?;
    encoder.emit_instruction("ret", None)?;

    let (bytecode, _max_stack) = encoder.finalize()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;
    assert_eq!(instructions.len(), 3);

    assert_eq!(instructions[0].mnemonic, "ldc.r4");
    assert_eq!(instructions[1].mnemonic, "ldc.r8");
    assert_eq!(instructions[2].mnemonic, "ret");

    Ok(())
}

/// Test that our encoder handles all instruction categories correctly.
#[test]
fn test_instruction_categories_roundtrip() -> Result<()> {
    let mut encoder = InstructionEncoder::new();

    // Test basic instructions from different categories
    encoder.emit_instruction("nop", None)?; // Basic
    encoder.emit_instruction("ldarg.0", None)?; // Argument loading
    encoder.emit_instruction("ldc.i4.1", None)?; // Constant loading
    encoder.emit_instruction("add", None)?; // Arithmetic
    encoder.emit_instruction("dup", None)?; // Stack manipulation
    encoder.emit_instruction("ret", None)?; // Return

    let (bytecode, _max_stack) = encoder.finalize()?;

    // Disassemble and verify all instructions are correctly decoded
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;
    assert_eq!(instructions.len(), 6);

    let mnemonics: Vec<&str> = instructions.iter().map(|i| i.mnemonic).collect();
    assert_eq!(
        mnemonics,
        vec!["nop", "ldarg.0", "ldc.i4.1", "add", "dup", "ret"]
    );

    Ok(())
}

/// Test error cases to ensure they're handled consistently.
#[test]
fn test_error_handling_consistency() {
    // Test invalid mnemonic
    let mut encoder = InstructionEncoder::new();
    let result = encoder.emit_instruction("invalid_instruction", None);
    assert!(result.is_err());

    // Test wrong operand type
    let mut encoder2 = InstructionEncoder::new();
    let result2 =
        encoder2.emit_instruction("ldarg.s", Some(Operand::Immediate(Immediate::Int32(1))));
    assert!(result2.is_err()); // ldarg.s expects Int8, not Int32
}

/// Comprehensive integration test combining multiple features.
#[test]
fn test_comprehensive_method_roundtrip() -> Result<()> {
    // Build a method that demonstrates multiple instruction types:
    // int Add(int a, int b) {
    //     if (a == 0) return b;
    //     if (b == 0) return a;
    //     return a + b;
    // }

    let mut asm = InstructionAssembler::new();
    asm.ldarg_1()? // Load parameter 'a'
        .ldc_i4_0()? // Load constant 0
        .bne_un_s("check_b")? // Branch if a != 0
        .ldarg_2()? // Load parameter 'b'
        .ret()? // Return b
        .label("check_b")?
        .ldarg_2()? // Load parameter 'b'
        .ldc_i4_0()? // Load constant 0
        .bne_un_s("do_add")? // Branch if b != 0
        .ldarg_1()? // Load parameter 'a'
        .ret()? // Return a
        .label("do_add")?
        .ldarg_1()? // Load parameter 'a'
        .ldarg_2()? // Load parameter 'b'
        .add()? // Add them
        .ret()?; // Return result

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify the complete method structure
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;

    // Should have 3 return instructions
    let returns = instructions.iter().filter(|i| i.mnemonic == "ret").count();
    assert_eq!(returns, 3);

    // Should have 2 conditional branches
    let branches = instructions
        .iter()
        .filter(|i| i.flow_type == FlowType::ConditionalBranch)
        .count();
    assert_eq!(branches, 2);

    // Should have add instruction
    let add_instr = instructions.iter().find(|i| i.mnemonic == "add");
    assert!(add_instr.is_some());

    // Verify instruction offsets are sequential and correct
    for (i, instruction) in instructions.iter().enumerate() {
        if i > 0 {
            assert!(instruction.offset > instructions[i - 1].offset);
        }
    }

    Ok(())
}

/// Test bitwise operations roundtrip correctly.
#[test]
fn test_bitwise_operations_roundtrip() -> Result<()> {
    let mut asm = InstructionAssembler::new();
    asm.ldc_i4_const(0b1010)? // Load binary pattern
        .ldc_i4_const(0b1100)? // Load another pattern
        .and()? // Bitwise AND
        .ldc_i4_const(0b0011)?
        .or()? // Bitwise OR
        .ldc_i4_const(0b1111)?
        .xor()? // Bitwise XOR
        .not()? // Bitwise NOT
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;

    // Find bitwise operations
    let and_instr = instructions.iter().find(|i| i.mnemonic == "and").unwrap();
    let or_instr = instructions.iter().find(|i| i.mnemonic == "or").unwrap();
    let xor_instr = instructions.iter().find(|i| i.mnemonic == "xor").unwrap();
    let not_instr = instructions.iter().find(|i| i.mnemonic == "not").unwrap();

    // All should have sequential flow
    assert_eq!(and_instr.flow_type, FlowType::Sequential);
    assert_eq!(or_instr.flow_type, FlowType::Sequential);
    assert_eq!(xor_instr.flow_type, FlowType::Sequential);
    assert_eq!(not_instr.flow_type, FlowType::Sequential);

    Ok(())
}

/// Test shift operations roundtrip correctly.
#[test]
fn test_shift_operations_roundtrip() -> Result<()> {
    let mut asm = InstructionAssembler::new();
    asm.ldc_i4_const(8)? // Load value to shift
        .ldc_i4_1()? // Shift amount
        .shl()? // Shift left
        .ldc_i4_2()?
        .shr()? // Shift right (signed)
        .ldc_i4_1()?
        .shr_un()? // Shift right (unsigned)
        .neg()? // Negate
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;

    let shl_instr = instructions.iter().find(|i| i.mnemonic == "shl").unwrap();
    let shr_instr = instructions.iter().find(|i| i.mnemonic == "shr").unwrap();
    let shr_un_instr = instructions
        .iter()
        .find(|i| i.mnemonic == "shr.un")
        .unwrap();
    let neg_instr = instructions.iter().find(|i| i.mnemonic == "neg").unwrap();

    // All should have sequential flow
    assert_eq!(shl_instr.flow_type, FlowType::Sequential);
    assert_eq!(shr_instr.flow_type, FlowType::Sequential);
    assert_eq!(shr_un_instr.flow_type, FlowType::Sequential);
    assert_eq!(neg_instr.flow_type, FlowType::Sequential);

    Ok(())
}

/// Test type conversion instructions roundtrip correctly.
#[test]
fn test_conversion_instructions_roundtrip() -> Result<()> {
    let mut asm = InstructionAssembler::new();
    asm.ldc_i4_const(42)?
        .conv_i1()? // Convert to int8
        .conv_i2()? // Convert to int16
        .conv_i4()? // Convert to int32
        .conv_i8()? // Convert to int64
        .conv_r4()? // Convert to float32
        .conv_r8()? // Convert to float64
        .conv_u4()? // Convert to uint32
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;

    let conv_instructions: Vec<_> = instructions
        .iter()
        .filter(|i| i.mnemonic.starts_with("conv."))
        .collect();

    assert_eq!(conv_instructions.len(), 7);
    assert_eq!(conv_instructions[0].mnemonic, "conv.i1");
    assert_eq!(conv_instructions[1].mnemonic, "conv.i2");
    assert_eq!(conv_instructions[2].mnemonic, "conv.i4");
    assert_eq!(conv_instructions[3].mnemonic, "conv.i8");
    assert_eq!(conv_instructions[4].mnemonic, "conv.r4");
    assert_eq!(conv_instructions[5].mnemonic, "conv.r8");
    assert_eq!(conv_instructions[6].mnemonic, "conv.u4");

    // All conversions should have sequential flow
    for conv in &conv_instructions {
        assert_eq!(conv.flow_type, FlowType::Sequential);
    }

    Ok(())
}

/// Test comparison instructions roundtrip correctly.
#[test]
fn test_comparison_instructions_roundtrip() -> Result<()> {
    let mut asm = InstructionAssembler::new();
    asm.ldc_i4_const(10)?
        .ldc_i4_const(20)?
        .ceq()? // Compare equal
        .pop()? // Remove result
        .ldc_i4_const(30)?
        .ldc_i4_const(40)?
        .cgt()? // Compare greater than
        .pop()?
        .ldc_i4_const(50)?
        .ldc_i4_const(60)?
        .clt()? // Compare less than
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;

    // Find comparison instructions (these are 0xFE prefixed)
    let ceq_instr = instructions.iter().find(|i| i.mnemonic == "ceq").unwrap();
    let cgt_instr = instructions.iter().find(|i| i.mnemonic == "cgt").unwrap();
    let clt_instr = instructions.iter().find(|i| i.mnemonic == "clt").unwrap();

    // All should have sequential flow
    assert_eq!(ceq_instr.flow_type, FlowType::Sequential);
    assert_eq!(cgt_instr.flow_type, FlowType::Sequential);
    assert_eq!(clt_instr.flow_type, FlowType::Sequential);

    Ok(())
}

/// Test null and reference operations roundtrip correctly.
#[test]
fn test_null_reference_operations_roundtrip() -> Result<()> {
    use dotscope::metadata::token::Token;

    let string_token = Token::new(0x70000001); // Example string token
    let type_token = Token::new(0x02000001); // Example type token

    let mut asm = InstructionAssembler::new();
    asm.ldnull()? // Load null reference
        .ldstr(string_token)? // Load string literal
        .pop()? // Remove string
        .ldarg_0()? // Load object reference
        .isinst(type_token)? // Instance check
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;

    let ldnull_instr = instructions
        .iter()
        .find(|i| i.mnemonic == "ldnull")
        .unwrap();
    let ldstr_instr = instructions.iter().find(|i| i.mnemonic == "ldstr").unwrap();
    let isinst_instr = instructions
        .iter()
        .find(|i| i.mnemonic == "isinst")
        .unwrap();

    // Verify flow types
    assert_eq!(ldnull_instr.flow_type, FlowType::Sequential);
    assert_eq!(ldstr_instr.flow_type, FlowType::Sequential);
    assert_eq!(isinst_instr.flow_type, FlowType::Sequential);

    Ok(())
}

/// Test object creation and field operations roundtrip correctly.
#[test]
fn test_object_field_operations_roundtrip() -> Result<()> {
    use dotscope::metadata::token::Token;

    let constructor_token = Token::new(0x0A000001);
    let field_token = Token::new(0x04000001);
    let static_field_token = Token::new(0x04000002);

    let mut asm = InstructionAssembler::new();
    asm.newobj(constructor_token)? // Create new object
        .dup()? // Duplicate reference
        .ldc_i4_const(42)?
        .stfld(field_token)? // Store to instance field
        .ldsfld(static_field_token)? // Load static field
        .add()? // Add values
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;

    let newobj_instr = instructions
        .iter()
        .find(|i| i.mnemonic == "newobj")
        .unwrap();
    let stfld_instr = instructions.iter().find(|i| i.mnemonic == "stfld").unwrap();
    let ldsfld_instr = instructions
        .iter()
        .find(|i| i.mnemonic == "ldsfld")
        .unwrap();

    // Verify flow types
    assert_eq!(newobj_instr.flow_type, FlowType::Call); // newobj calls constructor
    assert_eq!(stfld_instr.flow_type, FlowType::Sequential);
    assert_eq!(ldsfld_instr.flow_type, FlowType::Sequential);

    Ok(())
}

/// Test array operations roundtrip correctly.
#[test]
fn test_array_operations_roundtrip() -> Result<()> {
    use dotscope::metadata::token::Token;

    let int32_type_token = Token::new(0x02000001); // System.Int32

    let mut asm = InstructionAssembler::new();
    asm.ldc_i4_const(10)? // Array size
        .newarr(int32_type_token)? // Create new array
        .dup()? // Duplicate array reference
        .ldc_i4_0()? // Index 0
        .ldc_i4_const(42)? // Value to store
        .stelem_i4()? // Store element
        .dup()? // Duplicate array reference
        .ldc_i4_0()? // Index 0
        .ldelem_i4()? // Load element
        .ldlen()? // Get array length
        .add()? // Add element + length
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;

    let newarr_instr = instructions
        .iter()
        .find(|i| i.mnemonic == "newarr")
        .unwrap();
    let stelem_instr = instructions
        .iter()
        .find(|i| i.mnemonic == "stelem.i4")
        .unwrap();
    let ldelem_instr = instructions
        .iter()
        .find(|i| i.mnemonic == "ldelem.i4")
        .unwrap();
    let ldlen_instr = instructions.iter().find(|i| i.mnemonic == "ldlen").unwrap();

    // Verify flow types
    assert_eq!(newarr_instr.flow_type, FlowType::Sequential);
    assert_eq!(stelem_instr.flow_type, FlowType::Sequential);
    assert_eq!(ldelem_instr.flow_type, FlowType::Sequential);
    assert_eq!(ldlen_instr.flow_type, FlowType::Sequential);

    Ok(())
}

/// Test long form branch instructions roundtrip correctly.
#[test]
fn test_long_form_branches_roundtrip() -> Result<()> {
    let mut asm = InstructionAssembler::new();
    asm.ldarg_0()?
        .brfalse("false_case")? // Long form branch
        .ldc_i4_1()?
        .br("end")? // Long form unconditional branch
        .label("false_case")?
        .ldarg_1()?
        .ldarg_2()?
        .beq("equal_case")? // Long form equality branch
        .ldc_i4_0()?
        .br("end")?
        .label("equal_case")?
        .ldc_i4_const(100)?
        .label("end")?
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;

    // Find long form branch instructions
    let brfalse_instr = instructions
        .iter()
        .find(|i| i.mnemonic == "brfalse")
        .unwrap();
    let br_instr = instructions.iter().find(|i| i.mnemonic == "br").unwrap();
    let beq_instr = instructions.iter().find(|i| i.mnemonic == "beq").unwrap();

    // Verify flow types
    assert_eq!(brfalse_instr.flow_type, FlowType::ConditionalBranch);
    assert_eq!(br_instr.flow_type, FlowType::UnconditionalBranch);
    assert_eq!(beq_instr.flow_type, FlowType::ConditionalBranch);

    Ok(())
}

/// Test convenience methods roundtrip correctly.
#[test]
fn test_convenience_methods_roundtrip() -> Result<()> {
    let mut asm = InstructionAssembler::new();
    asm.ldc_bool(true)? // Boolean constant
        .ldc_bool(false)?
        .check_null_and_branch(0, "not_null")? // Null check pattern
        .ldc_i4_0()? // Null case
        .ret()?
        .label("not_null")?
        .compare_args_and_branch(1, 2, "equal")? // Argument comparison
        .ldc_i4_1()? // Not equal case
        .ret()?
        .label("equal")?
        .ldc_i4_2()? // Equal case
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify structure
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;

    // Should have multiple return statements
    let returns = instructions.iter().filter(|i| i.mnemonic == "ret").count();
    assert_eq!(returns, 3);

    // Should have boolean constants (ldc.i4.1 and ldc.i4.0)
    let bool_constants: Vec<_> = instructions
        .iter()
        .filter(|i| matches!(i.mnemonic, "ldc.i4.1" | "ldc.i4.0"))
        .collect();
    assert!(bool_constants.len() >= 2);

    // Should have branch instructions from convenience methods
    let branches: Vec<_> = instructions
        .iter()
        .filter(|i| matches!(i.flow_type, FlowType::ConditionalBranch))
        .collect();
    assert!(branches.len() >= 2);

    Ok(())
}

/// Test exception handling instructions roundtrip correctly.
#[test]
fn test_exception_handling_roundtrip() -> Result<()> {
    use dotscope::metadata::token::Token;

    let exception_type_token = Token::new(0x02000001);

    let mut asm = InstructionAssembler::new();
    asm.ldarg_0()?
        .brfalse_s("throw_exception")?
        .ldarg_1()?
        .ret()?
        .label("throw_exception")?
        .newobj(exception_type_token)? // Create exception
        .throw()? // Throw exception
        .ret()?; // Unreachable

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;

    let throw_instr = instructions.iter().find(|i| i.mnemonic == "throw").unwrap();

    // Throw should have the correct flow type
    assert_eq!(throw_instr.flow_type, FlowType::Throw);

    Ok(())
}

/// Test comprehensive mixed instruction types roundtrip.
#[test]
fn test_mixed_instruction_types_roundtrip() -> Result<()> {
    use dotscope::metadata::token::Token;

    let field_token = Token::new(0x04000001);

    // Simulate a more complex method with various instruction types
    let mut asm = InstructionAssembler::new();
    asm.ldarg_0()? // Load 'this'
        .ldfld(field_token)? // Load instance field
        .ldc_i4_const(10)?
        .ceq()? // Compare equal
        .brfalse_s("not_ten")?
        // True case: perform bitwise operations
        .ldarg_1()?
        .ldc_i4_const(0xFF)?
        .and()? // Mask with 0xFF
        .conv_u1()? // Convert to byte
        .ret()?
        .label("not_ten")?
        // False case: arithmetic operations
        .ldarg_1()?
        .ldarg_2()?
        .mul()? // Multiply
        .ldc_i4_2()?
        .shl()? // Shift left by 2 (multiply by 4)
        .neg()? // Negate result
        .ret()?;

    let (bytecode, _max_stack) = asm.finish()?;

    // Disassemble and verify comprehensive coverage
    let instructions = decode_stream(&mut Parser::new(&bytecode), 0x1000)?;

    // Should contain various instruction categories
    let categories = [
        "ldarg.0",
        "ldfld",
        "ldc.i4.s",
        "ceq",
        "brfalse.s",
        "ldarg.1",
        "and",
        "conv.u1",
        "mul",
        "shl",
        "neg",
        "ret",
    ];

    for category in &categories {
        let found = instructions.iter().any(|i| i.mnemonic == *category);
        assert!(found, "Missing instruction: {category}");
    }

    // Verify we have the expected number of returns
    let returns = instructions.iter().filter(|i| i.mnemonic == "ret").count();
    assert_eq!(returns, 2);

    // Verify branch exists with correct flow type
    let branch = instructions
        .iter()
        .find(|i| i.mnemonic == "brfalse.s")
        .unwrap();
    assert_eq!(branch.flow_type, FlowType::ConditionalBranch);

    Ok(())
}
