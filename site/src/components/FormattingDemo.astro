---
import MonacoEditor from './MonacoEditor.astro';
const sample = `public class TestClass { public void Loops(){ System.Console.WriteLine("test"); } }`;
const rawBase = import.meta.env.BASE_URL || '/';
const base = rawBase.endsWith('/') ? rawBase : `${rawBase}/`;
---
<section class="w-full px-4 py-8 md:px-8">
  <div class="prose prose-slate dark:prose-invert">
    <p>Experience clean, consistent formatting by editing C# code and seeing the transformed output instantly.</p>
  </div>
  <div class="mt-6 grid gap-4 md:grid-cols-2">
    <div>
      <div class="mb-2 text-sm" style="color: var(--mc-on-surface-variant)">Input C#</div>
      <MonacoEditor id="fmt-monaco" value={sample} language="csharp" height="460px" />
      <div class="mt-3 flex gap-2">
        <button id="fmt-run" class="btn btn-mc-primary">Format</button>
      </div>
    </div>
    <div>
      <div class="mb-2 text-sm" style="color: var(--mc-on-surface-variant)">Formatted</div>
      <div class="h-[460px] w-full overflow-auto rounded-lg border backdrop-blur-sm" 
           style="background: color-mix(in oklab, var(--mc-surface-variant) 15%, transparent); 
                  border-color: color-mix(in oklab, var(--mc-outline-variant) 30%, transparent);">
        <pre id="fmt-out" class="p-4 font-mono text-[13px] leading-6" 
             style="color: var(--mc-on-surface); white-space: pre-wrap;"></pre>
      </div>
    </div>
  </div>
</section>

<script type="module" define:vars={{ base }}>
  function wasmUrl() {
    const b = base.endsWith('/') ? base : `${base}/`;
    return new URL(`${b}wasm/bsharp_wasm.js`, window.location.origin).toString();
  }
  const $ = (s) => document.querySelector(s);
  const cout = $('#fmt-out');
  const btn = $('#fmt-run');
  let monacoEditor = null;
  
  // Wait for Monaco editor to be initialized
  function waitForEditor() {
    return new Promise((resolve) => {
      const checkEditor = () => {
        const container = $('#fmt-monaco');
        if (container && container.querySelector('.monaco-editor')) {
          const editorElement = container.querySelector('.monaco-editor');
          // Get the editor instance from global Monaco editors
          if (window.monacoEditors && window.monacoEditors['fmt-monaco']) {
            monacoEditor = window.monacoEditors['fmt-monaco'];
            resolve(monacoEditor);
          } else {
            setTimeout(checkEditor, 100);
          }
        } else {
          setTimeout(checkEditor, 100);
        }
      };
      checkEditor();
    });
  }
  
  async function loadWasm(){
    const mod = await import(wasmUrl());
    if (mod && mod.default) await mod.default();
    return mod;
  }
  
  btn?.addEventListener('click', async () => {
    try {
      const mod = await loadWasm();
      if (!monacoEditor) {
        await waitForEditor();
      }
      if (monacoEditor) {
        const res = await mod.format_code(monacoEditor.getValue());
        cout.textContent = res;
      }
    } catch(e) {
      cout.textContent = 'Format error: ' + (e?.message || String(e));
    }
  });
  
  // Auto-format on load
  window.addEventListener('load', async () => {
    await waitForEditor();
    btn?.click();
  });
</script>
