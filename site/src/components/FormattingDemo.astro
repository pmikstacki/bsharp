---
import MonacoInstance from './MonacoInstance.astro';
const sample = `public class TestClass { public void Loops(){ System.Console.WriteLine("test"); } }`;
const rawBase = import.meta.env.BASE_URL || '/';
const base = rawBase.endsWith('/') ? rawBase : `${rawBase}/`;
---
<section class="w-full px-4 py-8 md:px-8 demo-formatting">
  <p style="color: var(--mc-on-surface-variant)">Experience clean, consistent formatting by editing C# code and seeing the transformed output instantly.</p>
  <div class="mt-6 grid gap-4 md:grid-cols-2">
    <div>
      <label class="mb-2 block text-sm" style="color: var(--mc-on-surface-variant)">Input C#</label>
      <MonacoInstance id="fmt-monaco" initial={sample} height="460px" />
      <div class="mt-3 flex gap-2">
        <button id="fmt-run" class="btn btn-mc-primary">Format</button>
      </div>
    </div>
    <div>
      <label class="mb-2 block text-sm" style="color: var(--mc-on-surface-variant)">Formatted</label>
      <MonacoInstance id="fmt-out" initial="" height="460px" />
    </div>
  </div>
</section>

<script type="module" define:vars={{ base }}>
  function wasmUrl() {
    const b = base.endsWith('/') ? base : `${base}/`;
    return new URL(`${b}wasm/bsharp_wasm.js`, window.location.origin).toString();
  }
  const $ = (s) => document.querySelector(s);
  const btn = $('#fmt-run');
  let inputEditor = null;
  let outputEditor = null;
  
  // Wait for both Monaco editors to be initialized
  function waitForEditors() {
    return new Promise((resolve) => {
      const checkEditors = () => {
        const inputContainer = $('#fmt-monaco');
        const outputContainer = $('#fmt-out');
        
        if (inputContainer && inputContainer.querySelector('.monaco-editor') &&
            outputContainer && outputContainer.querySelector('.monaco-editor')) {
          // Get the editor instances from global Monaco editors
          const inputEd = window.__monacoEditors?.['fmt-monaco'];
          const outputEd = window.__monacoEditors?.['fmt-out'];
          
          if (inputEd && outputEd) {
            inputEditor = inputEd;
            outputEditor = outputEd;
            resolve({ inputEditor, outputEditor });
          } else {
            setTimeout(checkEditors, 100);
          }
        } else {
          setTimeout(checkEditors, 100);
        }
      };
      checkEditors();
    });
  }
  
  async function loadWasm(){
    const mod = await import(wasmUrl());
    if (mod && mod.default) await mod.default();
    return mod;
  }
  
  btn?.addEventListener('click', async () => {
    try {
      const mod = await loadWasm();
      if (!inputEditor || !outputEditor) {
        await waitForEditors();
      }
      if (inputEditor && outputEditor) {
        const res = await mod.format_code(inputEditor.getValue());
        outputEditor.setValue(res);
      }
    } catch(e) {
      if (outputEditor) {
        outputEditor.setValue('Format error: ' + (e?.message || String(e)));
      }
    }
  });
  
  // Auto-format on load
  window.addEventListener('load', async () => {
    await waitForEditors();
    btn?.click();
  });
</script>

<style>
</style>
