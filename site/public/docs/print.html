<!DOCTYPE HTML>
<html lang="en" class="dark js">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>BSharp C# Parser Documentation</title>
    <meta name="robots" content="noindex">
    <!-- BSharp mdBook Custom Head -->
    <meta name="theme-color" content="#00C9B9">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <style>
      /* Additional custom styles */
      .header .left a::before {
        content: "B# ";
        color: #00C9B9;
        font-weight: 700;
      }
      
      /* Force dark theme immediately */
      html, html.light, html.dark {
        color-scheme: dark !important;
      }
      
      html body, body, .light body, .dark body {
        background: linear-gradient(66.77deg, #00C9B9 0%, #003824 100%) !important;
        background-color: transparent !important;
        color: #dfe4e3 !important;
      }
      
      .header, .light .header, .dark .header {
        background-color: rgba(15, 20, 20, 0.7) !important;
        backdrop-filter: blur(20px) !important;
        -webkit-backdrop-filter: blur(20px) !important;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1) !important;
      }
      
      .sidebar, .light .sidebar, .dark .sidebar {
        background-color: rgba(15, 20, 20, 0.7) !important;
        backdrop-filter: blur(20px) !important;
        -webkit-backdrop-filter: blur(20px) !important;
        border-right: 1px solid rgba(255, 255, 255, 0.1) !important;
      }
      
      .content, .light .content, .dark .content {
        background-color: rgba(15, 20, 20, 0.6) !important;
        backdrop-filter: blur(10px) !important;
        -webkit-backdrop-filter: blur(10px) !important;
        color: #dfe4e3 !important;
      }
      
      /* Hide theme selector */
      .theme-selector {
        display: none !important;
      }
    </style>
    <script>
      // Force dark mode and prevent theme switching
      (function() {
        // Set dark mode immediately
        document.documentElement.classList.remove('light');
        document.documentElement.classList.add('dark');
        localStorage.setItem('mdbook-theme', 'dark');
        
        // Override localStorage to always return dark
        const originalSetItem = localStorage.setItem;
        const originalGetItem = localStorage.getItem;
        
        localStorage.setItem = function(key, value) {
          if (key === 'mdbook-theme') {
            value = 'dark';
          }
          return originalSetItem.call(this, key, value);
        };
        
        localStorage.getItem = function(key) {
          if (key === 'mdbook-theme') {
            return 'dark';
          }
          return originalGetItem.call(this, key);
        };
        
        // Continuously enforce dark mode
        setInterval(function() {
          document.documentElement.classList.remove('light');
          document.documentElement.classList.add('dark');
        }, 50);
        
        // Hide theme selector if it exists
        setTimeout(function() {
          const themeSelector = document.querySelector('.theme-selector');
          if (themeSelector) {
            themeSelector.style.display = 'none';
          }
        }, 100);
      })();
    </script>
</head>
<body>
    <!-- Provide site root to javascript -->
    <script>
        var path_to_root = "";
        var default_theme = "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script>
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script>
        var html = document.querySelector('html');
        var sidebar = null;
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
            sidebar = sidebar || 'visible';
        } else {
            sidebar = 'hidden';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scroll">
            <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Parser Architecture</li><li class="chapter-item expanded "><a href="parser/overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="parser/core-components.html"><strong aria-hidden="true">2.</strong> Core Components</a></li><li class="chapter-item expanded "><a href="parser/ast-structure.html"><strong aria-hidden="true">3.</strong> AST Structure</a></li><li class="chapter-item expanded "><a href="parser/error-handling.html"><strong aria-hidden="true">4.</strong> Error Handling</a></li><li class="chapter-item expanded affix "><li class="part-title">Parser Modules</li><li class="chapter-item expanded "><a href="parser/expressions.html"><strong aria-hidden="true">5.</strong> Expression Parsing</a></li><li class="chapter-item expanded "><a href="parser/statements.html"><strong aria-hidden="true">6.</strong> Statement Parsing</a></li><li class="chapter-item expanded "><a href="parser/declarations.html"><strong aria-hidden="true">7.</strong> Declaration Parsing</a></li><li class="chapter-item expanded "><a href="parser/types.html"><strong aria-hidden="true">8.</strong> Type System</a></li><li class="chapter-item expanded "><a href="parser/feature-completeness.html"><strong aria-hidden="true">9.</strong> Feature Completeness</a></li><li class="chapter-item expanded "><a href="parser/keywords-and-tokens.html"><strong aria-hidden="true">10.</strong> Keywords and Tokens</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Features</li><li class="chapter-item expanded "><a href="parser/navigation.html"><strong aria-hidden="true">11.</strong> Query API</a></li><li class="chapter-item expanded "><a href="parser/comments.html"><strong aria-hidden="true">12.</strong> Comment Parsing</a></li><li class="chapter-item expanded "><a href="parser/preprocessor.html"><strong aria-hidden="true">13.</strong> Preprocessor Directives</a></li><li class="chapter-item expanded affix "><li class="part-title">Syntax</li><li class="chapter-item expanded "><a href="syntax/spans.html"><strong aria-hidden="true">14.</strong> Spans</a></li><li class="chapter-item expanded "><a href="syntax/traits.html"><strong aria-hidden="true">15.</strong> Traits</a></li><li class="chapter-item expanded "><a href="syntax/derive-macros.html"><strong aria-hidden="true">16.</strong> Derive Macros</a></li><li class="chapter-item expanded "><a href="syntax/formatter.html"><strong aria-hidden="true">17.</strong> Formatter and Emitters</a></li><li class="chapter-item expanded affix "><li class="part-title">Analysis Framework</li><li class="chapter-item expanded "><a href="analysis/overview.html"><strong aria-hidden="true">18.</strong> Analysis Overview</a></li><li class="chapter-item expanded "><a href="analysis/pipeline.html"><strong aria-hidden="true">19.</strong> Analysis Pipeline</a></li><li class="chapter-item expanded "><a href="analysis/traversal-guide.html"><strong aria-hidden="true">20.</strong> Traversal Guide</a></li><li class="chapter-item expanded "><a href="analysis/control-flow.html"><strong aria-hidden="true">21.</strong> Control Flow Analysis</a></li><li class="chapter-item expanded "><a href="analysis/dependencies.html"><strong aria-hidden="true">22.</strong> Dependency Analysis</a></li><li class="chapter-item expanded "><a href="analysis/metrics.html"><strong aria-hidden="true">23.</strong> Metrics Collection</a></li><li class="chapter-item expanded "><a href="analysis/types.html"><strong aria-hidden="true">24.</strong> Type Analysis</a></li><li class="chapter-item expanded "><a href="analysis/quality.html"><strong aria-hidden="true">25.</strong> Code Quality</a></li><li class="chapter-item expanded "><a href="analysis/passes-and-rules.html"><strong aria-hidden="true">26.</strong> Passes and Rules</a></li><li class="chapter-item expanded "><a href="analysis/report-schema.html"><strong aria-hidden="true">27.</strong> Report Schema</a></li><li class="chapter-item expanded "><a href="analysis/writing-a-pass.html"><strong aria-hidden="true">28.</strong> Writing a Pass</a></li><li class="chapter-item expanded "><a href="analysis/writing-a-ruleset.html"><strong aria-hidden="true">29.</strong> Writing a Ruleset</a></li><li class="chapter-item expanded affix "><li class="part-title">CLI Tools</li><li class="chapter-item expanded "><a href="cli/overview.html"><strong aria-hidden="true">30.</strong> Command Line Interface</a></li><li class="chapter-item expanded "><a href="cli/parse.html"><strong aria-hidden="true">31.</strong> Parse Command</a></li><li class="chapter-item expanded "><a href="cli/tree.html"><strong aria-hidden="true">32.</strong> Tree Visualization</a></li><li class="chapter-item expanded "><a href="cli/analyze.html"><strong aria-hidden="true">33.</strong> Analysis Command</a></li><li class="chapter-item expanded "><a href="cli/format.html"><strong aria-hidden="true">34.</strong> Format Command</a></li><li class="chapter-item expanded "><a href="cli/errors-json.html"><strong aria-hidden="true">35.</strong> Parse Errors JSON</a></li><li class="chapter-item expanded affix "><li class="part-title">Workspace</li><li class="chapter-item expanded "><a href="workspace/overview.html"><strong aria-hidden="true">36.</strong> Workspace Loading</a></li><li class="chapter-item expanded affix "><li class="part-title">Configuration</li><li class="chapter-item expanded "><a href="configuration/overview.html"><strong aria-hidden="true">37.</strong> Configuration Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Development</li><li class="chapter-item expanded "><a href="development/contributing.html"><strong aria-hidden="true">38.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="development/testing.html"><strong aria-hidden="true">39.</strong> Testing</a></li><li class="chapter-item expanded "><a href="development/architecture.html"><strong aria-hidden="true">40.</strong> Architecture Decisions</a></li><li class="chapter-item expanded "><a href="development/cookbooks.html"><strong aria-hidden="true">41.</strong> Cookbooks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/query-cookbook.html"><strong aria-hidden="true">41.1.</strong> Query Cookbook</a></li><li class="chapter-item expanded "><a href="development/parser-cookbook.html"><strong aria-hidden="true">41.2.</strong> Parser Cookbook</a></li></ol></li><li class="chapter-item expanded "><a href="development/writing-tests.html"><strong aria-hidden="true">42.</strong> Writing Tests</a></li><li class="chapter-item expanded "><a href="development/bsharp_tests.html"><strong aria-hidden="true">43.</strong> bsharp_tests Overview</a></li><li class="chapter-item expanded "><a href="development/extending-syntax.html"><strong aria-hidden="true">44.</strong> Extending Syntax (New Nodes)</a></li><li class="chapter-item expanded "><a href="development/writing-parsers.html"><strong aria-hidden="true">45.</strong> Writing Parsers</a></li><li class="chapter-item expanded "><a href="development/compliance/index.html"><strong aria-hidden="true">46.</strong> Compliance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/compliance/overview.html"><strong aria-hidden="true">46.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="development/compliance/compliance_guide.html"><strong aria-hidden="true">46.2.</strong> Compliance Guide</a></li><li class="chapter-item expanded "><a href="development/compliance/Generator.html"><strong aria-hidden="true">46.3.</strong> Generator</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Research &amp; Development</li><li class="chapter-item expanded "><a href="cil-runtime/index.html"><strong aria-hidden="true">47.</strong> CIL Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cil-runtime/overview.html"><strong aria-hidden="true">47.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="cil-runtime/architecture.html"><strong aria-hidden="true">47.2.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/index.html"><strong aria-hidden="true">47.3.</strong> Phases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cil-runtime/phases/00-dotscope-spike.html"><strong aria-hidden="true">47.3.1.</strong> Phase 0: Dotscope Spike</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/01-vm-mvp.html"><strong aria-hidden="true">47.3.2.</strong> Phase 1: VM MVP</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/02-control-flow-and-eh.html"><strong aria-hidden="true">47.3.3.</strong> Phase 2: Control Flow + EH</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/03-object-model-and-arrays.html"><strong aria-hidden="true">47.3.4.</strong> Phase 3: Object Model and Arrays</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/04-back-compat-polish.html"><strong aria-hidden="true">47.3.5.</strong> Phase 4: Back-Compat Polish</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/05-ast-to-il-emitter.html"><strong aria-hidden="true">47.3.6.</strong> Phase 5: AST→IL Emitter</a></li></ol></li><li class="chapter-item expanded "><a href="cil-runtime/dotscope-guide.html"><strong aria-hidden="true">47.4.</strong> dotscope Guide</a></li><li class="chapter-item expanded "><a href="cil-runtime/vm-design.html"><strong aria-hidden="true">47.5.</strong> VM Design</a></li><li class="chapter-item expanded "><a href="cil-runtime/emitter-design.html"><strong aria-hidden="true">47.6.</strong> Emitter Design</a></li><li class="chapter-item expanded "><a href="cil-runtime/testing.html"><strong aria-hidden="true">47.7.</strong> Testing &amp; Conformance</a></li><li class="chapter-item expanded "><a href="cil-runtime/roadmap.html"><strong aria-hidden="true">47.8.</strong> Roadmap</a></li><li class="chapter-item expanded "><a href="cil-runtime/open-questions.html"><strong aria-hidden="true">47.9.</strong> Open Questions</a></li><li class="chapter-item expanded "><a href="cil-runtime/glossary.html"><strong aria-hidden="true">47.10.</strong> Glossary</a></li></ol></li></ol>
        </div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">

            <div id="content" class="content">
                <main>
                    <h1 id="bsharp-c-parser-documentation"><a class="header" href="#bsharp-c-parser-documentation">BSharp C# Parser Documentation</a></h1>
<p>BSharp is a comprehensive C# parser and analysis toolkit written in Rust. It provides a complete solution for parsing C# source code into an Abstract Syntax Tree (AST), performing various code analyses, and generating insights about code quality and structure.</p>
<h2 id="what-is-bsharp"><a class="header" href="#what-is-bsharp">What is BSharp?</a></h2>
<p>BSharp consists of several key components:</p>
<ul>
<li><strong>Parser</strong>: A robust C# parser built using the <code>nom</code> parser combinator library</li>
<li><strong>AST</strong>: A complete representation of C# language constructs</li>
<li><strong>Analysis Framework</strong>: Tools for analyzing code structure, dependencies, and quality</li>
<li><strong>CLI Tools</strong>: Command-line utilities for parsing, visualization, and analysis</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li>
<p><strong>Complete C# Language Support</strong>: Supports modern C# features including:</p>
<ul>
<li>Classes, structs, interfaces, records, enums</li>
<li>Methods, properties, fields, events, indexers</li>
<li>All statement types (if, for, while, switch, try-catch, etc.)</li>
<li>Expression parsing with operator precedence</li>
<li>Generic types and constraints</li>
<li>Attributes and modifiers</li>
<li>Preprocessor directives</li>
</ul>
</li>
<li>
<p><strong>Robust Error Handling</strong>: Custom error types with context information for debugging parse failures</p>
</li>
<li>
<p><strong>Query API</strong>: Typed, ergonomic traversal of the AST via <code>bsharp_analysis::framework::Query</code></p>
</li>
<li>
<p><strong>Code Analysis</strong>: Built-in analyzers for:</p>
<ul>
<li>Control flow analysis</li>
<li>Dependency tracking</li>
<li>Code metrics (complexity, maintainability)</li>
<li>Type analysis</li>
<li>Code quality assessment</li>
</ul>
</li>
<li>
<p><strong>Extensible Architecture</strong>: Modular design allowing easy extension of parsing and analysis capabilities</p>
</li>
</ul>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>The codebase is organized into several main modules:</p>
<pre><code>src/
├── bsharp_parser/    # Parser crate (expressions, statements, declarations, helpers)
├── bsharp_syntax/    # AST nodes and shared syntax types (re-exported by parser)
├── bsharp_analysis/  # Analysis framework and workspace loader
├── bsharp_cli/       # Command-line interface
└── bsharp_tests/     # External tests for parser/analysis/CLI
</code></pre>
<h3 id="key-components"><a class="header" href="#key-components">Key Components</a></h3>
<p><strong>Parser (<code>src/bsharp_parser/</code>, <code>src/bsharp_syntax/</code>)</strong></p>
<ul>
<li>Modular parser using nom combinators</li>
<li>Complete C# language support</li>
<li>Rich error diagnostics with ErrorTree</li>
<li>Keyword parsing organized by category</li>
<li>AST nodes follow PascalCase naming without 'Syntax' suffix</li>
</ul>
<p><strong>Workspace Loading (<code>src/bsharp_analysis/src/workspace/</code>)</strong></p>
<ul>
<li>Solution file (.sln) parsing</li>
<li>Project file (.csproj) parsing with XML</li>
<li>Transitive ProjectReference resolution</li>
<li>Source file discovery with glob patterns</li>
<li>Deterministic project ordering</li>
</ul>
<p><strong>Analysis Framework (<code>src/bsharp_analysis/src/</code>)</strong></p>
<ul>
<li>Pipeline-based architecture with phases</li>
<li>Extensible passes and rules system</li>
<li>Metrics collection (complexity, maintainability)</li>
<li>Control flow analysis</li>
<li>Dependency tracking</li>
<li>Code quality assessment</li>
</ul>
<!-- Code generation/compilation is currently out of scope and intentionally omitted. -->
<p><strong>CLI Tools (<code>src/bsharp_cli/</code>)</strong></p>
<ul>
<li><code>parse</code> - Parse C# and print textual AST tree</li>
<li><code>tree</code> - Generate AST visualization (Mermaid/DOT)</li>
<li><code>analyze</code> - Comprehensive code analysis</li>
<li><code>format</code> - Format C# code using syntax emitters</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>The easiest way to get started is using the CLI tools:</p>
<pre><code class="language-bash"># Parse a C# file and print textual AST tree
bsharp parse input.cs

# Generate AST visualization
bsharp tree input.cs --output ast.svg

# Analyze a project or solution
bsharp analyze MyProject.csproj --out report.json

# Format a file in-place (or a directory recursively)
bsharp format input.cs --write true
</code></pre>
<h2 id="formatter-quickstart"><a class="header" href="#formatter-quickstart">Formatter Quickstart</a></h2>
<p>Use the built-in formatter from the CLI or integrate the <code>Formatter</code> directly.</p>
<ul>
<li>CLI usage and options: see <a href="./cli/format.html">Format Command</a></li>
<li>Formatter design and policies: see <a href="./syntax/formatter.html">Formatter and Emitters</a></li>
</ul>
<p>Quick examples:</p>
<pre><code class="language-bash"># Format a single file in-place
bsharp format Program.cs

# Print formatted output (do not write)
bsharp format Program.cs --write false

# Enable emission tracing to a JSONL file
bsharp format Program.cs --emit-trace --emit-trace-file format_trace.jsonl
</code></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p>BSharp is designed for:</p>
<ul>
<li><strong>Static Analysis Tools</strong>: Build custom analyzers for code quality, security, or style</li>
<li><strong>Code Transformation</strong>: Parse, modify, and regenerate C# code</li>
<li><strong>Language Tooling</strong>: Create IDE extensions, linters, or formatters</li>
<li><strong>Educational Tools</strong>: Understand and visualize C# code structure</li>
<li><strong>Migration Tools</strong>: Analyze legacy code for modernization efforts</li>
</ul>
<p>This documentation will guide you through all aspects of using and extending BSharp.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parser-overview"><a class="header" href="#parser-overview">Parser Overview</a></h1>
<p>The BSharp parser transforms C# source code into a structured Abstract Syntax Tree (AST). Built using the <code>nom</code> parser combinator library, it provides a robust and extensible foundation for parsing modern C# syntax as part of the BSharp toolkit.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>The parser follows a modular architecture with clear separation of concerns. It serves as the frontend for tools that consume the AST (analysis, visualization, etc.):</p>
<h3 id="parser-infrastructure-srcbsharp_syntaxsrc"><a class="header" href="#parser-infrastructure-srcbsharp_syntaxsrc">Parser Infrastructure (<code>src/bsharp_syntax/src/</code>)</a></h3>
<ul>
<li><strong><code>mod.rs</code></strong>: Public API and re-exports</li>
<li><strong><code>ast.rs</code></strong>: Root AST node definitions (<code>CompilationUnit</code>, <code>TopLevelDeclaration</code>)</li>
<li><strong><code>errors.rs</code></strong>: Error formatting utilities (<code>format_error_tree</code>)</li>
<li><strong><code>parser_helpers.rs</code></strong>: Core parsing utilities (<code>context</code>, <code>bws</code>, <code>keyword</code>, etc.)</li>
<li><strong><code>test_helpers.rs</code></strong>: Testing utilities (<code>expect_ok</code>, etc.)</li>
<li><strong><code>nodes/</code></strong>: AST node definitions organized by category</li>
</ul>
<h3 id="parser-implementations-srcbsharp_parsersrc"><a class="header" href="#parser-implementations-srcbsharp_parsersrc">Parser Implementations (<code>src/bsharp_parser/src/</code>)</a></h3>
<p>The parsers are organized by language construct type:</p>
<ul>
<li><strong><code>expressions/</code></strong>: All expression parsing (literals, operators, method calls, etc.)</li>
<li><strong><code>keywords/</code></strong>: Keyword parsing organized by category</li>
<li><strong><code>types/</code></strong>: Type system parsing (primitives, generics, arrays, etc.)</li>
<li><strong><code>helpers/</code></strong>: Declaration helpers and utilities</li>
<li><strong><code>preprocessor/</code></strong>: Preprocessor directive parsing</li>
</ul>
<h3 id="ast-node-definitions-srcbsharp_syntaxsrc"><a class="header" href="#ast-node-definitions-srcbsharp_syntaxsrc">AST Node Definitions (<code>src/bsharp_syntax/src/</code>)</a></h3>
<p>Structured node definitions that mirror C# language constructs:</p>
<ul>
<li><strong><code>declarations/</code></strong>: All declaration node types</li>
<li><strong><code>expressions/</code></strong>: All expression node types</li>
<li><strong><code>statements/</code></strong>: All statement node types</li>
<li><strong><code>types/</code></strong>: Type system node definitions</li>
</ul>
<h2 id="parser-design-principles"><a class="header" href="#parser-design-principles">Parser Design Principles</a></h2>
<h3 id="1-compositional-design"><a class="header" href="#1-compositional-design">1. Compositional Design</a></h3>
<p>The parser is built from small, focused parser functions that combine to handle complex language constructs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example: Method declaration combines multiple sub-parsers
fn parse_method_declaration(input: &amp;str) -&gt; BResult&lt;&amp;str, MethodDeclaration&gt; {
    let (input, attributes) = parse_attributes(input.into())?;
    let (input, modifiers) = parse_modifiers(input.into())?;
    let (input, return_type) = parse_type(input.into())?;
    let (input, name) = parse_identifier(input.into())?;
    let (input, parameters) = parse_parameter_list(input.into())?;
    let (input, body) = opt(parse_block_statement)(input.into())?;
    // ... construct and return MethodDeclaration
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-error-recovery-and-context"><a class="header" href="#2-error-recovery-and-context">2. Error Recovery and Context</a></h3>
<p>Custom error types provide detailed context about parse failures:</p>
<ul>
<li>Location information (line, column)</li>
<li>Expected vs. actual input</li>
<li>Contextual error messages</li>
<li>Error recovery strategies</li>
</ul>
<h3 id="3-extensibility"><a class="header" href="#3-extensibility">3. Extensibility</a></h3>
<p>The modular design allows easy addition of new language features:</p>
<ul>
<li>Add new expression types by extending the <code>Expression</code> enum</li>
<li>Implement new statement parsers following established patterns</li>
<li>Extend AST navigation traits for new analysis capabilities</li>
</ul>
<h2 id="parsing-flow"><a class="header" href="#parsing-flow">Parsing Flow</a></h2>
<h3 id="1-entry-point"><a class="header" href="#1-entry-point">1. Entry Point</a></h3>
<p>Parsing begins via the public facade in <code>src/bsharp_parser/src/facade.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let parser = bsharp_parser::facade::Parser::new();
let cu = parser.parse(source)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-compilation-unit-parsing"><a class="header" href="#2-compilation-unit-parsing">2. Compilation Unit Parsing</a></h3>
<p>The parser starts by parsing a <code>CompilationUnit</code>, which represents a complete C# source file:</p>
<ul>
<li>Global attributes (assembly/module level)</li>
<li>Using directives</li>
<li>Top-level declarations (namespaces, classes, etc.)</li>
<li>File-scoped namespaces (C# 10+)</li>
<li>Top-level statements (C# 9+)</li>
</ul>
<h3 id="3-recursive-descent"><a class="header" href="#3-recursive-descent">3. Recursive Descent</a></h3>
<p>The parser uses recursive descent to handle nested structures:</p>
<ul>
<li>Namespaces contain type declarations</li>
<li>Types contain member declarations</li>
<li>Methods contain statements</li>
<li>Statements contain expressions</li>
</ul>
<h2 id="key-parser-features"><a class="header" href="#key-parser-features">Key Parser Features</a></h2>
<h3 id="expression-parsing-with-precedence"><a class="header" href="#expression-parsing-with-precedence">Expression Parsing with Precedence</a></h3>
<p>The expression parser handles operator precedence correctly:</p>
<ul>
<li>Primary expressions (literals, identifiers, parentheses)</li>
<li>Unary operators (!, -, +, ++, --, etc.)</li>
<li>Binary operators with correct precedence and associativity</li>
<li>Conditional expressions (ternary operator)</li>
<li>Assignment expressions</li>
</ul>
<h3 id="statement-parsing"><a class="header" href="#statement-parsing">Statement Parsing</a></h3>
<p>Comprehensive support for all C# statement types:</p>
<ul>
<li>Control flow: <code>if</code>, <code>switch</code>, <code>for</code>, <code>foreach</code>, <code>while</code>, <code>do-while</code></li>
<li>Jump statements: <code>break</code>, <code>continue</code>, <code>return</code>, <code>throw</code>, <code>goto</code></li>
<li>Exception handling: <code>try-catch-finally</code></li>
<li>Resource management: <code>using</code>, <code>lock</code></li>
<li>Local declarations and assignments</li>
</ul>
<h3 id="declaration-parsing"><a class="header" href="#declaration-parsing">Declaration Parsing</a></h3>
<p>Full support for C# type and member declarations:</p>
<ul>
<li>Types: classes, structs, interfaces, records, enums, delegates</li>
<li>Members: methods, properties, fields, events, indexers, operators</li>
<li>Modifiers: access modifiers, static, abstract, virtual, override, etc.</li>
<li>Generics: type parameters, constraints, variance</li>
</ul>
<h3 id="modern-c-features"><a class="header" href="#modern-c-features">Modern C# Features</a></h3>
<p>Support for recent C# language additions:</p>
<ul>
<li>Records (C# 9)</li>
<li>File-scoped namespaces (C# 10)</li>
<li>Top-level statements (C# 9)</li>
<li>Pattern matching enhancements</li>
<li>Nullable reference types</li>
</ul>
<h2 id="error-handling-strategy"><a class="header" href="#error-handling-strategy">Error Handling Strategy</a></h2>
<p>The parser uses a multi-layered error handling approach:</p>
<ol>
<li><strong>Parse Errors</strong>: Detailed information about what went wrong during parsing</li>
<li><strong>Context Propagation</strong>: Errors include context about where in the parsing process they occurred</li>
<li><strong>Recovery Mechanisms</strong>: Ability to continue parsing after certain types of errors</li>
<li><strong>User-Friendly Messages</strong>: Clear, actionable error messages for developers</li>
</ol>
<p>This design makes the parser robust and helpful for development and debugging. Code generation/compilation is out of scope for now; the parser and analysis crates form the current focus of the toolkit.</p>
<hr />
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="parser/./keywords-and-tokens.html">Keywords and Tokens</a> – keyword helpers, word boundaries, trivia handling</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-parser-components"><a class="header" href="#core-parser-components">Core Parser Components</a></h1>
<p>This document details the fundamental components that make up the BSharp parser infrastructure.</p>
<h2 id="public-parser-api"><a class="header" href="#public-parser-api">Public Parser API</a></h2>
<h3 id="parser-struct"><a class="header" href="#parser-struct">Parser Struct</a></h3>
<p>The main entry point for all parsing operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
pub struct Parser;

impl Parser {
    pub fn new() -&gt; Self
    pub fn parse(&amp;self, input: &amp;str) -&gt; Result&lt;ast::CompilationUnit, String&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Parser</code> provides a clean, simple interface that abstracts away the complexity of the underlying parsing implementation.</p>
<h2 id="error-system"><a class="header" href="#error-system">Error System</a></h2>
<h3 id="errortree-nom-supreme"><a class="header" href="#errortree-nom-supreme">ErrorTree (nom-supreme)</a></h3>
<p>BSharp uses nom-supreme's ErrorTree for rich error diagnostics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type BResult&lt;I, O&gt; = IResult&lt;I, O, ErrorTree&lt;I&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<p>Key features:</p>
<ul>
<li><strong>Context Stack</strong>: Maintains parsing contexts via <code>.context()</code> calls</li>
<li><strong>Position Tracking</strong>: Built-in span tracking for error locations</li>
<li><strong>Rich Diagnostics</strong>: Tree structure shows complete parse failure path</li>
<li><strong>Integration</strong>: Seamless with nom combinators</li>
</ul>
<h3 id="error-helpers"><a class="header" href="#error-helpers">Error Helpers</a></h3>
<p>Utility functions for enhanced error handling:</p>
<p><strong>Location:</strong> <code>src/bsharp_parser/src/helpers/</code></p>
<ul>
<li><code>context()</code>: Adds contextual information to parser errors</li>
<li><code>bws()</code>: Whitespace-aware wrapper with error context</li>
<li><code>bdelimited()</code>: Delimited parsing with cut on closing delimiter</li>
<li><code>cut()</code>: Commits to parse branch, preventing misleading backtracking</li>
<li>Error recovery mechanisms for common parsing scenarios</li>
</ul>
<h3 id="pretty-error-formatting"><a class="header" href="#pretty-error-formatting">Pretty Error Formatting</a></h3>
<p><strong>Location:</strong> <code>src/bsharp_parser/src/syntax/errors.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn format_error_tree(input: &amp;str, error: &amp;ErrorTree&lt;Span&lt;'_&gt;&gt;) -&gt; String;
<span class="boring">}</span></code></pre></pre>
<p>Produces rustc-like error messages with:</p>
<ul>
<li>Line and column numbers</li>
<li>Source code context</li>
<li>Caret pointing to error location</li>
<li>Context stack showing parse path</li>
</ul>
<h2 id="ast-foundation"><a class="header" href="#ast-foundation">AST Foundation</a></h2>
<h3 id="compilationunit"><a class="header" href="#compilationunit">CompilationUnit</a></h3>
<p>The root node of every parsed C# file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CompilationUnit {
    pub global_attributes: Vec&lt;GlobalAttribute&gt;,
    pub using_directives: Vec&lt;UsingDirective&gt;,
    pub global_using_directives: Vec&lt;GlobalUsingDirective&gt;,
    pub declarations: Vec&lt;TopLevelDeclaration&gt;,
    pub file_scoped_namespace: Option&lt;FileScopedNamespaceDeclaration&gt;,
    pub top_level_statements: Vec&lt;Statement&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Represents the complete structure of a C# source file, supporting both traditional and modern C# features.</p>
<h3 id="topleveldeclaration"><a class="header" href="#topleveldeclaration">TopLevelDeclaration</a></h3>
<p>Enum representing all possible top-level declarations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TopLevelDeclaration {
    Namespace(NamespaceDeclaration),
    FileScopedNamespace(FileScopedNamespaceDeclaration),
    Class(ClassDeclaration),
    Struct(StructDeclaration),
    Record(RecordDeclaration),
    Interface(InterfaceDeclaration),
    Enum(EnumDeclaration),
    Delegate(DelegateDeclaration),
    GlobalAttribute(GlobalAttribute),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="keyword-parsing"><a class="header" href="#keyword-parsing">Keyword Parsing</a></h2>
<h3 id="keyword-module-organization"><a class="header" href="#keyword-module-organization">Keyword Module Organization</a></h3>
<p><strong>Location:</strong> <code>src/bsharp_parser/src/keywords/</code></p>
<p>Keywords are organized by category in dedicated modules for maintainability and consistency:</p>
<pre><code>src/bsharp_parser/src/keywords/
├── mod.rs                      # Keyword infrastructure
├── access_keywords.rs          # public, private, protected, internal
├── accessor_keywords.rs        # get, set, init, add, remove
├── type_keywords.rs            # class, struct, interface, enum, record
├── modifier_keywords.rs        # static, abstract, virtual, sealed
├── flow_control_keywords.rs    # if, else, switch, case, default
├── iteration_keywords.rs       # for, foreach, while, do
├── expression_keywords.rs      # new, this, base, typeof, sizeof
├── linq_query_keywords.rs      # from, where, select, orderby
└── ...
</code></pre>
<h3 id="keyword-parsing-strategy"><a class="header" href="#keyword-parsing-strategy">Keyword Parsing Strategy</a></h3>
<p><strong>Word Boundary Enforcement:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn keyword(kw: &amp;'static str) -&gt; impl Fn(&amp;str) -&gt; BResult&lt;&amp;str, &amp;str&gt;;
<span class="boring">}</span></code></pre></pre>
<p>The <code>keyword()</code> helper enforces <code>[A-Za-z0-9_]</code> word boundaries to prevent partial matches:</p>
<ul>
<li>Correctly rejects "int" when parsing "int32"</li>
<li>Ensures "class" doesn't match "classname"</li>
<li>Consistent across all keyword parsers</li>
</ul>
<p><strong>Benefits:</strong></p>
<ul>
<li><strong>Maintainability</strong>: Easy to find and update keyword parsers</li>
<li><strong>Consistency</strong>: Uniform keyword parsing strategy</li>
<li><strong>Bug Prevention</strong>: Avoids partial match issues</li>
<li><strong>Centralization</strong>: Single source of truth for keywords</li>
</ul>
<h2 id="parser-helpers"><a class="header" href="#parser-helpers">Parser Helpers</a></h2>
<h3 id="context-management"><a class="header" href="#context-management">Context Management</a></h3>
<p>Functions for maintaining parsing context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn context&lt;I, O, F&gt;(
    ctx: &amp;'static str,
    parser: F
) -&gt; impl FnMut(I) -&gt; BResult&lt;I, O&gt;
<span class="boring">}</span></code></pre></pre>
<p>Wraps parsers with contextual information that appears in error messages, making debugging much easier.</p>
<h3 id="parser-composition"><a class="header" href="#parser-composition">Parser Composition</a></h3>
<p>Utilities for combining smaller parsers into larger ones:</p>
<ul>
<li>Sequencing parsers with error propagation</li>
<li>Optional parsing with fallbacks</li>
<li>Alternative parsing with preference ordering</li>
<li>Repetition parsing with separators</li>
</ul>
<h3 id="whitespace-and-comment-handling"><a class="header" href="#whitespace-and-comment-handling">Whitespace and Comment Handling</a></h3>
<p>Consistent handling of whitespace and comments throughout the parser:</p>
<ul>
<li>Automatic whitespace skipping between tokens</li>
<li>Comment preservation for documentation tools</li>
<li>Preprocessor directive handling</li>
</ul>
<h2 id="node-structure-standards"><a class="header" href="#node-structure-standards">Node Structure Standards</a></h2>
<h3 id="common-traits"><a class="header" href="#common-traits">Common Traits</a></h3>
<p>All AST nodes implement standard traits:</p>
<ul>
<li><code>Debug</code>: For debugging and logging</li>
<li><code>PartialEq</code>: For testing and comparison</li>
<li><code>Clone</code>: For AST manipulation</li>
<li><code>Serialize/Deserialize</code>: For JSON export/import</li>
</ul>
<h3 id="node-organization"><a class="header" href="#node-organization">Node Organization</a></h3>
<p>AST nodes are organized hierarchically:</p>
<pre><code>nodes/
├── declarations/     # Type and member declarations
├── expressions/      # All expression types
├── statements/       # All statement types
├── types/           # Type system representations
└── ...              # Other language constructs
</code></pre>
<h3 id="identifier-handling"><a class="header" href="#identifier-handling">Identifier Handling</a></h3>
<p>Consistent identifier representation throughout the AST:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Identifier {
    pub name: String,
    // Additional metadata like source location
}
<span class="boring">}</span></code></pre></pre>
<h2 id="type-system-integration"><a class="header" href="#type-system-integration">Type System Integration</a></h2>
<h3 id="type-representation"><a class="header" href="#type-representation">Type Representation</a></h3>
<p>The parser builds a complete representation of C# types:</p>
<ul>
<li>Primitive types (int, string, bool, etc.)</li>
<li>Reference types (classes, interfaces)</li>
<li>Value types (structs, enums)</li>
<li>Generic types with constraints</li>
<li>Array and pointer types</li>
<li>Nullable types</li>
</ul>
<h3 id="generic-support"><a class="header" href="#generic-support">Generic Support</a></h3>
<p>Full support for C# generics:</p>
<ul>
<li>Type parameters with constraints</li>
<li>Variance annotations (in, out)</li>
<li>Generic method declarations</li>
<li>Complex constraint combinations</li>
</ul>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<h3 id="zero-copy-parsing"><a class="header" href="#zero-copy-parsing">Zero-Copy Parsing</a></h3>
<p>Where possible, the parser avoids unnecessary string allocations:</p>
<ul>
<li>String slices reference original input</li>
<li>Minimal cloning during parsing</li>
<li>Efficient error reporting without excessive allocation</li>
</ul>
<h3 id="ast-ownership"><a class="header" href="#ast-ownership">AST Ownership</a></h3>
<p>Clear ownership semantics for AST nodes:</p>
<ul>
<li>Parent nodes own their children</li>
<li>Shared references through navigation traits</li>
<li>No circular references in the AST structure</li>
</ul>
<p>This foundation provides a robust base for parsing complex C# code while maintaining performance and usability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ast-structure"><a class="header" href="#ast-structure">AST Structure</a></h1>
<p>The BSharp AST (Abstract Syntax Tree) provides a complete, structured representation of C# source code. This document explains the organization and relationships between different AST node types.</p>
<h2 id="ast-hierarchy"><a class="header" href="#ast-hierarchy">AST Hierarchy</a></h2>
<h3 id="root-node-compilationunit"><a class="header" href="#root-node-compilationunit">Root Node: CompilationUnit</a></h3>
<p>Every parsed C# file results in a <code>CompilationUnit</code>, which serves as the root of the AST:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CompilationUnit {
    pub global_attributes: Vec&lt;GlobalAttribute&gt;,        // [assembly: ...] attributes
    pub using_directives: Vec&lt;UsingDirective&gt;,          // using statements
    pub global_using_directives: Vec&lt;GlobalUsingDirective&gt;, // C# 10+ global using
    pub declarations: Vec&lt;TopLevelDeclaration&gt;,         // namespaces, types
    pub file_scoped_namespace: Option&lt;FileScopedNamespaceDeclaration&gt;, // C# 10+
    pub top_level_statements: Vec&lt;Statement&gt;,           // C# 9+ top-level code
}
<span class="boring">}</span></code></pre></pre>
<p>This structure supports both traditional C# files and modern features like file-scoped namespaces and top-level statements.</p>
<h2 id="declaration-hierarchy"><a class="header" href="#declaration-hierarchy">Declaration Hierarchy</a></h2>
<h3 id="top-level-declarations"><a class="header" href="#top-level-declarations">Top-Level Declarations</a></h3>
<p>Top-level declarations represent constructs that can appear at the file or namespace level:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TopLevelDeclaration {
    Namespace(NamespaceDeclaration),
    FileScopedNamespace(FileScopedNamespaceDeclaration),
    Class(ClassDeclaration),
    Struct(StructDeclaration),
    Record(RecordDeclaration),
    Interface(InterfaceDeclaration),
    Enum(EnumDeclaration),
    Delegate(DelegateDeclaration),
    GlobalAttribute(GlobalAttribute),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="type-declarations"><a class="header" href="#type-declarations">Type Declarations</a></h3>
<p>Each type declaration contains comprehensive information about the type:</p>
<h4 id="classdeclaration"><a class="header" href="#classdeclaration">ClassDeclaration</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ClassDeclaration {
    pub attributes: Vec&lt;AttributeList&gt;,
    pub modifiers: Vec&lt;Modifier&gt;,
    pub name: Identifier,
    pub type_parameters: Option&lt;Vec&lt;TypeParameter&gt;&gt;,
    pub primary_constructor_parameters: Option&lt;Vec&lt;Parameter&gt;&gt;, // C# 12
    pub base_types: Vec&lt;Type&gt;,
    pub body_declarations: Vec&lt;ClassBodyDeclaration&gt;,
    pub documentation: Option&lt;XmlDocumentationComment&gt;,
    pub constraints: Option&lt;Vec&lt;TypeParameterConstraintClause&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="methoddeclaration"><a class="header" href="#methoddeclaration">MethodDeclaration</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MethodDeclaration {
    pub modifiers: Vec&lt;Modifier&gt;,
    pub return_type: Type,
    pub name: Identifier,
    pub type_parameters: Option&lt;Vec&lt;TypeParameter&gt;&gt;,
    pub parameters: Vec&lt;Parameter&gt;,
    pub body: Option&lt;Statement&gt;,                 // None for abstract/interface methods
    pub constraints: Option&lt;Vec&lt;TypeParameterConstraintClause&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="member-declarations"><a class="header" href="#member-declarations">Member Declarations</a></h3>
<p>Class body declarations represent all possible class members:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ClassBodyDeclaration {
    Method(MethodDeclaration),
    Constructor(ConstructorDeclaration),
    Destructor(DestructorDeclaration),
    Property(PropertyDeclaration),
    Field(FieldDeclaration),
    Event(EventDeclaration),
    Indexer(IndexerDeclaration),
    Operator(OperatorDeclaration),
    NestedClass(ClassDeclaration),
    NestedStruct(StructDeclaration),
    NestedInterface(InterfaceDeclaration),
    NestedEnum(EnumDeclaration),
    NestedDelegate(DelegateDeclaration),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="expression-hierarchy"><a class="header" href="#expression-hierarchy">Expression Hierarchy</a></h2>
<h3 id="expression-types"><a class="header" href="#expression-types">Expression Types</a></h3>
<p>The expression system covers all C# expression types with proper precedence:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Expression {
    // Primary and names
    Literal(Literal),
    Variable(Identifier),

    // Object and member operations
    New(Box&lt;NewExpression&gt;),
    MemberAccess(Box&lt;MemberAccessExpression&gt;),
    Invocation(Box&lt;InvocationExpression&gt;),
    Indexing(Box&lt;IndexingExpression&gt;),
    Index(Box&lt;IndexExpression&gt;),
    Range(Box&lt;RangeExpression&gt;),

    // Lambda and anonymous methods
    Lambda(Box&lt;LambdaExpression&gt;),
    AnonymousMethod(Box&lt;AnonymousMethodExpression&gt;),

    // Keywords
    This,
    Base,

    // Operators
    Unary { op: UnaryOperator, expr: Box&lt;Expression&gt; },
    Binary { left: Box&lt;Expression&gt;, op: BinaryOperator, right: Box&lt;Expression&gt; },
    PostfixUnary { op: UnaryOperator, expr: Box&lt;Expression&gt; },
    Assignment(Box&lt;AssignmentExpression&gt;),

    // Patterns and type ops
    Pattern(Box&lt;Pattern&gt;),
    IsPattern { expression: Box&lt;Expression&gt;, pattern: Box&lt;Pattern&gt; },
    As { expression: Box&lt;Expression&gt;, target_type: Type },
    Cast { expression: Box&lt;Expression&gt;, target_type: Type },

    // Misc language features
    Conditional(Box&lt;ConditionalExpression&gt;),
    Query(Box&lt;QueryExpression&gt;),
    Await(Box&lt;AwaitExpression&gt;),
    Throw(Box&lt;ThrowExpression&gt;),
    Nameof(Box&lt;NameofExpression&gt;),
    Typeof(Box&lt;TypeofExpression&gt;),
    Sizeof(Box&lt;SizeofExpression&gt;),
    Default(Box&lt;DefaultExpression&gt;),
    StackAlloc(Box&lt;StackAllocExpression&gt;),
    Ref(Box&lt;Expression&gt;),
    Checked(Box&lt;CheckedExpression&gt;),
    Unchecked(Box&lt;UncheckedExpression&gt;),

    // With/collection expressions
    With { target: Box&lt;Expression&gt;, initializers: Vec&lt;WithInitializerEntry&gt; },
    Collection(Vec&lt;CollectionElement&gt;),

    // Composite forms
    AnonymousObject(AnonymousObjectCreationExpression),
    Tuple(TupleExpression),
    SwitchExpression(Box&lt;SwitchExpression&gt;),
}
<span class="boring">}</span></code></pre></pre>
<p>Key helper structs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SwitchExpression {
    pub expression: Expression,
    pub arms: Vec&lt;SwitchExpressionArm&gt;,
}

pub enum WithInitializerEntry {
    Property { name: String, value: Expression },
    Indexer { indices: Vec&lt;Expression&gt;, value: Expression },
}

pub enum CollectionElement {
    Expr(Expression),
    Spread(Expression),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="literal-types"><a class="header" href="#literal-types">Literal Types</a></h3>
<p>Comprehensive support for C# literals:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Literal {
    Boolean(bool),
    Integer(String),          // Preserves original format
    FloatingPoint(String),    // Preserves original format
    Character(char),
    String(String),
    InterpolatedString(InterpolatedStringLiteral),
    Null,
    Default,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="statement-hierarchy"><a class="header" href="#statement-hierarchy">Statement Hierarchy</a></h2>
<h3 id="statement-types"><a class="header" href="#statement-types">Statement Types</a></h3>
<p>Complete coverage of C# statement types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Statement {
    // Control flow
    If(IfStatement),
    Switch(SwitchStatement),
    For(ForStatement),
    ForEach(ForEachStatement),
    While(WhileStatement),
    DoWhile(DoWhileStatement),
    
    // Jump statements
    Break(BreakStatement),
    Continue(ContinueStatement),
    Return(ReturnStatement),
    Throw(ThrowStatement),
    Goto(GotoStatement),
    
    // Exception handling
    Try(TryStatement),
    
    // Resource management
    Using(UsingStatement),
    Lock(LockStatement),
    
    // Declarations and expressions
    LocalVariableDeclaration(LocalVariableDeclaration),
    ExpressionStatement(Expression),
    Block(Vec&lt;Statement&gt;),
    Empty,
    
    // Modern features
    LocalFunction(LocalFunctionStatement),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="control-flow-statements"><a class="header" href="#control-flow-statements">Control Flow Statements</a></h3>
<p>Complex control flow statements contain nested structures:</p>
<h4 id="ifstatement"><a class="header" href="#ifstatement">IfStatement</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IfStatement {
    pub condition: Expression,
    pub consequence: Box&lt;Statement&gt;,
    pub alternative: Option&lt;Box&lt;Statement&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="trystatement"><a class="header" href="#trystatement">TryStatement</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TryStatement {
    pub body: Box&lt;Statement&gt;,
    pub catch_clauses: Vec&lt;CatchClause&gt;,
    pub finally_clause: Option&lt;FinallyClause&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="type-system"><a class="header" href="#type-system">Type System</a></h2>
<h3 id="type-representation-1"><a class="header" href="#type-representation-1">Type Representation</a></h3>
<p>The type system models all C# type constructs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Type {
    // Primitive types
    Primitive(PrimitiveType),
    
    // Named types
    Named { name: Identifier, type_arguments: Vec&lt;Type&gt; },
    
    // Array types
    Array { element_type: Box&lt;Type&gt;, rank: usize },
    
    // Pointer types
    Pointer(Box&lt;Type&gt;),
    
    // Nullable types
    Nullable(Box&lt;Type&gt;),
    
    // Generic type parameters
    TypeParameter(Identifier),
    
    // Tuple types
    Tuple(Vec&lt;Type&gt;),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="generic-support-1"><a class="header" href="#generic-support-1">Generic Support</a></h3>
<p>Full support for C# generics:</p>
<h4 id="typeparameter"><a class="header" href="#typeparameter">TypeParameter</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TypeParameter {
    pub attributes: Vec&lt;Attribute&gt;,
    pub variance: Option&lt;Variance&gt;,      // in, out
    pub identifier: Identifier,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="typeparameterconstraint"><a class="header" href="#typeparameterconstraint">TypeParameterConstraint</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TypeParameterConstraint {
    TypeConstraint { parameter: Identifier, constraint_type: Type },
    ConstructorConstraint(Identifier),    // new()
    ClassConstraint(Identifier),          // class
    StructConstraint(Identifier),         // struct
    UnmanagedConstraint(Identifier),      // unmanaged
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ast-metadata"><a class="header" href="#ast-metadata">AST Metadata</a></h2>
<h3 id="attributes"><a class="header" href="#attributes">Attributes</a></h3>
<p>Comprehensive attribute support:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Attribute {
    pub name: Identifier,
    pub arguments: Vec&lt;AttributeArgument&gt;,
}

pub enum AttributeArgument {
    Positional(Expression),
    Named { name: Identifier, value: Expression },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="modifiers"><a class="header" href="#modifiers">Modifiers</a></h3>
<p>All C# modifiers are represented:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Modifier {
    // Access modifiers
    Public, Private, Protected, Internal, ProtectedInternal, PrivateProtected,
    
    // Other modifiers
    Static, Abstract, Virtual, Override, Sealed, New,
    Async, Unsafe, Volatile, Readonly, Const,
    Partial, Extern,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="navigation-and-relationships"><a class="header" href="#navigation-and-relationships">Navigation and Relationships</a></h2>
<p>The AST maintains clear parent-child relationships while providing navigation capabilities through traits:</p>
<ul>
<li><strong>Ownership</strong>: Parent nodes own their children</li>
<li><strong>Navigation</strong>: Traits provide methods to traverse and search the AST</li>
<li><strong>Context</strong>: Nodes can access their containing context when needed</li>
</ul>
<p>This structure provides a complete, navigable representation of C# code that supports both analysis and transformation scenarios.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>BSharp implements a comprehensive error handling system that provides detailed context information for debugging parse failures.</p>
<h2 id="error-types"><a class="header" href="#error-types">Error Types</a></h2>
<p>The parser uses <code>ErrorTree</code> from nom-supreme for structured error information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type BResult&lt;I, O&gt; = nom::IResult&lt;I, O, ErrorTree&lt;I&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="errortree-structure"><a class="header" href="#errortree-structure">ErrorTree Structure</a></h3>
<p>The <code>ErrorTree</code> type provides:</p>
<ul>
<li><strong>Context Stack</strong>: Hierarchical parsing context via <code>.context()</code> calls</li>
<li><strong>Location</strong>: Span tracking for error positions</li>
<li><strong>Error Tree</strong>: Complete parse failure path</li>
<li><strong>Rich Diagnostics</strong>: Detailed error information for debugging</li>
</ul>
<h2 id="error-recovery"><a class="header" href="#error-recovery">Error Recovery</a></h2>
<p>The parser implements several error recovery strategies:</p>
<h3 id="1-malformed-syntax-recovery"><a class="header" href="#1-malformed-syntax-recovery">1. Malformed Syntax Recovery</a></h3>
<p>When encountering malformed syntax, the parser attempts to skip to recovery points:</p>
<ul>
<li>Semicolons (<code>;</code>)</li>
<li>Closing braces (<code>}</code>)</li>
<li>End of input</li>
</ul>
<h3 id="1a-declaration-error-recovery-type-member-top-level"><a class="header" href="#1a-declaration-error-recovery-type-member-top-level">1.a Declaration Error Recovery (Type Member Top-Level)</a></h3>
<p>For type declarations (classes, structs, records, interfaces), malformed members are recovered using a lightweight, scope-aware helper:</p>
<ul>
<li>Helper: <code>skip_to_member_boundary_top_level()</code></li>
<li>Location: <code>src/bsharp_parser/src/expressions/declarations/type_declaration_helpers.rs</code></li>
</ul>
<p>Contract:</p>
<ul>
<li>Only use from within a type body when a member parser fails.</li>
<li>Stops at the next safe boundary at top level of the current type:
<ul>
<li>Consumes a top-level <code>;</code> and returns the slice after it.</li>
<li>Or stops at a top-level <code>}</code> without consuming it (so the caller can close the current body cleanly).</li>
<li>Returns an empty slice at EOF.</li>
</ul>
</li>
<li>Depth-tracks <code>()</code>, <code>[]</code>, <code>{}</code>, and a heuristic <code>&lt;&gt;</code> to avoid stopping inside expressions, attribute arguments, or generic argument lists.</li>
<li>Ignores control characters inside strings, chars, and comments.</li>
</ul>
<p>Limitations:</p>
<ul>
<li>Angle-bracket tracking is heuristic and does not fully disambiguate generics from shift operators.</li>
<li>Verbatim/interpolated strings are not fully lexed here; this helper is intended for robust, not perfect, recovery.</li>
</ul>
<p>Usage example (simplified):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match member_parser(cur) {
    Ok((rest, member)) =&gt; { members.push(member); cur = rest; }
    Err(_) =&gt; {
        let next = skip_to_member_boundary_top_level(cur);
        if next.is_empty() || next == cur { break; }
        cur = next;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="1b-namespace-body-using-directives-before-members"><a class="header" href="#1b-namespace-body-using-directives-before-members">1.b Namespace Body: Using-Directives Before Members</a></h3>
<p>Inside a block-scoped namespace body, <code>using</code> directives are accepted before type and nested-namespace members.</p>
<ul>
<li>Implementation: <code>parse_namespace_declaration()</code> scans for <code>using</code> immediately after the opening <code>{</code> and collects all consecutive directives before parsing members.</li>
<li>This ensures inputs like the following are parsed deterministically without interleaving usings with members:</li>
</ul>
<pre><code class="language-csharp">namespace Outer {
    using System;
    namespace Inner {
        using System.Collections;
        class MyClass {}
    }
}
</code></pre>
<p>Contract and limitations:</p>
<ul>
<li>Only leading <code>using</code> directives at the current namespace body level are collected.</li>
<li>Interleaving <code>using</code> directives among members is not supported yet (matches common style and avoids ambiguous recovery).</li>
</ul>
<h3 id="1c-file-scoped-namespace"><a class="header" href="#1c-file-scoped-namespace">1.c File-Scoped Namespace</a></h3>
<p>When parsing a file-scoped namespace, the parser also skips preprocessor directives following the <code>namespace</code> line before parsing members, mirroring the block-scoped behavior.</p>
<h2 id="preprocessor-directives-and-trivia"><a class="header" href="#preprocessor-directives-and-trivia">Preprocessor Directives and Trivia</a></h2>
<p>Preprocessor directives (e.g., <code>#pragma</code>, <code>#line</code>) are treated as structured trivia, not AST declarations:</p>
<ul>
<li>Parser entrypoints (e.g., <code>parse_csharp_source()</code>) skip directive lines anywhere they can appear at the compilation-unit level.</li>
<li><code>parse_preprocessor_directive()</code> consumes the entire directive line including an optional trailing newline.</li>
<li>Current status: directives inside type and namespace bodies are planned to be skipped similarly; tests are tracked and temporarily ignored until this is integrated.</li>
</ul>
<p>Example:</p>
<pre><code class="language-csharp">#pragma warning disable CS0168
namespace N {
    // class and members...
}
</code></pre>
<p>The directive is skipped and not present as a namespace member.</p>
<h3 id="2-context-aware-errors"><a class="header" href="#2-context-aware-errors">2. Context-Aware Errors</a></h3>
<p>Errors include contextual information about the parsing context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>context("method declaration", parse_method_body)(input.into())
<span class="boring">}</span></code></pre></pre>
<p>This provides clear error messages like "expected method body in method declaration context".</p>
<p><strong>Helper Location:</strong> <code>src/bsharp_parser/src/helpers/</code></p>
<h3 id="3-graceful-degradation"><a class="header" href="#3-graceful-degradation">3. Graceful Degradation</a></h3>
<p>The parser continues parsing even after encountering errors, collecting multiple errors to provide comprehensive feedback.</p>
<h2 id="error-reporting"><a class="header" href="#error-reporting">Error Reporting</a></h2>
<p>Errors are reported with:</p>
<ul>
<li><strong>Line and column numbers</strong></li>
<li><strong>Surrounding context</strong></li>
<li><strong>Suggestions for fixes</strong></li>
<li><strong>Parser state information</strong></li>
</ul>
<h2 id="common-error-scenarios"><a class="header" href="#common-error-scenarios">Common Error Scenarios</a></h2>
<h3 id="syntax-errors"><a class="header" href="#syntax-errors">Syntax Errors</a></h3>
<ul>
<li>Missing semicolons</li>
<li>Unmatched braces</li>
<li>Invalid identifiers</li>
</ul>
<h3 id="type-errors"><a class="header" href="#type-errors">Type Errors</a></h3>
<ul>
<li>Unknown type references</li>
<li>Generic constraint violations</li>
<li>Invalid type parameter usage</li>
</ul>
<h3 id="declaration-errors"><a class="header" href="#declaration-errors">Declaration Errors</a></h3>
<ul>
<li>Conflicting modifiers</li>
<li>Missing required elements</li>
<li>Invalid access levels</li>
</ul>
<h2 id="debugging-tips"><a class="header" href="#debugging-tips">Debugging Tips</a></h2>
<ol>
<li><strong>Use verbose error output</strong> to get detailed parser state</li>
<li><strong>Check recovery points</strong> when errors cascade</li>
<li><strong>Validate input syntax</strong> with simpler test cases first</li>
<li><strong>Use parser context</strong> to understand where parsing failed</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h3 id="wrapper-expression-variants"><a class="header" href="#wrapper-expression-variants">Wrapper Expression Variants</a></h3>
<p>For clarity, several operations are modeled as distinct expression variants in the AST:</p>
<ul>
<li><code>New(NewExpression)</code> for object creation</li>
<li><code>MemberAccess(MemberAccessExpression)</code> for <code>obj.Member</code></li>
<li><code>Invocation(InvocationExpression)</code> for calls <code>expr(args)</code></li>
<li><code>Indexing(IndexingExpression)</code> and <code>Index(IndexExpression)</code></li>
<li><code>Range(RangeExpression)</code> for <code>start..end</code></li>
<li><code>With { target, initializers }</code> for record-like with-expressions</li>
<li><code>Collection(Vec&lt;CollectionElement&gt;)</code> for collection expressions</li>
</ul>
<h1 id="expression-parsing"><a class="header" href="#expression-parsing">Expression Parsing</a></h1>
<p>BSharp implements a complete expression parser that handles all C# expression types with proper operator precedence and associativity.</p>
<h2 id="expression-hierarchy-1"><a class="header" href="#expression-hierarchy-1">Expression Hierarchy</a></h2>
<p>The expression parser follows C#'s operator precedence rules:</p>
<ol>
<li><strong>Primary Expressions</strong> (<code>x</code>, <code>x.y</code>, <code>x[y]</code>, <code>x()</code>, etc.)</li>
<li><strong>Unary Expressions</strong> (<code>+x</code>, <code>-x</code>, <code>!x</code>, <code>~x</code>, <code>++x</code>, <code>--x</code>)</li>
<li><strong>Multiplicative</strong> (<code>*</code>, <code>/</code>, <code>%</code>)</li>
<li><strong>Additive</strong> (<code>+</code>, <code>-</code>)</li>
<li><strong>Shift</strong> (<code>&lt;&lt;</code>, <code>&gt;&gt;</code>)</li>
<li><strong>Relational</strong> (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>is</code>, <code>as</code>)</li>
<li><strong>Equality</strong> (<code>==</code>, <code>!=</code>)</li>
<li><strong>Logical AND</strong> (<code>&amp;</code>)</li>
<li><strong>Logical XOR</strong> (<code>^</code>)</li>
<li><strong>Logical OR</strong> (<code>|</code>)</li>
<li><strong>Conditional AND</strong> (<code>&amp;&amp;</code>)</li>
<li><strong>Conditional OR</strong> (<code>||</code>)</li>
<li><strong>Null Coalescing</strong> (<code>??</code>)</li>
<li><strong>Conditional</strong> (<code>?:</code>)</li>
<li><strong>Assignment</strong> (<code>=</code>, <code>+=</code>, <code>-=</code>, etc.)</li>
</ol>
<h2 id="expression-types-1"><a class="header" href="#expression-types-1">Expression Types</a></h2>
<h3 id="primary-expressions"><a class="header" href="#primary-expressions">Primary Expressions</a></h3>
<h4 id="literals"><a class="header" href="#literals">Literals</a></h4>
<ul>
<li><strong>Numeric</strong>: <code>42</code>, <code>3.14</code>, <code>0x1A</code></li>
<li><strong>String</strong>: <code>"hello"</code>, <code>@"verbatim"</code>, <code>$"interpolated {value}"</code></li>
<li><strong>Character</strong>: <code>'a'</code>, <code>'\n'</code></li>
<li><strong>Boolean</strong>: <code>true</code>, <code>false</code></li>
<li><strong>Null</strong>: <code>null</code></li>
</ul>
<h4 id="identifiers-and-member-access"><a class="header" href="#identifiers-and-member-access">Identifiers and Member Access</a></h4>
<pre><code class="language-csharp">variable          // Simple identifier
obj.property      // Member access
obj.method()      // Method invocation
obj[index]        // Indexer access
</code></pre>
<p>Note: In the AST, simple identifiers are represented by the <code>Expression::Variable(Identifier)</code> variant. Member access, invocation, and indexing are represented by dedicated wrapper variants (<code>MemberAccess</code>, <code>Invocation</code>, <code>Indexing</code>).</p>
<h4 id="object-creation"><a class="header" href="#object-creation">Object Creation</a></h4>
<pre><code class="language-csharp">new MyClass()                    // Constructor
new MyClass { Prop = value }     // Object initializer
new[] { 1, 2, 3 }               // Array initializer
new { Name = "John", Age = 30 }  // Anonymous object
</code></pre>
<h3 id="lambda-expressions"><a class="header" href="#lambda-expressions">Lambda Expressions</a></h3>
<p>The parser supports various lambda syntax forms:</p>
<pre><code class="language-csharp">x =&gt; x * 2                      // Single parameter
(x, y) =&gt; x + y                 // Multiple parameters
() =&gt; DoSomething()             // No parameters
(int x, string y) =&gt; Process(x, y)  // Typed parameters
x =&gt; { return x * 2; }          // Block body
async x =&gt; await ProcessAsync(x) // Async lambda
</code></pre>
<h3 id="query-expressions-linq"><a class="header" href="#query-expressions-linq">Query Expressions (LINQ)</a></h3>
<p>Complete LINQ query syntax support:</p>
<pre><code class="language-csharp">from item in collection
where item.IsValid
orderby item.Name
select item.Value
</code></pre>
<p>Supported clauses:</p>
<ul>
<li><code>from</code> - Data source</li>
<li><code>where</code> - Filtering</li>
<li><code>select</code> - Projection</li>
<li><code>orderby</code> - Sorting</li>
<li><code>group by</code> - Grouping</li>
<li><code>join</code> - Joining</li>
<li><code>let</code> - Variable introduction</li>
<li><code>into</code> - Query continuation</li>
</ul>
<h3 id="pattern-expressions"><a class="header" href="#pattern-expressions">Pattern Expressions</a></h3>
<p>Modern C# pattern matching:</p>
<pre><code class="language-csharp">obj is int value           // Type pattern
obj is not null           // Negation pattern
obj is &gt; 0 and &lt; 100     // Relational patterns
obj is var x             // Var pattern
</code></pre>
<h3 id="switch-expressions"><a class="header" href="#switch-expressions">Switch Expressions</a></h3>
<pre><code class="language-csharp">value switch
{
    1 =&gt; "one",
    2 =&gt; "two",
    _ =&gt; "other"
}
</code></pre>
<h2 id="operator-precedence-implementation"><a class="header" href="#operator-precedence-implementation">Operator Precedence Implementation</a></h2>
<p>The parser implements precedence using recursive descent with precedence climbing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_expression(input: &amp;str) -&gt; BResult&lt;&amp;str, Expression&gt; {
    parse_assignment_expression(input.into())
}

fn parse_assignment_expression(input: &amp;str) -&gt; BResult&lt;&amp;str, Expression&gt; {
    // Handle assignment operators with right associativity
}

fn parse_conditional_expression(input: &amp;str) -&gt; BResult&lt;&amp;str, Expression&gt; {
    // Handle ternary conditional operator
}

// ... continuing down the precedence chain
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-in-expressions"><a class="header" href="#error-handling-in-expressions">Error Handling in Expressions</a></h2>
<p>The expression parser provides detailed error messages:</p>
<ul>
<li><strong>Operator precedence conflicts</strong></li>
<li><strong>Missing operands</strong></li>
<li><strong>Invalid syntax combinations</strong></li>
<li><strong>Type compatibility issues</strong></li>
</ul>
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h2>
<h3 id="null-conditional-operators"><a class="header" href="#null-conditional-operators">Null-Conditional Operators</a></h3>
<pre><code class="language-csharp">obj?.Property        // Null-conditional member access
obj?[index]         // Null-conditional element access
obj?.Method()       // Null-conditional invocation
</code></pre>
<h3 id="throw-expressions"><a class="header" href="#throw-expressions">Throw Expressions</a></h3>
<pre><code class="language-csharp">value ?? throw new ArgumentNullException()
</code></pre>
<h3 id="range-and-index-expressions"><a class="header" href="#range-and-index-expressions">Range and Index Expressions</a></h3>
<pre><code class="language-csharp">array[^1]           // Index from end
array[1..5]         // Range
array[..^1]         // Range to index from end
</code></pre>
<h3 id="with-expressions-records"><a class="header" href="#with-expressions-records">With Expressions (Records)</a></h3>
<pre><code class="language-csharp">person with { Name = "Updated" }
</code></pre>
<p>The expression parser is designed to be extensible, allowing for easy addition of new expression types as the C# language evolves.</p>
<hr />
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="parser/./keywords-and-tokens.html">Keywords and Tokens</a> – keyword helpers, word boundaries, trivia handling for tokens used in expressions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statement-parsing-1"><a class="header" href="#statement-parsing-1">Statement Parsing</a></h1>
<p>BSharp provides comprehensive parsing for all C# statement types, from simple expressions to complex control flow constructs.</p>
<h2 id="statement-categories"><a class="header" href="#statement-categories">Statement Categories</a></h2>
<h3 id="1-declaration-statements"><a class="header" href="#1-declaration-statements">1. Declaration Statements</a></h3>
<h4 id="local-variable-declarations"><a class="header" href="#local-variable-declarations">Local Variable Declarations</a></h4>
<pre><code class="language-csharp">int x = 5;
var name = "John";
const double PI = 3.14159;
</code></pre>
<h4 id="local-function-declarations"><a class="header" href="#local-function-declarations">Local Function Declarations</a></h4>
<pre><code class="language-csharp">void LocalFunction(int parameter)
{
    // function body
}

T GenericLocalFunction&lt;T&gt;(T value) where T : class
{
    return value;
}
</code></pre>
<h3 id="2-expression-statements"><a class="header" href="#2-expression-statements">2. Expression Statements</a></h3>
<p>Any expression followed by a semicolon:</p>
<pre><code class="language-csharp">x++;                    // Increment
Method();              // Method call
obj.Property = value;  // Assignment
</code></pre>
<h3 id="3-control-flow-statements"><a class="header" href="#3-control-flow-statements">3. Control Flow Statements</a></h3>
<h4 id="conditional-statements"><a class="header" href="#conditional-statements">Conditional Statements</a></h4>
<p><strong>If Statements</strong></p>
<pre><code class="language-csharp">if (condition)
    statement;

if (condition)
{
    // block
}
else if (otherCondition)
{
    // else if block
}
else
{
    // else block
}
</code></pre>
<p><strong>Switch Statements</strong></p>
<pre><code class="language-csharp">switch (expression)
{
    case constant1:
        statements;
        break;
    case constant2 when condition:
        statements;
        goto case constant1;
    default:
        statements;
        break;
}
</code></pre>
<h4 id="loop-statements"><a class="header" href="#loop-statements">Loop Statements</a></h4>
<p><strong>For Loops</strong></p>
<pre><code class="language-csharp">for (int i = 0; i &lt; 10; i++)
{
    // loop body
}

for (;;)  // infinite loop
{
    // body
}
</code></pre>
<p><strong>Foreach Loops</strong></p>
<pre><code class="language-csharp">foreach (var item in collection)
{
    // process item
}

foreach ((string key, int value) in dictionary)
{
    // deconstruction in foreach
}
</code></pre>
<p><strong>While Loops</strong></p>
<pre><code class="language-csharp">while (condition)
{
    // loop body
}
</code></pre>
<p><strong>Do-While Loops</strong></p>
<pre><code class="language-csharp">do
{
    // loop body
} while (condition);
</code></pre>
<h4 id="jump-statements"><a class="header" href="#jump-statements">Jump Statements</a></h4>
<pre><code class="language-csharp">break;              // Break from loop/switch
continue;           // Continue to next iteration
return;             // Return from method
return value;       // Return with value
goto label;         // Jump to label
goto case 5;        // Jump to switch case
goto default;       // Jump to switch default
</code></pre>
<h3 id="4-exception-handling"><a class="header" href="#4-exception-handling">4. Exception Handling</a></h3>
<h4 id="try-catch-finally"><a class="header" href="#try-catch-finally">Try-Catch-Finally</a></h4>
<pre><code class="language-csharp">try
{
    // risky code
}
catch (SpecificException ex) when (ex.Code == 123)
{
    // specific exception handling
}
catch (Exception ex)
{
    // general exception handling
}
finally
{
    // cleanup code
}
</code></pre>
<h4 id="throw-statements"><a class="header" href="#throw-statements">Throw Statements</a></h4>
<pre><code class="language-csharp">throw;                           // Rethrow current exception
throw new InvalidOperationException();
throw new CustomException("message");
</code></pre>
<h3 id="5-resource-management"><a class="header" href="#5-resource-management">5. Resource Management</a></h3>
<h4 id="using-statements"><a class="header" href="#using-statements">Using Statements</a></h4>
<pre><code class="language-csharp">using (var resource = new DisposableResource())
{
    // use resource
}

using var resource = new DisposableResource();
// resource disposed at end of scope
</code></pre>
<h4 id="lock-statements"><a class="header" href="#lock-statements">Lock Statements</a></h4>
<pre><code class="language-csharp">lock (syncObject)
{
    // synchronized code
}
</code></pre>
<h4 id="fixed-statements"><a class="header" href="#fixed-statements">Fixed Statements</a></h4>
<pre><code class="language-csharp">unsafe
{
    fixed (byte* ptr = array)
    {
        // work with fixed pointer
    }
}
</code></pre>
<h3 id="6-special-statements"><a class="header" href="#6-special-statements">6. Special Statements</a></h3>
<h4 id="yield-statements"><a class="header" href="#yield-statements">Yield Statements</a></h4>
<pre><code class="language-csharp">yield return value;     // Return value in iterator
yield break;           // End iterator
</code></pre>
<h4 id="checkedunchecked-statements"><a class="header" href="#checkedunchecked-statements">Checked/Unchecked Statements</a></h4>
<pre><code class="language-csharp">checked
{
    // arithmetic overflow checking enabled
}

unchecked
{
    // arithmetic overflow checking disabled
}
</code></pre>
<h4 id="unsafe-statements"><a class="header" href="#unsafe-statements">Unsafe Statements</a></h4>
<pre><code class="language-csharp">unsafe
{
    // unsafe code block
}
</code></pre>
<h2 id="statement-parsing-implementation"><a class="header" href="#statement-parsing-implementation">Statement Parsing Implementation</a></h2>
<p>The statement parser uses a dispatch mechanism based on the first token:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_statement(input: &amp;str) -&gt; BResult&lt;&amp;str, Statement&gt; {
    alt((
        parse_block_statement,
        parse_if_statement,
        parse_while_statement,
        parse_for_statement,
        parse_foreach_statement,
        parse_do_while_statement,
        parse_switch_statement,
        parse_try_statement,
        parse_using_statement,
        parse_lock_statement,
        parse_return_statement,
        parse_throw_statement,
        parse_break_statement,
        parse_continue_statement,
        parse_goto_statement,
        parse_label_statement,
        parse_yield_statement,
        parse_local_declaration_statement,
        parse_local_function_statement,
        parse_expression_statement,
        parse_empty_statement,
    ))(input.into())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="block-statements"><a class="header" href="#block-statements">Block Statements</a></h2>
<p>Block statements group multiple statements:</p>
<pre><code class="language-csharp">{
    int x = 5;
    Console.WriteLine(x);
    if (x &gt; 0)
    {
        Console.WriteLine("Positive");
    }
}
</code></pre>
<h2 id="error-recovery-1"><a class="header" href="#error-recovery-1">Error Recovery</a></h2>
<p>The statement parser implements robust error recovery:</p>
<ol>
<li><strong>Statement-level recovery</strong>: Skip to next statement boundary (semicolon or brace)</li>
<li><strong>Block-level recovery</strong>: Skip to matching brace</li>
<li><strong>Context preservation</strong>: Maintain parsing context across errors</li>
</ol>
<h2 id="statement-attributes"><a class="header" href="#statement-attributes">Statement Attributes</a></h2>
<p>Statements can have attributes applied:</p>
<pre><code class="language-csharp">[Obsolete("Use NewMethod instead")]
void OldMethod() { }

[ConditionalAttribute("DEBUG")]
static void DebugMethod() { }
</code></pre>
<h2 id="top-level-statements"><a class="header" href="#top-level-statements">Top-Level Statements</a></h2>
<p>Support for C# 9+ top-level statements:</p>
<pre><code class="language-csharp">// Program.cs
using System;

Console.WriteLine("Hello World!");
return 0;
</code></pre>
<p>The statement parser is designed to handle the full complexity of C# control flow while providing clear error messages and robust error recovery.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declaration-parsing-1"><a class="header" href="#declaration-parsing-1">Declaration Parsing</a></h1>
<p>BSharp implements comprehensive parsing for all C# declaration types, from simple variables to complex generic types with constraints.</p>
<h2 id="declaration-categories"><a class="header" href="#declaration-categories">Declaration Categories</a></h2>
<h3 id="1-namespace-declarations"><a class="header" href="#1-namespace-declarations">1. Namespace Declarations</a></h3>
<h4 id="traditional-namespace"><a class="header" href="#traditional-namespace">Traditional Namespace</a></h4>
<pre><code class="language-csharp">namespace MyCompany.MyProject
{
    // namespace members
}
</code></pre>
<h4 id="file-scoped-namespace-c-10"><a class="header" href="#file-scoped-namespace-c-10">File-Scoped Namespace (C# 10+)</a></h4>
<pre><code class="language-csharp">namespace MyCompany.MyProject;

// All following declarations belong to this namespace
</code></pre>
<h4 id="nested-namespaces"><a class="header" href="#nested-namespaces">Nested Namespaces</a></h4>
<pre><code class="language-csharp">namespace Outer
{
    namespace Inner
    {
        // nested namespace content
    }
}
</code></pre>
<h3 id="2-type-declarations"><a class="header" href="#2-type-declarations">2. Type Declarations</a></h3>
<h4 id="class-declarations"><a class="header" href="#class-declarations">Class Declarations</a></h4>
<pre><code class="language-csharp">public class MyClass : BaseClass, IInterface1, IInterface2
{
    // class members
}

public abstract class AbstractClass
{
    public abstract void AbstractMethod();
}

public sealed class SealedClass
{
    // cannot be inherited
}
</code></pre>
<h4 id="interface-declarations"><a class="header" href="#interface-declarations">Interface Declarations</a></h4>
<pre><code class="language-csharp">public interface IMyInterface : IBaseInterface
{
    void Method();
    int Property { get; set; }
    event Action SomeEvent;
}

public interface IGeneric&lt;T&gt; where T : class
{
    T GenericMethod&lt;U&gt;(U parameter) where U : struct;
}
</code></pre>
<h4 id="struct-declarations"><a class="header" href="#struct-declarations">Struct Declarations</a></h4>
<pre><code class="language-csharp">public struct Point
{
    public int X { get; set; }
    public int Y { get; set; }
    
    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
}

public readonly struct ReadOnlyPoint
{
    public readonly int X;
    public readonly int Y;
    
    public ReadOnlyPoint(int x, int y)
    {
        X = x;
        Y = y;
    }
}
</code></pre>
<h4 id="record-declarations"><a class="header" href="#record-declarations">Record Declarations</a></h4>
<pre><code class="language-csharp">public record Person(string FirstName, string LastName);

public record class Employee(string FirstName, string LastName, string Department)
    : Person(FirstName, LastName);

public record struct Point(int X, int Y);
</code></pre>
<h4 id="enum-declarations"><a class="header" href="#enum-declarations">Enum Declarations</a></h4>
<pre><code class="language-csharp">public enum Color
{
    Red,
    Green,
    Blue
}

[Flags]
public enum FileAccess : byte
{
    None = 0,
    Read = 1,
    Write = 2,
    Execute = 4,
    All = Read | Write | Execute
}
</code></pre>
<h4 id="delegate-declarations"><a class="header" href="#delegate-declarations">Delegate Declarations</a></h4>
<pre><code class="language-csharp">public delegate void EventHandler(object sender, EventArgs e);
public delegate T GenericDelegate&lt;T, U&gt;(U parameter) where T : class;
</code></pre>
<h3 id="3-member-declarations"><a class="header" href="#3-member-declarations">3. Member Declarations</a></h3>
<h4 id="field-declarations"><a class="header" href="#field-declarations">Field Declarations</a></h4>
<pre><code class="language-csharp">private int field;
public readonly string ReadOnlyField;
public const double PI = 3.14159;
private static readonly List&lt;string&gt; StaticField = new();
</code></pre>
<h4 id="property-declarations"><a class="header" href="#property-declarations">Property Declarations</a></h4>
<pre><code class="language-csharp">// Auto-implemented properties
public string Name { get; set; }
public int Age { get; private set; }
public bool IsValid { get; init; }

// Properties with backing fields
private string _description;
public string Description
{
    get =&gt; _description;
    set =&gt; _description = value?.Trim();
}

// Expression-bodied properties
public string FullName =&gt; $"{FirstName} {LastName}";

// Indexer properties
public string this[int index]
{
    get =&gt; items[index];
    set =&gt; items[index] = value;
}
</code></pre>
<h4 id="method-declarations"><a class="header" href="#method-declarations">Method Declarations</a></h4>
<pre><code class="language-csharp">public void VoidMethod() { }
public int MethodWithReturnType() =&gt; 42;
public static T GenericMethod&lt;T&gt;(T parameter) where T : new() =&gt; new T();

// Async methods
public async Task&lt;string&gt; AsyncMethod()
{
    await Task.Delay(1000);
    return "result";
}

// Extension methods
public static class Extensions
{
    public static bool IsEmpty(this string str) =&gt; string.IsNullOrEmpty(str);
}
</code></pre>
<h4 id="constructor-declarations"><a class="header" href="#constructor-declarations">Constructor Declarations</a></h4>
<pre><code class="language-csharp">public class MyClass
{
    public MyClass() { }                    // Default constructor
    public MyClass(string name) : this()   // Constructor chaining
    {
        Name = name;
    }
    
    static MyClass()                        // Static constructor
    {
        // Static initialization
    }
}
</code></pre>
<h4 id="destructor-declarations"><a class="header" href="#destructor-declarations">Destructor Declarations</a></h4>
<pre><code class="language-csharp">public class Resource
{
    ~Resource()
    {
        // Cleanup code
    }
}
</code></pre>
<p>Note: In the AST, <code>DestructorDeclaration.body</code> is <code>Option&lt;Statement&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Some(Block(...)) for `{ ... }`, None for extern (i.e., `;` only)
pub struct DestructorDeclaration {
    pub name: Identifier,
    pub body: Option&lt;Statement&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="event-declarations"><a class="header" href="#event-declarations">Event Declarations</a></h4>
<pre><code class="language-csharp">public event Action&lt;string&gt; SomethingHappened;

public event EventHandler&lt;CustomEventArgs&gt; CustomEvent
{
    add { customEvent += value; }
    remove { customEvent -= value; }
}
</code></pre>
<h4 id="operator-declarations"><a class="header" href="#operator-declarations">Operator Declarations</a></h4>
<pre><code class="language-csharp">public static Point operator +(Point a, Point b)
{
    return new Point(a.X + b.X, a.Y + b.Y);
}

public static implicit operator string(Point p)
{
    return $"({p.X}, {p.Y})";
}
</code></pre>
<h3 id="4-generic-constraints"><a class="header" href="#4-generic-constraints">4. Generic Constraints</a></h3>
<h4 id="type-parameter-constraints"><a class="header" href="#type-parameter-constraints">Type Parameter Constraints</a></h4>
<pre><code class="language-csharp">public class Container&lt;T&gt; where T : class, IDisposable, new()
{
    // T must be a reference type, implement IDisposable, and have a parameterless constructor
}

public void Method&lt;T, U&gt;()
    where T : class
    where U : struct, IComparable&lt;U&gt;
{
    // Multiple constraint clauses
}
</code></pre>
<p>AST mapping for constraints:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// On type declarations (class/struct/interface/record)
pub struct ClassDeclaration {
    pub constraints: Option&lt;Vec&lt;TypeParameterConstraintClause&gt;&gt;,
}

// On methods
pub struct MethodDeclaration {
    pub constraints: Option&lt;Vec&lt;TypeParameterConstraintClause&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-modifiers-and-attributes"><a class="header" href="#5-modifiers-and-attributes">5. Modifiers and Attributes</a></h3>
<h4 id="access-modifiers"><a class="header" href="#access-modifiers">Access Modifiers</a></h4>
<ul>
<li><code>public</code> - Accessible everywhere</li>
<li><code>private</code> - Accessible only within the same class</li>
<li><code>protected</code> - Accessible within class and derived classes</li>
<li><code>internal</code> - Accessible within the same assembly</li>
<li><code>protected internal</code> - Accessible within assembly or derived classes</li>
<li><code>private protected</code> - Accessible within derived classes in the same assembly</li>
</ul>
<h4 id="other-modifiers"><a class="header" href="#other-modifiers">Other Modifiers</a></h4>
<ul>
<li><code>static</code> - Belongs to the type rather than instance</li>
<li><code>abstract</code> - Must be overridden in derived classes</li>
<li><code>virtual</code> - Can be overridden in derived classes</li>
<li><code>override</code> - Overrides a virtual/abstract member</li>
<li><code>sealed</code> - Cannot be overridden further</li>
<li><code>readonly</code> - Can only be assigned during initialization</li>
<li><code>const</code> - Compile-time constant</li>
<li><code>async</code> - Asynchronous method</li>
<li><code>unsafe</code> - Contains unsafe code</li>
<li><code>extern</code> - Implemented externally</li>
</ul>
<h4 id="attributes-1"><a class="header" href="#attributes-1">Attributes</a></h4>
<pre><code class="language-csharp">[Obsolete("Use NewMethod instead")]
public void OldMethod() { }

[DllImport("kernel32.dll")]
public static extern bool SetConsoleTitle(string title);

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class CustomAttribute : Attribute
{
    public string Description { get; set; }
}
</code></pre>
<h3 id="6-using-directives"><a class="header" href="#6-using-directives">6. Using Directives</a></h3>
<pre><code class="language-csharp">using System;                           // Namespace using
using System.Collections.Generic;
using static System.Math;               // Static using
using Project = MyCompany.MyProject;    // Alias directive
global using System.Text;              // Global using (C# 10+)
</code></pre>
<p>Note: <code>global using</code> directives are stored at the compilation unit level in <code>CompilationUnit.global_using_directives</code>.</p>
<h2 id="declaration-parsing-implementation"><a class="header" href="#declaration-parsing-implementation">Declaration Parsing Implementation</a></h2>
<p>The declaration parser uses a multi-stage approach:</p>
<ol>
<li><strong>Modifier Parsing</strong>: Parse access modifiers and other keywords</li>
<li><strong>Declaration Type Detection</strong>: Determine what kind of declaration</li>
<li><strong>Specific Parser Dispatch</strong>: Route to specialized parser</li>
<li><strong>Member Collection</strong>: Gather all declaration components</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_type_declaration(input: &amp;str) -&gt; BResult&lt;&amp;str, TypeDeclaration&gt; {
    let (input, attributes) = many0(parse_attribute)(input.into())?;
    let (input, modifiers) = parse_modifiers(input.into())?;
    let (input, declaration) = alt((
        parse_class_declaration,
        parse_interface_declaration,
        parse_struct_declaration,
        parse_enum_declaration,
        parse_delegate_declaration,
        parse_record_declaration,
    ))(input.into())?;
    
    Ok((input, TypeDeclaration {
        attributes,
        modifiers,
        declaration,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>The declaration parser provides comprehensive error reporting:</p>
<ul>
<li><strong>Modifier conflicts</strong>: Detecting incompatible modifier combinations</li>
<li><strong>Constraint validation</strong>: Ensuring generic constraints are valid</li>
<li><strong>Accessibility consistency</strong>: Verifying access level consistency</li>
<li><strong>Syntax validation</strong>: Catching malformed declarations</li>
</ul>
<h3 id="recovery-for-malformed-members"><a class="header" href="#recovery-for-malformed-members">Recovery for Malformed Members</a></h3>
<p>When a member inside a type body fails to parse, the parser uses a scoped recovery strategy to skip to the next safe boundary without crossing the enclosing type's closing brace. See the dedicated section in Error Handling for details on <code>skip_to_member_boundary_top_level()</code> and its contract:</p>
<ul>
<li>docs: <code>docs/parser/error-handling.md</code> (Declaration Error Recovery subsection)</li>
</ul>
<h2 id="xml-documentation"><a class="header" href="#xml-documentation">XML Documentation</a></h2>
<p>The parser handles XML documentation comments:</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// Calculates the area of a rectangle.
/// &lt;/summary&gt;
/// &lt;param name="width"&gt;The width of the rectangle.&lt;/param&gt;
/// &lt;param name="height"&gt;The height of the rectangle.&lt;/param&gt;
/// &lt;returns&gt;The area of the rectangle.&lt;/returns&gt;
public double CalculateArea(double width, double height)
{
    return width * height;
}
</code></pre>
<p>The declaration parser is designed to handle the full complexity of C# type system while maintaining performance and providing detailed error diagnostics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-system-1"><a class="header" href="#type-system-1">Type System</a></h1>
<p>BSharp implements a comprehensive type system that accurately represents all C# type constructs, from primitive types to complex generic types with constraints.</p>
<h2 id="type-categories"><a class="header" href="#type-categories">Type Categories</a></h2>
<h3 id="1-primitive-types"><a class="header" href="#1-primitive-types">1. Primitive Types</a></h3>
<h4 id="built-in-value-types"><a class="header" href="#built-in-value-types">Built-in Value Types</a></h4>
<pre><code class="language-csharp">bool        // Boolean type
byte        // 8-bit unsigned integer
sbyte       // 8-bit signed integer
short       // 16-bit signed integer
ushort      // 16-bit unsigned integer
int         // 32-bit signed integer
uint        // 32-bit unsigned integer
long        // 64-bit signed integer
ulong       // 64-bit unsigned integer
char        // 16-bit Unicode character
float       // 32-bit floating point
double      // 64-bit floating point
decimal     // 128-bit decimal
</code></pre>
<h4 id="special-types"><a class="header" href="#special-types">Special Types</a></h4>
<pre><code class="language-csharp">object      // Base type of all types
string      // Immutable string type
void        // Absence of type (method returns)
dynamic     // Dynamic type
var         // Implicitly typed variable
</code></pre>
<h3 id="2-reference-types"><a class="header" href="#2-reference-types">2. Reference Types</a></h3>
<h4 id="class-types"><a class="header" href="#class-types">Class Types</a></h4>
<pre><code class="language-csharp">MyClass                 // Simple class reference
System.Collections.List&lt;int&gt;  // Generic class
</code></pre>
<h4 id="interface-types"><a class="header" href="#interface-types">Interface Types</a></h4>
<pre><code class="language-csharp">IEnumerable&lt;T&gt;         // Generic interface
IDisposable            // Non-generic interface
</code></pre>
<h4 id="array-types"><a class="header" href="#array-types">Array Types</a></h4>
<pre><code class="language-csharp">int[]                  // Single-dimensional array
int[,]                 // Multi-dimensional array
int[][]                // Jagged array
int[,,]                // Three-dimensional array
</code></pre>
<h4 id="delegate-types"><a class="header" href="#delegate-types">Delegate Types</a></h4>
<pre><code class="language-csharp">Action                 // Parameterless action
Action&lt;int&gt;            // Action with parameter
Func&lt;int, string&gt;      // Function with return type
EventHandler&lt;T&gt;        // Event handler
</code></pre>
<h3 id="3-nullable-types"><a class="header" href="#3-nullable-types">3. Nullable Types</a></h3>
<h4 id="nullable-value-types"><a class="header" href="#nullable-value-types">Nullable Value Types</a></h4>
<pre><code class="language-csharp">int?                   // Nullable integer
DateTime?              // Nullable DateTime
bool?                  // Nullable boolean
</code></pre>
<h4 id="nullable-reference-types-c-8"><a class="header" href="#nullable-reference-types-c-8">Nullable Reference Types (C# 8+)</a></h4>
<pre><code class="language-csharp">string?                // Nullable string
List&lt;int&gt;?             // Nullable list
MyClass?               // Nullable custom class
</code></pre>
<h3 id="4-generic-types"><a class="header" href="#4-generic-types">4. Generic Types</a></h3>
<h4 id="type-parameters"><a class="header" href="#type-parameters">Type Parameters</a></h4>
<pre><code class="language-csharp">T                      // Simple type parameter
TKey, TValue           // Multiple type parameters
</code></pre>
<h4 id="constructed-generic-types"><a class="header" href="#constructed-generic-types">Constructed Generic Types</a></h4>
<pre><code class="language-csharp">List&lt;int&gt;              // Generic list of integers
Dictionary&lt;string, object&gt;  // Generic dictionary
</code></pre>
<h4 id="generic-constraints"><a class="header" href="#generic-constraints">Generic Constraints</a></h4>
<pre><code class="language-csharp">T where T : class                    // Reference type constraint
T where T : struct                   // Value type constraint
T where T : new()                    // Constructor constraint
T where T : BaseClass                // Base class constraint
T where T : IInterface               // Interface constraint
T where T : class, IDisposable, new() // Multiple constraints
</code></pre>
<h3 id="5-tuple-types"><a class="header" href="#5-tuple-types">5. Tuple Types</a></h3>
<h4 id="named-tuples"><a class="header" href="#named-tuples">Named Tuples</a></h4>
<pre><code class="language-csharp">(int x, int y)         // Named tuple elements
(string name, int age) // Different element types
</code></pre>
<h4 id="unnamed-tuples"><a class="header" href="#unnamed-tuples">Unnamed Tuples</a></h4>
<pre><code class="language-csharp">(int, string)          // Unnamed tuple elements
</code></pre>
<h4 id="nested-tuples"><a class="header" href="#nested-tuples">Nested Tuples</a></h4>
<pre><code class="language-csharp">(int, (string, bool))  // Nested tuple structure
</code></pre>
<h3 id="6-pointer-types-unsafe-context"><a class="header" href="#6-pointer-types-unsafe-context">6. Pointer Types (Unsafe Context)</a></h3>
<pre><code class="language-csharp">int*                   // Pointer to integer
char**                 // Pointer to pointer to char
void*                  // Void pointer
</code></pre>
<h3 id="7-function-pointer-types-c-9"><a class="header" href="#7-function-pointer-types-c-9">7. Function Pointer Types (C# 9+)</a></h3>
<pre><code class="language-csharp">delegate*&lt;int, string&gt;              // Function pointer
delegate* managed&lt;int, void&gt;        // Managed function pointer
delegate* unmanaged&lt;int, void&gt;      // Unmanaged function pointer
</code></pre>
<h2 id="type-syntax-parsing"><a class="header" href="#type-syntax-parsing">Type Syntax Parsing</a></h2>
<h3 id="basic-type-parsing"><a class="header" href="#basic-type-parsing">Basic Type Parsing</a></h3>
<p>The type parser handles various syntactic forms:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_type(input: &amp;str) -&gt; BResult&lt;&amp;str, Type&gt; {
    alt((
        parse_tuple_type,
        parse_function_pointer_type,
        parse_named_type,
        parse_primitive_type,
    ))(input.into())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="array-type-parsing"><a class="header" href="#array-type-parsing">Array Type Parsing</a></h3>
<p>Array types have specific syntax rules:</p>
<pre><code class="language-csharp">int[]                  // T[]
int[,]                 // T[,]
int[,,]                // T[,,]
int[][]                // T[][] (jagged)
</code></pre>
<h3 id="generic-type-parsing"><a class="header" href="#generic-type-parsing">Generic Type Parsing</a></h3>
<p>Generic types require careful parsing of type arguments:</p>
<pre><code class="language-csharp">List&lt;int&gt;              // Simple generic
Dictionary&lt;string, List&lt;int&gt;&gt;  // Nested generics
</code></pre>
<h3 id="nullable-type-parsing"><a class="header" href="#nullable-type-parsing">Nullable Type Parsing</a></h3>
<p>Nullable types use special syntax:</p>
<pre><code class="language-csharp">int?                   // Nullable&lt;int&gt;
string?                // string with nullable annotation
</code></pre>
<h2 id="type-resolution"><a class="header" href="#type-resolution">Type Resolution</a></h2>
<h3 id="qualified-names"><a class="header" href="#qualified-names">Qualified Names</a></h3>
<p>Types can be fully qualified:</p>
<pre><code class="language-csharp">System.Collections.Generic.List&lt;int&gt;
MyNamespace.MyClass
</code></pre>
<h3 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h3>
<p>Using directives create type aliases:</p>
<pre><code class="language-csharp">using StringList = System.Collections.Generic.List&lt;string&gt;;
</code></pre>
<h3 id="global-type-references"><a class="header" href="#global-type-references">Global Type References</a></h3>
<p>Global namespace references:</p>
<pre><code class="language-csharp">global::System.String  // Fully qualified from global namespace
</code></pre>
<h2 id="type-constraints"><a class="header" href="#type-constraints">Type Constraints</a></h2>
<h3 id="constraint-types"><a class="header" href="#constraint-types">Constraint Types</a></h3>
<ol>
<li><strong>Reference Type</strong>: <code>where T : class</code></li>
<li><strong>Value Type</strong>: <code>where T : struct</code></li>
<li><strong>Constructor</strong>: <code>where T : new()</code></li>
<li><strong>Base Class</strong>: <code>where T : BaseClass</code></li>
<li><strong>Interface</strong>: <code>where T : IInterface</code></li>
<li><strong>Type Parameter</strong>: <code>where T : U</code></li>
</ol>
<h3 id="constraint-combinations"><a class="header" href="#constraint-combinations">Constraint Combinations</a></h3>
<p>Multiple constraints can be combined:</p>
<pre><code class="language-csharp">where T : class, IDisposable, new()
</code></pre>
<h3 id="constraint-validation"><a class="header" href="#constraint-validation">Constraint Validation</a></h3>
<p>The parser validates constraint combinations:</p>
<ul>
<li><code>class</code> and <code>struct</code> are mutually exclusive</li>
<li><code>new()</code> constraint must come last</li>
<li>Base class constraint must come before interface constraints</li>
</ul>
<h2 id="type-variance"><a class="header" href="#type-variance">Type Variance</a></h2>
<h3 id="covariance-and-contravariance"><a class="header" href="#covariance-and-contravariance">Covariance and Contravariance</a></h3>
<pre><code class="language-csharp">interface ICovariant&lt;out T&gt; { }     // Covariant
interface IContravariant&lt;in T&gt; { }  // Contravariant
interface IInvariant&lt;T&gt; { }         // Invariant
</code></pre>
<h2 id="advanced-type-features"><a class="header" href="#advanced-type-features">Advanced Type Features</a></h2>
<h3 id="record-types"><a class="header" href="#record-types">Record Types</a></h3>
<pre><code class="language-csharp">record Person(string Name, int Age);
record class Employee(string Name, int Age, string Department);
record struct Point(int X, int Y);
</code></pre>
<h3 id="pattern-types"><a class="header" href="#pattern-types">Pattern Types</a></h3>
<p>Types used in pattern matching:</p>
<pre><code class="language-csharp">obj is string str          // Type pattern
obj is not null           // Negation pattern
obj is &gt; 0 and &lt; 100     // Relational pattern
</code></pre>
<h2 id="type-system-implementation"><a class="header" href="#type-system-implementation">Type System Implementation</a></h2>
<p>The type system is implemented with a hierarchical structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum Type {
    Primitive(PrimitiveType),
    Named {
        name: Identifier,
        type_arguments: Option&lt;Vec&lt;Type&gt;&gt;,
    },
    Array {
        element_type: Box&lt;Type&gt;,
        dimensions: u32,
    },
    Nullable(Box&lt;Type&gt;),
    Tuple(Vec&lt;(Option&lt;Identifier&gt;, Type)&gt;),
    Pointer(Box&lt;Type&gt;),
    FunctionPointer {
        parameters: Vec&lt;Type&gt;,
        return_type: Box&lt;Type&gt;,
    },
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>The type parser provides detailed error messages for:</p>
<ul>
<li><strong>Invalid type syntax</strong></li>
<li><strong>Constraint violations</strong></li>
<li><strong>Generic parameter mismatches</strong></li>
<li><strong>Nullable context errors</strong></li>
<li><strong>Variance violations</strong></li>
</ul>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>While the parser doesn't perform type inference (that's the compiler's job), it correctly parses:</p>
<ul>
<li><code>var</code> declarations</li>
<li>Anonymous types</li>
<li>Implicitly typed arrays</li>
<li>Lambda parameter types</li>
</ul>
<p>The type system parser is designed to accurately represent the full complexity of C#'s type system while maintaining performance and providing clear error diagnostics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-feature-completeness-matrix"><a class="header" href="#c-feature-completeness-matrix">C# Feature Completeness Matrix</a></h1>
<p>This document tracks the implementation status of C# language features in the BSharp parser.</p>
<p><strong>Legend:</strong></p>
<ul>
<li>✅ <strong>Fully Supported</strong> - Feature is completely implemented and tested</li>
<li>🟡 <strong>Partial Support</strong> - Feature is partially implemented or has known limitations</li>
<li>⚠️ <strong>Planned</strong> - Feature is planned but not yet implemented</li>
<li>❌ <strong>Not Supported</strong> - Feature is not currently supported</li>
</ul>
<hr />
<h2 id="c-10-features-2002"><a class="header" href="#c-10-features-2002">C# 1.0 Features (2002)</a></h2>
<h3 id="type-declarations-1"><a class="header" href="#type-declarations-1">Type Declarations</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Classes</td><td>✅</td><td>Full support including nested classes</td></tr>
<tr><td>Structs</td><td>✅</td><td>Full support</td></tr>
<tr><td>Interfaces</td><td>✅</td><td>Full support</td></tr>
<tr><td>Enums</td><td>✅</td><td>Full support including flags</td></tr>
<tr><td>Delegates</td><td>✅</td><td>Full support</td></tr>
</tbody></table>
</div>
<h3 id="members"><a class="header" href="#members">Members</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Fields</td><td>✅</td><td>Public, private, protected, internal</td></tr>
<tr><td>Properties</td><td>✅</td><td>Get/set accessors</td></tr>
<tr><td>Methods</td><td>✅</td><td>Instance and static methods</td></tr>
<tr><td>Constructors</td><td>✅</td><td>Instance and static constructors</td></tr>
<tr><td>Destructors/Finalizers</td><td>✅</td><td>Full support</td></tr>
<tr><td>Events</td><td>✅</td><td>Full support</td></tr>
<tr><td>Indexers</td><td>✅</td><td>Full support</td></tr>
<tr><td>Operators</td><td>✅</td><td>Operator overloading</td></tr>
</tbody></table>
</div>
<h3 id="statements"><a class="header" href="#statements">Statements</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>if</code>/<code>else</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>switch</code>/<code>case</code></td><td>✅</td><td>Traditional switch statements</td></tr>
<tr><td><code>for</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>foreach</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>while</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>do-while</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>break</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>continue</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>return</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>throw</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>try</code>/<code>catch</code>/<code>finally</code></td><td>✅</td><td>Full exception handling</td></tr>
<tr><td><code>using</code> statement</td><td>✅</td><td>Resource management</td></tr>
<tr><td><code>lock</code></td><td>✅</td><td>Thread synchronization</td></tr>
<tr><td><code>goto</code></td><td>✅</td><td>Including goto case</td></tr>
<tr><td><code>checked</code>/<code>unchecked</code></td><td>✅</td><td>Overflow checking</td></tr>
</tbody></table>
</div>
<h3 id="expressions"><a class="header" href="#expressions">Expressions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Literals</td><td>✅</td><td>All literal types</td></tr>
<tr><td>Arithmetic operators</td><td>✅</td><td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></td></tr>
<tr><td>Comparison operators</td><td>✅</td><td><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td></tr>
<tr><td>Logical operators</td><td>✅</td><td><code>&amp;&amp;</code>, `</td></tr>
<tr><td>Bitwise operators</td><td>✅</td><td><code>&amp;</code>, `</td></tr>
<tr><td>Assignment operators</td><td>✅</td><td><code>=</code>, <code>+=</code>, <code>-=</code>, etc.</td></tr>
<tr><td>Conditional operator</td><td>✅</td><td><code>? :</code> ternary</td></tr>
<tr><td>Member access</td><td>✅</td><td><code>.</code> operator</td></tr>
<tr><td>Indexing</td><td>✅</td><td><code>[]</code> operator</td></tr>
<tr><td>Method invocation</td><td>✅</td><td>Full support</td></tr>
<tr><td>Object creation</td><td>✅</td><td><code>new</code> expressions</td></tr>
<tr><td>Array creation</td><td>✅</td><td>Single and multi-dimensional</td></tr>
<tr><td>Type casting</td><td>✅</td><td><code>(Type)expr</code></td></tr>
<tr><td><code>typeof</code></td><td>✅</td><td>Type information</td></tr>
<tr><td><code>sizeof</code></td><td>✅</td><td>Size of types</td></tr>
<tr><td><code>is</code> operator</td><td>✅</td><td>Type testing</td></tr>
<tr><td><code>as</code> operator</td><td>✅</td><td>Safe casting</td></tr>
</tbody></table>
</div>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Primitive types</td><td>✅</td><td>All built-in types</td></tr>
<tr><td>Arrays</td><td>✅</td><td>Single, multi-dimensional, jagged</td></tr>
<tr><td>Nullable value types</td><td>✅</td><td><code>T?</code> syntax</td></tr>
<tr><td>Reference types</td><td>✅</td><td>Classes, interfaces, delegates</td></tr>
<tr><td>Value types</td><td>✅</td><td>Structs, enums</td></tr>
</tbody></table>
</div>
<h3 id="modifiers-1"><a class="header" href="#modifiers-1">Modifiers</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Access modifiers</td><td>✅</td><td>public, private, protected, internal</td></tr>
<tr><td><code>static</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>readonly</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>const</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>virtual</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>override</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>abstract</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>sealed</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>extern</code></td><td>✅</td><td>Full support</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-20-features-2005"><a class="header" href="#c-20-features-2005">C# 2.0 Features (2005)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Generics</td><td>✅</td><td>Full support including constraints</td></tr>
<tr><td>Generic constraints</td><td>✅</td><td><code>where T : class</code>, <code>struct</code>, <code>new()</code>, etc.</td></tr>
<tr><td>Partial types</td><td>✅</td><td><code>partial</code> keyword</td></tr>
<tr><td>Anonymous methods</td><td>✅</td><td><code>delegate { }</code> syntax</td></tr>
<tr><td>Nullable types</td><td>✅</td><td><code>Nullable&lt;T&gt;</code> and <code>T?</code></td></tr>
<tr><td>Iterators</td><td>✅</td><td><code>yield return</code>, <code>yield break</code></td></tr>
<tr><td>Covariance/Contravariance</td><td>✅</td><td><code>in</code>/<code>out</code> variance</td></tr>
<tr><td>Static classes</td><td>✅</td><td>Full support</td></tr>
<tr><td>Property accessors</td><td>✅</td><td>Different accessibility</td></tr>
<tr><td>Namespace aliases</td><td>✅</td><td><code>using Alias = Namespace</code></td></tr>
<tr><td><code>??</code> operator</td><td>✅</td><td>Null-coalescing</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-30-features-2007"><a class="header" href="#c-30-features-2007">C# 3.0 Features (2007)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Auto-implemented properties</td><td>✅</td><td><code>{ get; set; }</code></td></tr>
<tr><td>Object initializers</td><td>✅</td><td><code>new T { Prop = value }</code></td></tr>
<tr><td>Collection initializers</td><td>✅</td><td><code>new List&lt;T&gt; { 1, 2, 3 }</code></td></tr>
<tr><td>Anonymous types</td><td>✅</td><td><code>new { Name = "x" }</code></td></tr>
<tr><td>Extension methods</td><td>✅</td><td><code>this</code> parameter</td></tr>
<tr><td>Lambda expressions</td><td>✅</td><td><code>x =&gt; x * 2</code></td></tr>
<tr><td>Expression trees</td><td>✅</td><td>Parsing support</td></tr>
<tr><td>LINQ query syntax</td><td>✅</td><td><code>from x in y select z</code></td></tr>
<tr><td>Implicitly typed variables</td><td>✅</td><td><code>var</code> keyword</td></tr>
<tr><td>Partial methods</td><td>✅</td><td>In partial classes</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-40-features-2010"><a class="header" href="#c-40-features-2010">C# 4.0 Features (2010)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Dynamic binding</td><td>✅</td><td><code>dynamic</code> type</td></tr>
<tr><td>Named arguments</td><td>✅</td><td><code>Method(param: value)</code></td></tr>
<tr><td>Optional parameters</td><td>✅</td><td>Default parameter values</td></tr>
<tr><td>Generic covariance/contravariance</td><td>✅</td><td>Enhanced support</td></tr>
<tr><td>Embedded interop types</td><td>✅</td><td><code>no-pia</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-50-features-2012"><a class="header" href="#c-50-features-2012">C# 5.0 Features (2012)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Async/await</td><td>✅</td><td><code>async</code> and <code>await</code> keywords</td></tr>
<tr><td>Caller info attributes</td><td>✅</td><td><code>[CallerMemberName]</code>, etc.</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-60-features-2015"><a class="header" href="#c-60-features-2015">C# 6.0 Features (2015)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Auto-property initializers</td><td>✅</td><td><code>public int X { get; set; } = 1;</code></td></tr>
<tr><td>Expression-bodied members</td><td>✅</td><td><code>=&gt; expr</code> for methods/properties</td></tr>
<tr><td><code>using static</code></td><td>✅</td><td>Import static members</td></tr>
<tr><td>Null-conditional operator</td><td>✅</td><td><code>?.</code> and <code>?[]</code></td></tr>
<tr><td>String interpolation</td><td>✅</td><td><code>$"Hello {name}"</code></td></tr>
<tr><td><code>nameof</code> operator</td><td>✅</td><td><code>nameof(variable)</code></td></tr>
<tr><td>Index initializers</td><td>✅</td><td><code>[index] = value</code></td></tr>
<tr><td>Exception filters</td><td>✅</td><td><code>catch (E) when (condition)</code></td></tr>
<tr><td><code>await</code> in catch/finally</td><td>✅</td><td>Full support</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-70-features-2017"><a class="header" href="#c-70-features-2017">C# 7.0 Features (2017)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Out variables</td><td>✅</td><td><code>Method(out var x)</code></td></tr>
<tr><td>Tuples</td><td>✅</td><td><code>(int, string)</code> syntax</td></tr>
<tr><td>Tuple deconstruction</td><td>✅</td><td><code>(var x, var y) = tuple</code></td></tr>
<tr><td>Pattern matching</td><td>✅</td><td><code>is</code> patterns</td></tr>
<tr><td>Local functions</td><td>✅</td><td>Functions inside methods</td></tr>
<tr><td>Ref returns and locals</td><td>✅</td><td><code>ref</code> keyword</td></tr>
<tr><td>Discards</td><td>✅</td><td><code>_</code> placeholder</td></tr>
<tr><td>Binary literals</td><td>✅</td><td><code>0b1010</code></td></tr>
<tr><td>Digit separators</td><td>✅</td><td><code>1_000_000</code></td></tr>
<tr><td>Throw expressions</td><td>✅</td><td><code>x ?? throw new E()</code></td></tr>
<tr><td>Expression-bodied constructors</td><td>✅</td><td><code>=&gt; expr</code> syntax</td></tr>
<tr><td>Expression-bodied finalizers</td><td>✅</td><td><code>=&gt; expr</code> syntax</td></tr>
<tr><td>Expression-bodied accessors</td><td>✅</td><td><code>get =&gt; expr</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-71-features-2017"><a class="header" href="#c-71-features-2017">C# 7.1 Features (2017)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Async main</td><td>✅</td><td><code>async Task Main()</code></td></tr>
<tr><td>Default literal expressions</td><td>✅</td><td><code>default</code> without type</td></tr>
<tr><td>Inferred tuple names</td><td>✅</td><td>Automatic naming</td></tr>
<tr><td>Pattern matching on generics</td><td>✅</td><td>Full support</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-72-features-2017"><a class="header" href="#c-72-features-2017">C# 7.2 Features (2017)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>ref readonly</code></td><td>✅</td><td>Read-only references</td></tr>
<tr><td><code>in</code> parameters</td><td>✅</td><td>Pass by readonly reference</td></tr>
<tr><td><code>ref struct</code></td><td>✅</td><td>Stack-only structs</td></tr>
<tr><td>Non-trailing named arguments</td><td>✅</td><td>Mixed named/positional</td></tr>
<tr><td><code>private protected</code></td><td>✅</td><td>Access modifier</td></tr>
<tr><td>Leading underscores in numeric literals</td><td>✅</td><td><code>_123</code></td></tr>
<tr><td>Conditional <code>ref</code> expressions</td><td>✅</td><td><code>ref</code> in ternary</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-73-features-2018"><a class="header" href="#c-73-features-2018">C# 7.3 Features (2018)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Tuple equality</td><td>✅</td><td><code>==</code> and <code>!=</code></td></tr>
<tr><td>Attributes on backing fields</td><td>✅</td><td><code>[field: Attribute]</code></td></tr>
<tr><td>Expression variables in initializers</td><td>✅</td><td>Full support</td></tr>
<tr><td><code>ref</code> local reassignment</td><td>✅</td><td>Reassign ref locals</td></tr>
<tr><td>Stackalloc initializers</td><td>✅</td><td><code>stackalloc[] { 1, 2 }</code></td></tr>
<tr><td>Pattern-based <code>fixed</code></td><td>✅</td><td>Custom fixed</td></tr>
<tr><td>Improved overload candidates</td><td>✅</td><td>Better resolution</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-80-features-2019"><a class="header" href="#c-80-features-2019">C# 8.0 Features (2019)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Nullable reference types</td><td>✅</td><td><code>string?</code> annotations</td></tr>
<tr><td>Default interface methods</td><td>✅</td><td>Interface implementations</td></tr>
<tr><td>Pattern matching enhancements</td><td>✅</td><td>Switch expressions, property patterns</td></tr>
<tr><td>Switch expressions</td><td>✅</td><td><code>x switch { ... }</code></td></tr>
<tr><td>Property patterns</td><td>✅</td><td><code>{ Prop: value }</code></td></tr>
<tr><td>Tuple patterns</td><td>✅</td><td><code>(1, 2)</code> patterns</td></tr>
<tr><td>Positional patterns</td><td>✅</td><td>Deconstruction patterns</td></tr>
<tr><td>Using declarations</td><td>✅</td><td><code>using var x = ...</code></td></tr>
<tr><td>Static local functions</td><td>✅</td><td><code>static</code> modifier</td></tr>
<tr><td>Disposable ref structs</td><td>✅</td><td><code>IDisposable</code> on ref struct</td></tr>
<tr><td>Nullable reference types</td><td>✅</td><td><code>#nullable</code> directives</td></tr>
<tr><td>Asynchronous streams</td><td>✅</td><td><code>IAsyncEnumerable&lt;T&gt;</code></td></tr>
<tr><td>Asynchronous disposable</td><td>✅</td><td><code>IAsyncDisposable</code></td></tr>
<tr><td>Indices and ranges</td><td>✅</td><td><code>^</code> and <code>..</code> operators</td></tr>
<tr><td>Null-coalescing assignment</td><td>✅</td><td><code>??=</code> operator</td></tr>
<tr><td>Unmanaged constructed types</td><td>✅</td><td>Generic constraints</td></tr>
<tr><td>Stackalloc in nested expressions</td><td>✅</td><td>Full support</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-90-features-2020"><a class="header" href="#c-90-features-2020">C# 9.0 Features (2020)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Records</td><td>✅</td><td><code>record</code> keyword</td></tr>
<tr><td>Init-only setters</td><td>✅</td><td><code>init</code> accessor</td></tr>
<tr><td>Top-level statements</td><td>✅</td><td>No Main method required</td></tr>
<tr><td>Pattern matching improvements</td><td>✅</td><td>Relational, logical patterns</td></tr>
<tr><td>Relational patterns</td><td>✅</td><td><code>&gt; 0</code>, <code>&lt;= 10</code></td></tr>
<tr><td>Logical patterns</td><td>✅</td><td><code>and</code>, <code>or</code>, <code>not</code></td></tr>
<tr><td>Target-typed <code>new</code></td><td>✅</td><td><code>new()</code> without type</td></tr>
<tr><td>Covariant returns</td><td>✅</td><td>Override with derived type</td></tr>
<tr><td>Extension <code>GetEnumerator</code></td><td>✅</td><td>foreach support</td></tr>
<tr><td>Lambda discard parameters</td><td>✅</td><td><code>(_, _) =&gt; expr</code></td></tr>
<tr><td>Attributes on local functions</td><td>✅</td><td>Full support</td></tr>
<tr><td>Module initializers</td><td>✅</td><td><code>[ModuleInitializer]</code></td></tr>
<tr><td>Partial methods with return</td><td>✅</td><td>Extended partial</td></tr>
<tr><td>Native integers</td><td>✅</td><td><code>nint</code>, <code>nuint</code></td></tr>
<tr><td>Function pointers</td><td>✅</td><td><code>delegate*</code> syntax</td></tr>
<tr><td>Suppress emitting localsinit</td><td>✅</td><td><code>[SkipLocalsInit]</code></td></tr>
<tr><td>Target-typed conditional</td><td>✅</td><td><code>? :</code> inference</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-100-features-2021"><a class="header" href="#c-100-features-2021">C# 10.0 Features (2021)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Record structs</td><td>✅</td><td><code>record struct</code></td></tr>
<tr><td>Global using directives</td><td>✅</td><td><code>global using</code></td></tr>
<tr><td>File-scoped namespaces</td><td>✅</td><td><code>namespace X;</code></td></tr>
<tr><td>Extended property patterns</td><td>✅</td><td>Nested patterns</td></tr>
<tr><td>Constant interpolated strings</td><td>✅</td><td><code>const</code> strings</td></tr>
<tr><td>Lambda improvements</td><td>✅</td><td>Natural types, attributes</td></tr>
<tr><td>Caller expression attribute</td><td>✅</td><td><code>[CallerArgumentExpression]</code></td></tr>
<tr><td>Improved definite assignment</td><td>✅</td><td>Better analysis</td></tr>
<tr><td>Allow <code>AsyncMethodBuilder</code></td><td>✅</td><td>Custom builders</td></tr>
<tr><td>Record types with sealed <code>ToString</code></td><td>✅</td><td>Sealed override</td></tr>
<tr><td>Assignment and declaration in same deconstruction</td><td>✅</td><td>Mixed syntax</td></tr>
<tr><td>Allow both assignment and declaration</td><td>✅</td><td>Full support</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-110-features-2022"><a class="header" href="#c-110-features-2022">C# 11.0 Features (2022)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Raw string literals</td><td>✅</td><td><code>"""text"""</code></td></tr>
<tr><td>Generic attributes</td><td>✅</td><td><code>[Attr&lt;T&gt;]</code></td></tr>
<tr><td>UTF-8 string literals</td><td>✅</td><td><code>"text"u8</code></td></tr>
<tr><td>Newlines in string interpolations</td><td>✅</td><td>Multi-line expressions</td></tr>
<tr><td>List patterns</td><td>✅</td><td><code>[1, 2, .., 10]</code></td></tr>
<tr><td>File-local types</td><td>✅</td><td><code>file class</code></td></tr>
<tr><td>Required members</td><td>✅</td><td><code>required</code> modifier</td></tr>
<tr><td>Auto-default structs</td><td>✅</td><td>Default initialization</td></tr>
<tr><td>Pattern match <code>Span&lt;char&gt;</code></td><td>✅</td><td>Constant patterns</td></tr>
<tr><td>Extended <code>nameof</code> scope</td><td>✅</td><td>More contexts</td></tr>
<tr><td>Numeric IntPtr</td><td>✅</td><td>Operators on IntPtr</td></tr>
<tr><td><code>ref</code> fields</td><td>✅</td><td>In ref structs</td></tr>
<tr><td><code>scoped</code> ref</td><td>✅</td><td>Lifetime annotations</td></tr>
<tr><td>Checked operators</td><td>✅</td><td>User-defined checked</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-120-features-2023"><a class="header" href="#c-120-features-2023">C# 12.0 Features (2023)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Primary constructors</td><td>✅</td><td>Full support for classes and structs</td></tr>
<tr><td>Collection expressions</td><td>✅</td><td><code>[1, 2, 3]</code> and spread <code>..</code> syntax</td></tr>
<tr><td>Inline arrays</td><td>❌</td><td>Not yet implemented</td></tr>
<tr><td>Optional parameters in lambdas</td><td>✅</td><td>Full support</td></tr>
<tr><td><code>ref readonly</code> parameters</td><td>✅</td><td>Full support</td></tr>
<tr><td>Alias any type</td><td>✅</td><td><code>using Alias = (int, string)</code></td></tr>
<tr><td>Experimental attribute</td><td>✅</td><td><code>[Experimental]</code></td></tr>
<tr><td>Interceptors</td><td>❌</td><td>Not yet implemented</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-130-features-2024"><a class="header" href="#c-130-features-2024">C# 13.0 Features (2024)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>params</code> collections</td><td>⚠️</td><td>Planned</td></tr>
<tr><td>New lock type</td><td>⚠️</td><td>Planned</td></tr>
<tr><td>New escape sequence <code>\e</code></td><td>⚠️</td><td>Planned</td></tr>
<tr><td>Method group natural type</td><td>⚠️</td><td>Planned</td></tr>
<tr><td>Implicit indexer access</td><td>⚠️</td><td>Planned</td></tr>
<tr><td><code>ref</code> and <code>unsafe</code> in iterators</td><td>⚠️</td><td>Planned</td></tr>
<tr><td><code>ref struct</code> interfaces</td><td>⚠️</td><td>Planned</td></tr>
<tr><td>Allows <code>ref struct</code> types</td><td>⚠️</td><td>Planned</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="c-140-features-2025---net-10"><a class="header" href="#c-140-features-2025---net-10">C# 14.0 Features (2025 - .NET 10)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Extension members</td><td>⚠️</td><td>Planned - <code>extension</code> blocks</td></tr>
<tr><td><code>field</code> keyword</td><td>⚠️</td><td>Planned - Field-backed properties</td></tr>
<tr><td>Null-conditional assignment</td><td>⚠️</td><td>Planned - <code>?.</code> on left side of <code>=</code></td></tr>
<tr><td><code>nameof</code> unbound generics</td><td>⚠️</td><td>Planned - <code>nameof(List&lt;&gt;)</code></td></tr>
<tr><td>Implicit <code>Span&lt;T&gt;</code> conversions</td><td>⚠️</td><td>Planned - First-class span support</td></tr>
<tr><td>Lambda parameter modifiers</td><td>⚠️</td><td>Planned - <code>(out x) =&gt; ...</code> without types</td></tr>
<tr><td>Partial constructors</td><td>⚠️</td><td>Planned - <code>partial</code> instance constructors</td></tr>
<tr><td>Partial events</td><td>⚠️</td><td>Planned - <code>partial</code> events</td></tr>
<tr><td>User-defined compound assignment</td><td>⚠️</td><td>Planned - Custom <code>+=</code>, <code>-=</code> operators</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="preprocessor-directives"><a class="header" href="#preprocessor-directives">Preprocessor Directives</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>#if</code> / <code>#elif</code> / <code>#else</code> / <code>#endif</code></td><td>✅</td><td>Conditional compilation</td></tr>
<tr><td><code>#define</code> / <code>#undef</code></td><td>✅</td><td>Symbol definition</td></tr>
<tr><td><code>#warning</code> / <code>#error</code></td><td>✅</td><td>Compiler messages</td></tr>
<tr><td><code>#line</code></td><td>✅</td><td>Line number control</td></tr>
<tr><td><code>#region</code> / <code>#endregion</code></td><td>✅</td><td>Code folding</td></tr>
<tr><td><code>#pragma warning</code></td><td>✅</td><td>Warning control</td></tr>
<tr><td><code>#pragma checksum</code></td><td>✅</td><td>Debugging support</td></tr>
<tr><td><code>#nullable</code></td><td>✅</td><td>Nullable context</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="documentation-comments"><a class="header" href="#documentation-comments">Documentation Comments</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>XML documentation</td><td>✅</td><td><code>///</code> and <code>/** */</code></td></tr>
<tr><td><code>&lt;summary&gt;</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>&lt;param&gt;</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>&lt;returns&gt;</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>&lt;exception&gt;</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>&lt;see&gt;</code> / <code>&lt;seealso&gt;</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>&lt;example&gt;</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>&lt;code&gt;</code> / <code>&lt;c&gt;</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>&lt;para&gt;</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>&lt;list&gt;</code></td><td>✅</td><td>Full support</td></tr>
<tr><td><code>&lt;include&gt;</code></td><td>✅</td><td>Full support</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="unsafe-code"><a class="header" href="#unsafe-code">Unsafe Code</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>Pointers</td><td>✅</td><td><code>T*</code> syntax</td></tr>
<tr><td><code>unsafe</code> keyword</td><td>✅</td><td>Blocks and methods</td></tr>
<tr><td><code>fixed</code> statement</td><td>✅</td><td>Pin managed objects</td></tr>
<tr><td><code>stackalloc</code></td><td>✅</td><td>Stack allocation</td></tr>
<tr><td>Function pointers</td><td>✅</td><td><code>delegate*</code> (C# 9+)</td></tr>
<tr><td><code>sizeof</code> operator</td><td>✅</td><td>Type sizes</td></tr>
<tr><td>Pointer arithmetic</td><td>✅</td><td>Full support</td></tr>
<tr><td>Address-of operator</td><td>✅</td><td><code>&amp;</code> operator</td></tr>
<tr><td>Indirection operator</td><td>✅</td><td><code>*</code> operator</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="summary-statistics"><a class="header" href="#summary-statistics">Summary Statistics</a></h2>
<h3 id="overall-completeness"><a class="header" href="#overall-completeness">Overall Completeness</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Version</th><th>Features</th><th>Supported</th><th>Partial</th><th>Planned</th><th>Not Supported</th><th>Completion</th></tr></thead><tbody>
<tr><td>C# 1.0</td><td>80+</td><td>80+</td><td>0</td><td>0</td><td>0</td><td><strong>100%</strong></td></tr>
<tr><td>C# 2.0</td><td>11</td><td>11</td><td>0</td><td>0</td><td>0</td><td><strong>100%</strong></td></tr>
<tr><td>C# 3.0</td><td>10</td><td>10</td><td>0</td><td>0</td><td>0</td><td><strong>100%</strong></td></tr>
<tr><td>C# 4.0</td><td>5</td><td>5</td><td>0</td><td>0</td><td>0</td><td><strong>100%</strong></td></tr>
<tr><td>C# 5.0</td><td>2</td><td>2</td><td>0</td><td>0</td><td>0</td><td><strong>100%</strong></td></tr>
<tr><td>C# 6.0</td><td>10</td><td>10</td><td>0</td><td>0</td><td>0</td><td><strong>100%</strong></td></tr>
<tr><td>C# 7.0</td><td>13</td><td>13</td><td>0</td><td>0</td><td>0</td><td><strong>100%</strong></td></tr>
<tr><td>C# 7.1</td><td>4</td><td>4</td><td>0</td><td>0</td><td>0</td><td><strong>100%</strong></td></tr>
<tr><td>C# 7.2</td><td>7</td><td>7</td><td>0</td><td>0</td><td>0</td><td><strong>100%</strong></td></tr>
<tr><td>C# 7.3</td><td>7</td><td>7</td><td>0</td><td>0</td><td>0</td><td><strong>100%</strong></td></tr>
<tr><td>C# 8.0</td><td>18</td><td>18</td><td>0</td><td>0</td><td>0</td><td><strong>100%</strong></td></tr>
<tr><td>C# 9.0</td><td>17</td><td>17</td><td>0</td><td>0</td><td>0</td><td><strong>100%</strong></td></tr>
<tr><td>C# 10.0</td><td>12</td><td>12</td><td>0</td><td>0</td><td>0</td><td><strong>100%</strong></td></tr>
<tr><td>C# 11.0</td><td>13</td><td>13</td><td>0</td><td>0</td><td>0</td><td><strong>100%</strong></td></tr>
<tr><td>C# 12.0</td><td>7</td><td>6</td><td>0</td><td>0</td><td>1</td><td><strong>~86%</strong></td></tr>
<tr><td>C# 13.0</td><td>8</td><td>0</td><td>0</td><td>8</td><td>0</td><td><strong>0%</strong> (Preview)</td></tr>
<tr><td>C# 14.0</td><td>9</td><td>0</td><td>0</td><td>9</td><td>0</td><td><strong>0%</strong> (Preview)</td></tr>
</tbody></table>
</div>
<h3 id="total-99-of-released-c-features-supported-c-10---120"><a class="header" href="#total-99-of-released-c-features-supported-c-10---120"><strong>Total: ~99% of released C# features supported (C# 1.0 - 12.0)</strong></a></h3>
<hr />
<h2 id="testing-coverage"><a class="header" href="#testing-coverage">Testing Coverage</a></h2>
<h3 id="test-organization"><a class="header" href="#test-organization">Test Organization</a></h3>
<p>All parser tests are located in <code>tests/parser/</code> with comprehensive coverage:</p>
<ul>
<li><strong>Expression tests</strong>: <code>tests/parser/expressions/</code></li>
<li><strong>Statement tests</strong>: <code>tests/parser/statements/</code></li>
<li><strong>Declaration tests</strong>: <code>tests/parser/declarations/</code></li>
<li><strong>Type tests</strong>: <code>tests/parser/types/</code></li>
<li><strong>Pattern matching tests</strong>: <code>tests/parser/expressions/pattern_matching_tests.rs</code></li>
<li><strong>Preprocessor tests</strong>: <code>tests/parser/preprocessor/</code></li>
</ul>
<h3 id="test-fixtures"><a class="header" href="#test-fixtures">Test Fixtures</a></h3>
<p>Real-world C# projects in <code>tests/fixtures/</code>:</p>
<ul>
<li><strong>happy_path/</strong>: Valid, well-formed C# code</li>
<li><strong>complex/</strong>: Complex real-world scenarios</li>
</ul>
<hr />
<h2 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h2>
<h3 id="c-120-limitations"><a class="header" href="#c-120-limitations">C# 12.0 Limitations</a></h3>
<ol>
<li>
<p><strong>Inline Arrays</strong>: Not yet implemented</p>
<ul>
<li>Requires <code>[InlineArray(n)]</code> attribute support</li>
<li>Planned for future release</li>
</ul>
</li>
<li>
<p><strong>Interceptors</strong>: Not yet implemented</p>
<ul>
<li>Experimental feature in C# 12</li>
<li>May be implemented when feature stabilizes</li>
</ul>
</li>
</ol>
<h3 id="c-130--140-status"><a class="header" href="#c-130--140-status">C# 13.0 &amp; 14.0 Status</a></h3>
<p>All C# 13.0 and 14.0 features are in preview/development status and planned for future implementation as they stabilize in the official .NET releases.</p>
<hr />
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>To add support for new C# features:</p>
<ol>
<li><strong>Update AST nodes</strong> in <code>src/syntax/nodes/</code></li>
<li><strong>Implement parser</strong> in <code>src/parser/</code></li>
<li><strong>Add comprehensive tests</strong> in <code>tests/parser/</code></li>
<li><strong>Update this matrix</strong> to reflect new support</li>
<li><strong>Document in</strong> relevant parser documentation</li>
</ol>
<p>See <a href="parser/../development/contributing.html">Contributing Guide</a> for details.</p>
<hr />
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><strong>C# Language Specification</strong>: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/</li>
<li><strong>C# Version History</strong>: https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/</li>
<li><strong>Roslyn Source</strong>: https://github.com/dotnet/roslyn</li>
<li><strong>Parser Implementation</strong>: <code>src/parser/</code></li>
<li><strong>Test Suite</strong>: <code>tests/parser/</code></li>
</ul>
<hr />
<p><strong>Last Updated</strong>: 2025-09-30<br />
<strong>Parser Version</strong>: Current development version<br />
<strong>Maintained By</strong>: BSharp Project Contributors</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keywords-and-tokens"><a class="header" href="#keywords-and-tokens">Keywords and Tokens</a></h1>
<p>Keyword and token helpers used by the parser.</p>
<hr />
<h2 id="keyword-pairs-macro"><a class="header" href="#keyword-pairs-macro">Keyword Pairs Macro</a></h2>
<ul>
<li><strong>Location:</strong> <code>src/bsharp_parser/src/keywords/mod.rs</code></li>
<li><strong>Macro:</strong> <code>define_keyword_pair!</code> (macro_rules)</li>
<li>Generates two functions per keyword:
<ul>
<li><code>kw_&lt;name&gt;()</code> – consumes the keyword with word boundary check</li>
<li><code>peek_&lt;name&gt;()</code> – non-consuming peek with surrounding whitespace/comments tolerated</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define a pair:
// define_keyword_pair!(kw_public, peek_public, "public");
#[macro_export]
macro_rules! define_keyword_pair {
    ($kw_fn:ident, $peek_fn:ident, $lit:literal) =&gt; {
        pub fn $kw_fn() -&gt; impl FnMut($crate::syntax::span::Span) -&gt; $crate::syntax::errors::BResult&lt;&amp;str&gt; {
            use nom::Parser as _;
            (|i: $crate::syntax::span::Span| {
                nom::combinator::map(
                    nom::sequence::terminated(
                        nom_supreme::tag::complete::tag($lit),
                        nom::combinator::peek(nom::combinator::not(
                            nom::character::complete::satisfy(|c: char| c.is_alphanumeric() || c == '_'),
                        )),
                    ),
                    |s: $crate::syntax::span::Span| *s.fragment(),
                )
                .parse(i)
            })
        }
        pub fn $peek_fn() -&gt; impl FnMut($crate::syntax::span::Span) -&gt; $crate::syntax::errors::BResult&lt;&amp;str&gt; {
            use nom::Parser as _;
            (|i: $crate::syntax::span::Span| {
                nom::combinator::peek(
                    nom::sequence::delimited(
                        $crate::syntax::comment_parser::ws,
                        nom::combinator::map(
                            nom::sequence::terminated(
                                nom_supreme::tag::complete::tag($lit),
                                nom::combinator::peek(nom::combinator::not(
                                    nom::character::complete::satisfy(|c: char| c.is_alphanumeric() || c == '_'),
                                )),
                            ),
                            |_| $lit,
                        ),
                        $crate::syntax::comment_parser::ws,
                    ),
                )
                .parse(i)
            })
        }
    };
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Keyword modules live under <code>src/bsharp_parser/src/keywords/</code> (e.g., <code>access_keywords.rs</code>, <code>declaration_keywords.rs</code>, <code>linq_query_keywords.rs</code>, <code>type_keywords.rs</code>).</li>
<li>Central keyword set: <code>KEYWORDS</code> in <code>keywords/mod.rs</code> and check <code>is_keyword()</code>.</li>
</ul>
<hr />
<h2 id="token-and-whitespace-helpers"><a class="header" href="#token-and-whitespace-helpers">Token and Whitespace Helpers</a></h2>
<ul>
<li><strong>Whitespace/comments:</strong> <code>src/bsharp_parser/src/syntax/comment_parser.rs</code>
<ul>
<li><code>ws()</code> parses optional whitespace and comments</li>
<li><code>parse_whitespace_or_comments()</code> returns the consumed span text</li>
</ul>
</li>
<li><strong>List parsing:</strong> <code>src/bsharp_parser/src/syntax/list_parser.rs</code> provides helpers for delimited/separated lists</li>
<li><strong>Punctuation/tokens:</strong> Use <code>nom_supreme::tag::complete::tag("...")</code> with:
<ul>
<li><code>peek(not(satisfy(|c| ...)))</code> for word boundaries on keywords</li>
<li><code>preceded/terminated/delimited</code> and <code>ws()</code> to control surrounding trivia</li>
</ul>
</li>
</ul>
<p>Example token with trivia discipline:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nom::{combinator::map, sequence::delimited};
use nom_supreme::tag::complete::tag;
use crate::syntax::comment_parser::ws;
use crate::syntax::errors::BResult;
use crate::syntax::span::Span;

pub fn comma(i: Span) -&gt; BResult&lt;()&gt; {
    map(delimited(ws, tag(","), ws), |_| ()).parse(i)
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="usage-patterns"><a class="header" href="#usage-patterns">Usage Patterns</a></h2>
<ul>
<li>Prefer <code>peek_*()</code> when branching without consuming input (e.g., lookahead for statement kind).</li>
<li>After consuming a keyword with <code>kw_*()</code>, use <code>cut()</code> to prevent backtracking past the commitment.</li>
<li>Always wrap top-level file parser with <code>all_consuming</code>.</li>
<li>Keep context labels short and specific.</li>
</ul>
<hr />
<h2 id="adding-a-new-keyword"><a class="header" href="#adding-a-new-keyword">Adding a New Keyword</a></h2>
<ol>
<li>Pick the right module in <code>keywords/</code> and add a <code>define_keyword_pair!</code> entry.</li>
<li>If it's a reserved word, add it to <code>KEYWORDS</code> (for identifier filtering).</li>
<li>Use <code>kw_*()</code>/<code>peek_*()</code> in parsers with <code>ws()</code> at boundaries.</li>
<li>Add tests under <code>src/bsharp_tests/src/parser/...</code> for both positive and negative cases.</li>
</ol>
<hr />
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li>Keyword macro and modules: <code>src/bsharp_parser/src/keywords/</code></li>
<li>Whitespace/comment parser: <code>src/bsharp_parser/src/syntax/comment_parser.rs</code></li>
<li>Lists: <code>src/bsharp_parser/src/syntax/list_parser.rs</code></li>
<li>Error formatting: <code>src/bsharp_parser/src/syntax/errors.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-api-for-ast-traversal"><a class="header" href="#query-api-for-ast-traversal">Query API for AST traversal</a></h1>
<p>The Query API is provided by the <code>bsharp_syntax</code> crate and re-exported by <code>bsharp_analysis</code> for convenience. It replaces older navigation traits, but the Query API itself is current and not deprecated.</p>
<h2 id="core-types"><a class="header" href="#core-types">Core types</a></h2>
<ul>
<li><code>NodeRef&lt;'a&gt;</code>: a thin enum over AST nodes (<code>CompilationUnit</code>, <code>Namespace</code>, <code>Class</code>, <code>Struct</code>, <code>Interface</code>, <code>Enum</code>, <code>Record</code>, <code>Delegate</code>, <code>Method</code>, <code>Statement</code>, <code>Expression</code>, plus top-level items). Origin: <code>bsharp_syntax::node::ast_node::NodeRef</code> (re-exported as <code>bsharp_analysis::framework::NodeRef</code>).</li>
<li><code>Query&lt;'a&gt;</code>: a fluent helper to enumerate descendants and select typed nodes. Origin: <code>bsharp_syntax::query::Query</code> (re-exported as <code>bsharp_analysis::framework::Query</code>).</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::framework::{NodeRef, Query};
use bsharp_syntax::CompilationUnit;
use bsharp_syntax::{ClassDeclaration, MethodDeclaration};

fn all_classes&lt;'a&gt;(cu: &amp;'a CompilationUnit) -&gt; Vec&lt;&amp;'a ClassDeclaration&gt; {
    Query::from(NodeRef::CompilationUnit(cu))
        .of::&lt;ClassDeclaration&gt;()
        .collect()
}

fn all_methods&lt;'a&gt;(cu: &amp;'a CompilationUnit) -&gt; Vec&lt;&amp;'a MethodDeclaration&gt; {
    Query::from(NodeRef::CompilationUnit(cu))
        .of::&lt;MethodDeclaration&gt;()
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="descendant-enumeration"><a class="header" href="#descendant-enumeration">Descendant enumeration</a></h2>
<p><code>Query::descendants()</code> walks the tree using <code>Children</code> implemented for <code>NodeRef</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::framework::{NodeRef, Query};
use bsharp_syntax::statements::Statement;

fn all_statements&lt;'a&gt;(cu: &amp;'a CompilationUnit) -&gt; Vec&lt;&amp;'a Statement&gt; {
    Query::from(NodeRef::CompilationUnit(cu))
        .of::&lt;Statement&gt;()
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="filtering"><a class="header" href="#filtering">Filtering</a></h2>
<p>Use <code>filter_typed</code> to filter by predicate.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use analysis::syntax::declarations::ClassDeclaration;

let public_classes: Vec&lt;&amp;ClassDeclaration&gt; =
    Query::from(NodeRef::CompilationUnit(&amp;cu))
        .filter_typed::&lt;ClassDeclaration&gt;(|c| c.modifiers.iter().any(|m| m.is_public()))
        .collect();
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best practices</a></h2>
<ul>
<li>Prefer <code>Query</code> for node enumeration across passes.</li>
<li>For hot path statement/expression analysis, use shared helpers (<code>metrics::shared</code>) or a small local walker when necessary.</li>
<li>Keep passes stateless and deterministic; feed inputs via <code>AnalysisSession</code> artifacts.</li>
</ul>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation notes</a></h2>
<p>The <code>Children</code>/<code>Extract</code> traits are implemented for common AST nodes, enabling <code>Query::of&lt;T&gt;()</code> to return strong types. See:</p>
<ul>
<li><code>src/bsharp_syntax/src/query/</code> for <code>Children</code>, <code>Extract</code>, <code>Query</code>.</li>
<li><code>src/bsharp_syntax/src/node/ast_node.rs</code> for <code>NodeRef</code>.</li>
</ul>
<!-- Legacy sections removed; this page documents the current Query API only. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="comment-parsing"><a class="header" href="#comment-parsing">Comment Parsing</a></h1>
<p>BSharp implements comprehensive comment parsing for both regular comments and XML documentation comments, preserving them as part of the AST for documentation generation and analysis tools.</p>
<h2 id="comment-types"><a class="header" href="#comment-types">Comment Types</a></h2>
<h3 id="1-single-line-comments"><a class="header" href="#1-single-line-comments">1. Single-Line Comments</a></h3>
<p>Standard C++ style comments:</p>
<pre><code class="language-csharp">// This is a single-line comment
int x = 5; // End-of-line comment
</code></pre>
<h3 id="2-multi-line-comments"><a class="header" href="#2-multi-line-comments">2. Multi-Line Comments</a></h3>
<p>Traditional C-style block comments:</p>
<pre><code class="language-csharp">/*
 * This is a multi-line comment
 * that spans several lines
 */
int y = 10; /* Inline block comment */
</code></pre>
<h3 id="3-xml-documentation-comments"><a class="header" href="#3-xml-documentation-comments">3. XML Documentation Comments</a></h3>
<h4 id="single-line-xml-comments"><a class="header" href="#single-line-xml-comments">Single-Line XML Comments</a></h4>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// This method calculates the sum of two integers.
/// &lt;/summary&gt;
/// &lt;param name="a"&gt;The first integer.&lt;/param&gt;
/// &lt;param name="b"&gt;The second integer.&lt;/param&gt;
/// &lt;returns&gt;The sum of a and b.&lt;/returns&gt;
public int Add(int a, int b)
{
    return a + b;
}
</code></pre>
<h4 id="multi-line-xml-comments"><a class="header" href="#multi-line-xml-comments">Multi-Line XML Comments</a></h4>
<pre><code class="language-csharp">/**
 * &lt;summary&gt;
 * This is a multi-line XML documentation comment.
 * It provides detailed information about the method.
 * &lt;/summary&gt;
 * &lt;param name="value"&gt;The input value to process.&lt;/param&gt;
 * &lt;returns&gt;The processed result.&lt;/returns&gt;
 */
public string ProcessValue(string value) { }
</code></pre>
<h2 id="xml-documentation-structure"><a class="header" href="#xml-documentation-structure">XML Documentation Structure</a></h2>
<h3 id="standard-xml-tags"><a class="header" href="#standard-xml-tags">Standard XML Tags</a></h3>
<h4 id="summary-and-description"><a class="header" href="#summary-and-description">Summary and Description</a></h4>
<pre><code class="language-xml">&lt;summary&gt;
Brief description of the member.
&lt;/summary&gt;

&lt;remarks&gt;
Detailed remarks and additional information.
&lt;/remarks&gt;
</code></pre>
<h4 id="parameters-and-returns"><a class="header" href="#parameters-and-returns">Parameters and Returns</a></h4>
<pre><code class="language-xml">&lt;param name="parameterName"&gt;Description of the parameter.&lt;/param&gt;
&lt;returns&gt;Description of the return value.&lt;/returns&gt;
</code></pre>
<h4 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h4>
<pre><code class="language-xml">&lt;exception cref="ArgumentNullException"&gt;
Thrown when the parameter is null.
&lt;/exception&gt;
</code></pre>
<h4 id="examples"><a class="header" href="#examples">Examples</a></h4>
<pre><code class="language-xml">&lt;example&gt;
This example shows how to use the method:
&lt;code&gt;
var result = MyMethod("input");
Console.WriteLine(result);
&lt;/code&gt;
&lt;/example&gt;
</code></pre>
<h4 id="see-references"><a class="header" href="#see-references">See References</a></h4>
<pre><code class="language-xml">&lt;see cref="RelatedMethod"/&gt;
&lt;seealso cref="AnotherClass"/&gt;
</code></pre>
<h4 id="generic-type-parameters"><a class="header" href="#generic-type-parameters">Generic Type Parameters</a></h4>
<pre><code class="language-xml">&lt;typeparam name="T"&gt;The type parameter.&lt;/typeparam&gt;
&lt;typeparamref name="T"/&gt;
</code></pre>
<h3 id="custom-xml-tags"><a class="header" href="#custom-xml-tags">Custom XML Tags</a></h3>
<p>The parser supports custom XML tags:</p>
<pre><code class="language-xml">&lt;custom attribute="value"&gt;
Custom content with &lt;nested&gt;elements&lt;/nested&gt;.
&lt;/custom&gt;
</code></pre>
<h2 id="xml-documentation-parsing"><a class="header" href="#xml-documentation-parsing">XML Documentation Parsing</a></h2>
<h3 id="xml-element-structure"><a class="header" href="#xml-element-structure">XML Element Structure</a></h3>
<p>The parser represents XML elements with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct XmlElement {
    pub name: Identifier,
    pub attributes: Vec&lt;XmlAttribute&gt;,
    pub children: Vec&lt;XmlNode&gt;,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct XmlAttribute {
    pub name: Identifier,
    pub value: String,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum XmlNode {
    Element(XmlElement),
    Text(String),
    CData(String),
    Comment(String),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="xml-documentation-comment"><a class="header" href="#xml-documentation-comment">XML Documentation Comment</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct XmlDocumentationComment {
    pub elements: Vec&lt;XmlNode&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="parsing-xml-attributes"><a class="header" href="#parsing-xml-attributes">Parsing XML Attributes</a></h3>
<p>The parser handles XML attributes with various syntaxes:</p>
<pre><code class="language-xml">&lt;param name="value"&gt;Description&lt;/param&gt;
&lt;see cref="MyClass.MyMethod(int, string)"/&gt;
&lt;exception cref="System.ArgumentException"&gt;Error description&lt;/exception&gt;
</code></pre>
<h3 id="xml-content-parsing"><a class="header" href="#xml-content-parsing">XML Content Parsing</a></h3>
<p>The parser processes mixed content:</p>
<pre><code class="language-xml">&lt;summary&gt;
This method processes &lt;paramref name="input"/&gt; and returns
&lt;see cref="ProcessResult"/&gt; containing the result.
&lt;/summary&gt;
</code></pre>
<h2 id="comment-association"><a class="header" href="#comment-association">Comment Association</a></h2>
<h3 id="declaration-comments"><a class="header" href="#declaration-comments">Declaration Comments</a></h3>
<p>Comments are associated with their following declarations:</p>
<pre><code class="language-csharp">/// &lt;summary&gt;Class documentation&lt;/summary&gt;
public class MyClass
{
    /// &lt;summary&gt;Method documentation&lt;/summary&gt;
    public void MyMethod() { }
}
</code></pre>
<h3 id="member-comments"><a class="header" href="#member-comments">Member Comments</a></h3>
<p>Each declaration can have associated documentation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct MethodDeclaration {
    pub documentation: Option&lt;XmlDocumentationComment&gt;,
    // ... other fields
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-xml-features"><a class="header" href="#advanced-xml-features">Advanced XML Features</a></h2>
<h3 id="cdata-sections"><a class="header" href="#cdata-sections">CDATA Sections</a></h3>
<p>The parser handles CDATA sections for literal content:</p>
<pre><code class="language-xml">&lt;example&gt;
&lt;![CDATA[
if (x &lt; y &amp;&amp; y &gt; z)
{
    Console.WriteLine("Complex condition");
}
]]&gt;
&lt;/example&gt;
</code></pre>
<h3 id="nested-xml-elements"><a class="header" href="#nested-xml-elements">Nested XML Elements</a></h3>
<p>Complex nested structures are supported:</p>
<pre><code class="language-xml">&lt;summary&gt;
This method handles &lt;see cref="List{T}"/&gt; where T is
&lt;typeparamref name="T"/&gt; and implements &lt;see cref="IComparable{T}"/&gt;.
&lt;/summary&gt;
</code></pre>
<h3 id="xml-namespaces"><a class="header" href="#xml-namespaces">XML Namespaces</a></h3>
<p>The parser can handle XML namespaces in documentation:</p>
<pre><code class="language-xml">&lt;doc:summary xmlns:doc="http://schemas.microsoft.com/developer/documentation"&gt;
Namespaced documentation content.
&lt;/doc:summary&gt;
</code></pre>
<h2 id="comment-preservation"><a class="header" href="#comment-preservation">Comment Preservation</a></h2>
<h3 id="comment-tokens"><a class="header" href="#comment-tokens">Comment Tokens</a></h3>
<p>Comments are preserved as tokens in the AST:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq)]
pub enum CommentToken {
    SingleLine(String),
    MultiLine(String),
    XmlDocumentation(XmlDocumentationComment),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="position-information"><a class="header" href="#position-information">Position Information</a></h3>
<p>Comments maintain position information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PositionedComment {
    pub comment: CommentToken,
    pub line: usize,
    pub column: usize,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<h3 id="xml-validation"><a class="header" href="#xml-validation">XML Validation</a></h3>
<p>The parser validates XML structure:</p>
<ul>
<li><strong>Well-formed XML</strong>: Proper opening and closing tags</li>
<li><strong>Attribute syntax</strong>: Valid attribute name-value pairs</li>
<li><strong>Nesting rules</strong>: Correct element nesting</li>
<li><strong>Character escaping</strong>: Proper XML character escaping</li>
</ul>
<h3 id="error-recovery-2"><a class="header" href="#error-recovery-2">Error Recovery</a></h3>
<p>When XML is malformed, the parser attempts recovery:</p>
<ul>
<li><strong>Skip malformed elements</strong>: Continue parsing after errors</li>
<li><strong>Preserve content</strong>: Keep as much content as possible</li>
<li><strong>Error reporting</strong>: Provide detailed error locations</li>
</ul>
<h2 id="integration-with-analysis"><a class="header" href="#integration-with-analysis">Integration with Analysis</a></h2>
<h3 id="documentation-analysis"><a class="header" href="#documentation-analysis">Documentation Analysis</a></h3>
<p>Comments are available for analysis tools:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl XmlDocumentationComment {
    pub fn find_elements_by_name(&amp;self, name: &amp;str) -&gt; Vec&lt;&amp;XmlElement&gt; {
        // Find all elements with the given tag name
    }
    
    pub fn get_summary(&amp;self) -&gt; Option&lt;String&gt; {
        // Extract summary text
    }
    
    pub fn get_parameters(&amp;self) -&gt; Vec&lt;(String, String)&gt; {
        // Extract parameter documentation
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="documentation-generation"><a class="header" href="#documentation-generation">Documentation Generation</a></h3>
<p>The parsed XML documentation can be used for:</p>
<ul>
<li><strong>API documentation generation</strong></li>
<li><strong>IntelliSense information</strong></li>
<li><strong>Code analysis and quality checks</strong></li>
<li><strong>Documentation coverage reports</strong></li>
</ul>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="lazy-parsing"><a class="header" href="#lazy-parsing">Lazy Parsing</a></h3>
<p>XML documentation can be parsed lazily when needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub enum DocumentationState {
    Unparsed(String),
    Parsed(XmlDocumentationComment),
    Invalid(String, ParseError),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-optimization"><a class="header" href="#memory-optimization">Memory Optimization</a></h3>
<p>The parser optimizes memory usage by:</p>
<ul>
<li><strong>String interning</strong>: Reusing common XML tag names</li>
<li><strong>Structured storage</strong>: Efficient representation of XML structure</li>
<li><strong>On-demand parsing</strong>: Parse XML only when accessed</li>
</ul>
<p>The comment parsing system ensures that all documentation and comments are preserved and available for analysis, while maintaining the performance characteristics needed for large codebases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preprocessor-directives-1"><a class="header" href="#preprocessor-directives-1">Preprocessor Directives</a></h1>
<p>This parser treats preprocessor directives as trivia that can appear at safe boundaries (file start, between members inside namespaces and type bodies). We currently parse only a small subset explicitly and skip the rest.</p>
<h2 id="what-is-parsed-today"><a class="header" href="#what-is-parsed-today">What is parsed today</a></h2>
<ul>
<li><code>#pragma</code> lines are parsed into <code>PreprocessorDirective::Pragma { pragma: String }</code>.</li>
<li><code>#line</code> lines are parsed into <code>PreprocessorDirective::Line { line: String }</code>.</li>
<li>Any other line starting with <code>#</code> is recognized and consumed as
<code>PreprocessorDirective::Unknown { text: String }</code> (the remainder of the line after <code>#</code>).</li>
</ul>
<p>All directive parsers consume the optional trailing newline so the main parser can continue cleanly at the next token.</p>
<h2 id="where-directives-are-skipped"><a class="header" href="#where-directives-are-skipped">Where directives are skipped</a></h2>
<p>Directives are treated as trivia and skipped at these locations:</p>
<p>This skipping is centralized via <code>parser/helpers/directives.rs: skip_preprocessor_directives()</code>.</p>
<pre><code>
### 2. Symbol Definition

#### #define and #undef

```csharp
#define FEATURE_ENABLED
#define VERSION_2_0

#undef OLD_FEATURE
</code></pre>
<h3 id="3-diagnostic-directives"><a class="header" href="#3-diagnostic-directives">3. Diagnostic Directives</a></h3>
<h4 id="warning"><a class="header" href="#warning">#warning</a></h4>
<pre><code class="language-csharp">#warning This code is deprecated and will be removed in the next version
</code></pre>
<h4 id="error"><a class="header" href="#error">#error</a></h4>
<pre><code class="language-csharp">#if UNSUPPORTED_PLATFORM
#error This platform is not supported
#endif
</code></pre>
<h3 id="4-line-directives"><a class="header" href="#4-line-directives">4. Line Directives</a></h3>
<h4 id="line"><a class="header" href="#line">#line</a></h4>
<pre><code class="language-csharp">#line 100 "OriginalFile.cs"
// Following code appears to come from line 100 of OriginalFile.cs

#line default
// Reset to actual file and line numbers

#line hidden
// Hide following lines from debugger
</code></pre>
<h3 id="5-region-directives"><a class="header" href="#5-region-directives">5. Region Directives</a></h3>
<h4 id="region-and-endregion"><a class="header" href="#region-and-endregion">#region and #endregion</a></h4>
<pre><code class="language-csharp">#region Private Methods
private void HelperMethod()
{
    // Implementation
}

private void AnotherHelper()
{
    // Implementation
}
#endregion
</code></pre>
<h3 id="6-pragma-directives"><a class="header" href="#6-pragma-directives">6. Pragma Directives</a></h3>
<h4 id="pragma-warning"><a class="header" href="#pragma-warning">#pragma warning</a></h4>
<pre><code class="language-csharp">#pragma warning disable CS0618
// Use of obsolete members
ObsoleteMethod();
#pragma warning restore CS0618

#pragma warning disable CS0162, CS0168
// Disable multiple warnings
#pragma warning restore CS0162, CS0168
</code></pre>
<h4 id="pragma-checksum"><a class="header" href="#pragma-checksum">#pragma checksum</a></h4>
<pre><code class="language-csharp">#pragma checksum "file.cs" "{406EA660-64CF-4C82-B6F0-42D48172A799}" "checksum_bytes"
</code></pre>
<h3 id="7-nullable-context-directives"><a class="header" href="#7-nullable-context-directives">7. Nullable Context Directives</a></h3>
<h4 id="nullable"><a class="header" href="#nullable">#nullable</a></h4>
<pre><code class="language-csharp">#nullable enable
string? nullable = null;  // Nullable reference types enabled

#nullable disable
string notNullable = null;  // Warning disabled

#nullable restore
// Restore previous nullable context
</code></pre>
<h2 id="preprocessor-expression-evaluation"><a class="header" href="#preprocessor-expression-evaluation">Preprocessor Expression Evaluation</a></h2>
<h3 id="symbols-and-operators"><a class="header" href="#symbols-and-operators">Symbols and Operators</a></h3>
<h4 id="boolean-operators"><a class="header" href="#boolean-operators">Boolean Operators</a></h4>
<pre><code class="language-csharp">#if DEBUG &amp;&amp; !RELEASE           // AND and NOT
#if WINDOWS || LINUX || MACOS   // OR
#if (A &amp;&amp; B) || (C &amp;&amp; D)        // Grouping with parentheses
</code></pre>
<h4 id="equality-operators"><a class="header" href="#equality-operators">Equality Operators</a></h4>
<pre><code class="language-csharp">#if VERSION == "2.0"            // String equality
#if BUILD_NUMBER &gt;= 1000        // Numeric comparison (limited support)
</code></pre>
<h3 id="symbol-resolution"><a class="header" href="#symbol-resolution">Symbol Resolution</a></h3>
<p>Symbols can be defined:</p>
<ol>
<li><strong>Source code</strong>: <code>#define SYMBOL</code></li>
<li><strong>Compiler flags</strong>: <code>/define:SYMBOL</code></li>
<li><strong>Project settings</strong>: <code>&lt;DefineConstants&gt;</code></li>
<li><strong>Environment</strong>: Predefined symbols</li>
</ol>
<h3 id="predefined-symbols"><a class="header" href="#predefined-symbols">Predefined Symbols</a></h3>
<p>Common predefined symbols:</p>
<pre><code class="language-csharp">#if NET5_0_OR_GREATER          // Framework version
#if WINDOWS                    // Platform
#if DEBUG                      // Configuration
#if X64                        // Architecture
</code></pre>
<h2 id="preprocessor-ast-representation"><a class="header" href="#preprocessor-ast-representation">Preprocessor AST Representation</a></h2>
<h3 id="preprocessor-directive-node"><a class="header" href="#preprocessor-directive-node">Preprocessor Directive Node</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum PreprocessorDirective {
    If {
        condition: PreprocessorExpression,
        then_block: Vec&lt;PreprocessorDirective&gt;,
        elif_blocks: Vec&lt;(PreprocessorExpression, Vec&lt;PreprocessorDirective&gt;)&gt;,
        else_block: Option&lt;Vec&lt;PreprocessorDirective&gt;&gt;,
    },
    Define(String),
    Undef(String),
    Warning(String),
    Error(String),
    Line {
        line_number: Option&lt;u32&gt;,
        file_name: Option&lt;String&gt;,
        hidden: bool,
    },
    Region {
        name: String,
        content: Vec&lt;PreprocessorDirective&gt;,
    },
    Pragma {
        directive: String,
        arguments: Vec&lt;String&gt;,
    },
    Nullable(NullableDirective),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="preprocessor-expression"><a class="header" href="#preprocessor-expression">Preprocessor Expression</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum PreprocessorExpression {
    Symbol(String),
    Not(Box&lt;PreprocessorExpression&gt;),
    And(Box&lt;PreprocessorExpression&gt;, Box&lt;PreprocessorExpression&gt;),
    Or(Box&lt;PreprocessorExpression&gt;, Box&lt;PreprocessorExpression&gt;),
    Equal(Box&lt;PreprocessorExpression&gt;, Box&lt;PreprocessorExpression&gt;),
    NotEqual(Box&lt;PreprocessorExpression&gt;, Box&lt;PreprocessorExpression&gt;),
    Parenthesized(Box&lt;PreprocessorExpression&gt;),
    Literal(String),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="conditional-compilation-processing"><a class="header" href="#conditional-compilation-processing">Conditional Compilation Processing</a></h2>
<h3 id="block-structure"><a class="header" href="#block-structure">Block Structure</a></h3>
<p>Conditional blocks create a tree structure:</p>
<pre><code class="language-csharp">#if CONDITION_A
    // Block A
    #if NESTED_CONDITION
        // Nested block
    #endif
#elif CONDITION_B
    // Block B
#else
    // Default block
#endif
</code></pre>
<h3 id="active-code-determination"><a class="header" href="#active-code-determination">Active Code Determination</a></h3>
<p>The preprocessor determines which code blocks are active:</p>
<ol>
<li><strong>Evaluate conditions</strong>: Process #if expressions</li>
<li><strong>Symbol lookup</strong>: Resolve defined symbols</li>
<li><strong>Block selection</strong>: Choose active code paths</li>
<li><strong>Nested processing</strong>: Handle nested conditionals</li>
</ol>
<h2 id="integration-with-main-parser"><a class="header" href="#integration-with-main-parser">Integration with Main Parser</a></h2>
<h3 id="two-phase-parsing"><a class="header" href="#two-phase-parsing">Two-Phase Parsing</a></h3>
<ol>
<li><strong>Preprocessor Phase</strong>: Process directives and determine active code</li>
<li><strong>Main Parse Phase</strong>: Parse the active code sections</li>
</ol>
<h3 id="conditional-code-exclusion"><a class="header" href="#conditional-code-exclusion">Conditional Code Exclusion</a></h3>
<p>Inactive code blocks are:</p>
<ul>
<li><strong>Excluded from parsing</strong>: Not processed by main parser</li>
<li><strong>Preserved in AST</strong>: Available for analysis tools</li>
<li><strong>Marked as inactive</strong>: Flagged for tooling</li>
</ul>
<h3 id="directive-preservation"><a class="header" href="#directive-preservation">Directive Preservation</a></h3>
<p>All directives are preserved for:</p>
<ul>
<li><strong>Code formatting tools</strong></li>
<li><strong>Refactoring utilities</strong></li>
<li><strong>Documentation generation</strong></li>
<li><strong>Build system integration</strong></li>
</ul>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<h3 id="directive-validation"><a class="header" href="#directive-validation">Directive Validation</a></h3>
<p>The parser validates:</p>
<ul>
<li><strong>Balanced conditionals</strong>: Every #if has matching #endif</li>
<li><strong>Valid expressions</strong>: Preprocessor expressions are syntactically correct</li>
<li><strong>Symbol definitions</strong>: #define follows naming rules</li>
<li><strong>Pragma syntax</strong>: Pragma directives have valid format</li>
</ul>
<h3 id="error-recovery-3"><a class="header" href="#error-recovery-3">Error Recovery</a></h3>
<p>When encountering malformed directives:</p>
<ul>
<li><strong>Skip invalid directives</strong>: Continue parsing</li>
<li><strong>Report detailed errors</strong>: Show directive location and issue</li>
<li><strong>Maintain structure</strong>: Keep conditional block structure intact</li>
</ul>
<h2 id="advanced-features-1"><a class="header" href="#advanced-features-1">Advanced Features</a></h2>
<h3 id="nested-regions"><a class="header" href="#nested-regions">Nested Regions</a></h3>
<pre><code class="language-csharp">#region Outer Region
    #region Inner Region
        // Nested region content
    #endregion
#endregion
</code></pre>
<h3 id="complex-pragma-directives"><a class="header" href="#complex-pragma-directives">Complex Pragma Directives</a></h3>
<pre><code class="language-csharp">#pragma warning disable IDE0051 // Remove unused private members
#pragma warning restore IDE0051

#pragma nullable enable warnings
#pragma nullable disable annotations
</code></pre>
<h3 id="source-mapping"><a class="header" href="#source-mapping">Source Mapping</a></h3>
<p>Line directives affect source mapping:</p>
<pre><code class="language-csharp">#line 1 "Generated.cs"
// This appears to come from Generated.cs line 1
var generated = true;
#line default
// Back to actual file location
</code></pre>
<h2 id="usage-in-analysis"><a class="header" href="#usage-in-analysis">Usage in Analysis</a></h2>
<h3 id="conditional-code-analysis"><a class="header" href="#conditional-code-analysis">Conditional Code Analysis</a></h3>
<p>Analysis tools can:</p>
<ul>
<li><strong>Detect dead code</strong>: Find code that's never compiled</li>
<li><strong>Track feature flags</strong>: Analyze conditional compilation usage</li>
<li><strong>Generate reports</strong>: Show compilation configurations</li>
</ul>
<h3 id="symbol-tracking"><a class="header" href="#symbol-tracking">Symbol Tracking</a></h3>
<p>Track symbol definitions and usage:</p>
<ul>
<li><strong>Definition locations</strong>: Where symbols are defined</li>
<li><strong>Usage contexts</strong>: Where symbols are referenced</li>
<li><strong>Scope analysis</strong>: Symbol visibility across files</li>
</ul>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<h3 id="preprocessing-optimization"><a class="header" href="#preprocessing-optimization">Preprocessing Optimization</a></h3>
<ul>
<li><strong>Symbol caching</strong>: Cache symbol resolution results</li>
<li><strong>Lazy evaluation</strong>: Process conditionals only when needed</li>
<li><strong>Memory efficiency</strong>: Minimize directive storage overhead</li>
</ul>
<h3 id="integration-efficiency"><a class="header" href="#integration-efficiency">Integration Efficiency</a></h3>
<ul>
<li><strong>Single-pass processing</strong>: Process directives during parsing</li>
<li><strong>Minimal backtracking</strong>: Avoid reparsing conditional blocks</li>
<li><strong>Incremental updates</strong>: Support for incremental parsing with directive changes</li>
</ul>
<p>The preprocessor directive system ensures that all C# preprocessing features are supported while maintaining the ability to analyze and manipulate code across different compilation configurations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spans"><a class="header" href="#spans">Spans</a></h1>
<p>This page explains how source spans are represented and returned during parsing.</p>
<hr />
<h2 id="span-type"><a class="header" href="#span-type">Span Type</a></h2>
<ul>
<li><strong>Type:</strong> <code>bsharp_parser::syntax::span::Span&lt;'a&gt;</code></li>
<li><strong>Alias:</strong> <code>type Span&lt;'a&gt; = nom_locate::LocatedSpan&lt;&amp;'a str&gt;;</code></li>
<li>Provides line/column offsets and byte positions for parser errors and mapping.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/bsharp_parser/src/syntax/span.rs
pub type Span&lt;'a&gt; = nom_locate::LocatedSpan&lt;&amp;'a str&gt;;
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="parsing-with-spans"><a class="header" href="#parsing-with-spans">Parsing With Spans</a></h2>
<p>Use the parser facade to parse and also get a span table for top-level declarations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_parser::facade::Parser;

let source = std::fs::read_to_string("Program.cs")?;
let (cu, spans) = Parser::new().parse_with_spans(&amp;source)?;
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The return value is <code>(CompilationUnit, SpanTable)</code>.</li>
<li><code>SpanTable</code> maps top-level declarations to byte ranges for later mapping.</li>
</ul>
<hr />
<h2 id="error-reporting-1"><a class="header" href="#error-reporting-1">Error Reporting</a></h2>
<p>Pretty error formatting uses <code>Span</code> to print line/column with context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_parser::syntax::errors::format_error_tree;

let msg = format_error_tree(&amp;source, &amp;error_tree);
<span class="boring">}</span></code></pre></pre>
<p>See: <code>docs/parser/error-handling.md</code> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-traits"><a class="header" href="#syntax-traits">Syntax Traits</a></h1>
<p>Core traits used by AST types and formatting emitters.</p>
<hr />
<h2 id="astnode"><a class="header" href="#astnode">AstNode</a></h2>
<ul>
<li><strong>Path:</strong> <code>bsharp_syntax::node::ast_node::AstNode</code></li>
<li>Implemented by all syntax node types for traversal and visualization.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait AstNode: Any {
    fn as_any(&amp;self) -&gt; &amp;dyn Any;
    fn children&lt;'a&gt;(&amp;'a self, _push: &amp;mut dyn FnMut(NodeRef&lt;'a&gt;)) {}
    fn node_kind(&amp;self) -&gt; &amp;'static str { core::any::type_name::&lt;Self&gt;() }
    fn node_label(&amp;self) -&gt; String { format!("{} ({})", self.node_kind(), core::any::type_name::&lt;Self&gt;()) }
}
<span class="boring">}</span></code></pre></pre>
<p>Helpers:</p>
<ul>
<li><code>NodeRef&lt;'a&gt;</code> alias to <code>DynNodeRef&lt;'a&gt;</code> for dynamic traversal.</li>
<li><code>push_child(push, node)</code> to push typed children.</li>
</ul>
<hr />
<h2 id="emit-and-emitter"><a class="header" href="#emit-and-emitter">Emit and Emitter</a></h2>
<ul>
<li><strong>Path:</strong> <code>bsharp_syntax::emitters::emit_trait::{Emit, Emitter, EmitCtx}</code></li>
<li><code>Emit</code> is implemented by nodes that can render themselves as C# code.</li>
<li><code>Emitter</code> writes items to <code>String</code> (or writer) using a mutable <code>EmitCtx</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Emit {
    fn emit&lt;W: std::fmt::Write&gt;(&amp;self, w: &amp;mut W, cx: &amp;mut EmitCtx) -&gt; Result&lt;(), EmitError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><code>EmitCtx</code> controls indentation, simple policies, and optional JSONL tracing.</p>
<hr />
<h2 id="rendering-helpers"><a class="header" href="#rendering-helpers">Rendering Helpers</a></h2>
<ul>
<li>Graph renderers in <code>bsharp_syntax::node::render::{to_text, to_mermaid, to_dot}</code> operate on <code>&amp;impl AstNode</code>.</li>
</ul>
<hr />
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<ul>
<li><code>docs/syntax/spans.md</code></li>
<li><code>docs/syntax/derive-macros.md</code></li>
<li><code>docs/syntax/formatter.md</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive-macros"><a class="header" href="#derive-macros">Derive Macros</a></h1>
<p>Procedural macros used by syntax nodes to implement traversal and visualization behavior.</p>
<hr />
<h2 id="deriveastnode"><a class="header" href="#deriveastnode"><code>#[derive(AstNode)]</code></a></h2>
<ul>
<li><strong>Crate:</strong> <code>bsharp_syntax_derive</code></li>
<li><strong>Implements:</strong> <code>bsharp_syntax::node::ast_node::AstNode</code> for your struct/enum</li>
<li><strong>Purpose:</strong> Auto-generates <code>children()</code> to enable dynamic traversal via <code>NodeRef</code>/<code>DynNodeRef</code>.</li>
</ul>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h3>
<p>For each field, the macro emits code to push children appropriately:</p>
<ul>
<li><code>Option&lt;T&gt;</code>: pushes inner <code>T</code> if present</li>
<li><code>Vec&lt;T&gt;</code>: iterates and pushes each <code>T</code></li>
<li><code>Box&lt;T&gt;</code>: borrows inner <code>&amp;T</code> and pushes it</li>
<li>Other types: treated as AST nodes by default</li>
<li>Primitive-like types are skipped: <code>bool</code>, numbers, <code>char</code>, <code>String</code>, and internal primitive enums like <code>PrimitiveType</code></li>
</ul>
<p>Excerpt from implementation (<code>src/bsharp_syntax_derive/src/lib.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_derive(AstNode)]
pub fn derive_ast_node(input: TokenStream) -&gt; TokenStream {
    // ...
    impl crate::node::ast_node::AstNode for #name {
        fn as_any(&amp;self) -&gt; &amp;dyn ::core::any::Any { self }
        fn children&lt;'a&gt;(&amp;'a self, push: &amp;mut dyn FnMut(crate::node::ast_node::NodeRef&lt;'a&gt;)) {
            // Generated per-type based on fields
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Helper routine decides how to push for common containers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gen_push_for_type(ty: &amp;Type, access: TokenStream) -&gt; TokenStream {
    // Handles Option&lt;T&gt;, Vec&lt;T&gt;, Box&lt;T&gt;, or default to AST node push
}
<span class="boring">}</span></code></pre></pre>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>Add the derive to your AST types in <code>bsharp_syntax</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(bsharp_syntax_derive::AstNode, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Expression {
    Literal(Literal),
    Variable(Identifier),
    Invocation(Box&lt;InvocationExpression&gt;),
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>This enables:</p>
<ul>
<li>Graph rendering via <code>to_text</code>, <code>to_mermaid</code>, <code>to_dot</code></li>
<li>Traversal via <code>AstWalker</code>/<code>Visit</code> or <code>Query</code> API (by way of <code>NodeRef</code> children)</li>
</ul>
<hr />
<h2 id="guidelines"><a class="header" href="#guidelines">Guidelines</a></h2>
<ul>
<li>Ensure child fields are typed as AST nodes or containers of AST nodes for traversal to work.</li>
<li>Keep primitive data out of traversal (the derive already skips standard primitives).</li>
<li>Favor <code>Box&lt;T&gt;</code> for recursive enum variants to keep sizes reasonable.</li>
</ul>
<hr />
<h2 id="see-also-3"><a class="header" href="#see-also-3">See Also</a></h2>
<ul>
<li><code>docs/syntax/traits.md</code> – <code>AstNode</code>, <code>NodeRef</code></li>
<li><code>docs/analysis/traversal-guide.md</code> – traversal patterns</li>
<li><code>docs/development/query-cookbook.md</code> – query examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatter-and-emitters"><a class="header" href="#formatter-and-emitters">Formatter and Emitters</a></h1>
<p>This page describes the formatting architecture in BSharp, implemented in the <code>bsharp_syntax</code> crate.</p>
<hr />
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The formatter is an AST-driven emitter that produces the final C# text directly. There is no post-processing pass (no normalize_text): the output is exactly what emitters write.</p>
<ul>
<li>Core types:
<ul>
<li><code>Formatter</code></li>
<li><code>FormatOptions</code></li>
</ul>
</li>
<li>Emission is instrumentable via a JSONL trace for debugging and profiling.</li>
</ul>
<hr />
<h2 id="formatoptions"><a class="header" href="#formatoptions">FormatOptions</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FormatOptions {
    pub indent_width: usize,                      // default: 4 spaces
    pub newline: &amp;'static str,                    // "\n" or "\r\n"
    pub max_consecutive_blank_lines: u8,          // default: 1
    pub blank_line_between_members: bool,         // default: true
    pub ensure_final_newline: bool,               // default: true (emit one final newline if any content)
    pub trim_trailing_whitespace: bool,           // default: true
    pub instrument_emission: bool,                // default: false
    pub trace_file: Option&lt;std::path::PathBuf&gt;,   // optional JSONL output
    pub current_file: Option&lt;std::path::PathBuf&gt;, // helpful in messages
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Newline mode is controlled by CLI <code>--newline-mode</code> or defaults to LF.</li>
<li>Emission tracing can be toggled via CLI <code>--emit-trace</code> or <code>BSHARP_EMIT_TRACE=1</code>.</li>
</ul>
<hr />
<h2 id="brace-style-and-spacing-policy"><a class="header" href="#brace-style-and-spacing-policy">Brace Style and Spacing Policy</a></h2>
<ul>
<li>
<p><strong>Brace style:</strong> All containers and headers use Allman style</p>
<ul>
<li>Header ends the line (e.g., <code>namespace X</code>, <code>class C</code>, <code>void M()</code>)</li>
<li>Next line is an opening <code>{</code>, indented body, then closing <code>}</code> on its own line.</li>
</ul>
</li>
<li>
<p><strong>Spacing is centralized</strong> in simple policy helpers (see <code>src/bsharp_syntax/src/emitters/policy.rs</code>):</p>
<ul>
<li><code>between_header_and_body_of_file</code> → blank line between file header (e.g., file-scoped ns) and body</li>
<li><code>after_file_scoped_namespace_header</code> → blank line after <code>namespace X.Y;</code></li>
<li><code>between_using_blocks_and_declarations</code> → blank line after using block before first declaration</li>
<li><code>between_top_level_declarations</code> → single separator newline between top-level declarations</li>
<li><code>between_members</code> → single separator newline between adjacent type members</li>
<li><code>between_block_items</code> → optional extra newline inside a block when a control-flow block (if/for/while/do/switch/inner block) is followed by a declaration</li>
</ul>
</li>
</ul>
<p>Notes:</p>
<ul>
<li>Policies are invoked from emitters; emitters themselves keep logic minimal and do not hardcode extra blank lines.</li>
<li>Interfaces, classes, structs, and records call <code>between_members</code> between members; the boolean <code>blank_line_between_members</code> toggles this globally.</li>
</ul>
<hr />
<h2 id="end-of-file-newline"><a class="header" href="#end-of-file-newline">End-of-file Newline</a></h2>
<ul>
<li>The <code>CompilationUnit</code> emitter ensures at most one final newline at EOF.</li>
<li>There are no per-statement trailing newlines at the root; separation is handled by policy functions.</li>
</ul>
<hr />
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_syntax::{Formatter, FormatOptions};

let mut opts = FormatOptions::default();
opts.newline = "\n";
opts.max_consecutive_blank_lines = 1;
opts.blank_line_between_members = true;
opts.trim_trailing_whitespace = true;

let fmt = Formatter::new(opts);
let output = fmt.format_compilation_unit(&amp;cu)?; // cu: CompilationUnit
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="emission-trace-jsonl"><a class="header" href="#emission-trace-jsonl">Emission Trace (JSONL)</a></h2>
<p>When instrumentation is enabled, the formatter emits a stream of JSON objects describing emission steps.</p>
<ul>
<li>CLI integration:
<ul>
<li><code>--emit-trace</code> to enable</li>
<li><code>--emit-trace-file &lt;FILE&gt;</code> to write to a file (stdout by default)</li>
<li>Env var <code>BSHARP_EMIT_TRACE=1</code> acts as a default toggle</li>
</ul>
</li>
</ul>
<p>The trace can be useful to:</p>
<ul>
<li>Diagnose spacing/blank line decisions (look for <code>action: "policy"</code> with names like <code>between_members</code>, <code>between_top_level_declarations</code>, <code>between_block_items</code>)</li>
<li>Identify costly emission paths</li>
<li>Reproduce formatting anomalies</li>
</ul>
<p>Typical actions include: <code>enter_node</code>, <code>open_brace</code>, <code>close_brace</code>, <code>newline</code>, <code>space</code>, <code>token</code>, and <code>policy</code>.</p>
<hr />
<h2 id="integration-with-cli"><a class="header" href="#integration-with-cli">Integration with CLI</a></h2>
<ul>
<li>See <code>bsharp format</code> in <code>docs/cli/format.md</code> for options mapping to <code>FormatOptions</code>.</li>
<li>Files that fail to parse are skipped; a summary is printed.</li>
<li>With <code>--write false</code> on a single file input, the formatted output is printed to stdout.</li>
</ul>
<hr />
<h2 id="design-notes"><a class="header" href="#design-notes">Design Notes</a></h2>
<ul>
<li>Emitters are AST-driven to preserve structure while normalizing whitespace and layout based on policies.</li>
<li>The formatter avoids changing semantics and focuses on consistent style.</li>
<li>Options default to safe, conservative values and can be tuned via CLI.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analysis-framework-overview"><a class="header" href="#analysis-framework-overview">Analysis Framework Overview</a></h1>
<p>The BSharp analysis framework provides a comprehensive suite of tools for analyzing C# code at various levels of detail. It is built on top of the BSharp parser infrastructure and offers insights into code structure, quality, dependencies, and maintainability. These capabilities support standalone analysis tools and editor/CI integrations.</p>
<h2 id="analysis-architecture"><a class="header" href="#analysis-architecture">Analysis Architecture</a></h2>
<p>The analysis framework is organized into specialized modules:</p>
<pre><code>src/bsharp_analysis/src/
├── framework/        # pipeline, passes, registry, session, walker, query
├── passes/           # indexing, metrics, control_flow, dependencies, reporting
├── artifacts/        # symbols, cfg, dependencies
├── metrics/          # AstAnalysis data + shared helpers
├── rules/            # naming, semantic, control_flow_smells
├── report/           # AnalysisReport assembly
└── (no quality module)
</code></pre>
<h2 id="analysis-capabilities"><a class="header" href="#analysis-capabilities">Analysis Capabilities</a></h2>
<h3 id="control-flow-analysis"><a class="header" href="#control-flow-analysis">Control Flow Analysis</a></h3>
<ul>
<li><strong>Path Analysis</strong>: Identify all possible execution paths through methods</li>
<li><strong>Reachability</strong>: Detect unreachable code sections</li>
<li><strong>Complexity Metrics</strong>: Calculate cyclomatic complexity and other flow-based metrics</li>
<li><strong>Dead Code Detection</strong>: Find code that can never be executed</li>
</ul>
<h3 id="dependency-analysis"><a class="header" href="#dependency-analysis">Dependency Analysis</a></h3>
<ul>
<li><strong>Type Dependencies</strong>: Track relationships between types</li>
<li><strong>Assembly Dependencies</strong>: Analyze external assembly usage</li>
<li><strong>Circular Dependencies</strong>: Detect problematic dependency cycles</li>
<li><strong>Coupling Metrics</strong>: Measure afferent and efferent coupling</li>
</ul>
<h3 id="code-metrics"><a class="header" href="#code-metrics">Code Metrics</a></h3>
<p>Comprehensive metrics collection across multiple dimensions:</p>
<h4 id="complexity-metrics"><a class="header" href="#complexity-metrics">Complexity Metrics</a></h4>
<ul>
<li>Cyclomatic Complexity</li>
<li>Cognitive Complexity</li>
<li>Nesting Depth</li>
<li>Method Length</li>
</ul>
<h4 id="size-metrics"><a class="header" href="#size-metrics">Size Metrics</a></h4>
<ul>
<li>Lines of Code (LOC)</li>
<li>Source Lines of Code (SLOC)</li>
<li>Comment Lines</li>
<li>Method Count per Class</li>
</ul>
<h4 id="maintainability-metrics"><a class="header" href="#maintainability-metrics">Maintainability Metrics</a></h4>
<ul>
<li>Maintainability Index</li>
<li>Technical Debt Indicators</li>
<li>Code Duplication Detection</li>
<li>Halstead Metrics</li>
</ul>
<h3 id="rules"><a class="header" href="#rules">Rules</a></h3>
<ul>
<li><strong>Naming Rules</strong>: Basic naming convention checks</li>
<li><strong>Control Flow Smells</strong>: Simple flow-related smells (e.g., deep nesting warnings)</li>
</ul>
<h3 id="type-analysis"><a class="header" href="#type-analysis">Type Analysis</a></h3>
<ul>
<li><strong>Type Usage</strong>: Track how types are used throughout the codebase</li>
<li><strong>Generic Analysis</strong>: Analyze generic type usage patterns</li>
<li><strong>Inheritance Hierarchies</strong>: Map class and interface hierarchies</li>
<li><strong>Interface Compliance</strong>: Validate interface implementations</li>
</ul>
<h2 id="analysis-workflow"><a class="header" href="#analysis-workflow">Analysis Workflow</a></h2>
<h3 id="1-ast-preparation"><a class="header" href="#1-ast-preparation">1. AST Preparation</a></h3>
<p>All analysis begins with a parsed AST:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let parser = Parser::new();
let compilation_unit = parser.parse(source_code)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-pipeline"><a class="header" href="#2-pipeline">2. Pipeline</a></h3>
<p>Use the framework pipeline with registered passes. Per-file runs populate typed artifacts; a final <code>AnalysisReport</code> summarizes metrics, control flow, and dependencies.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::framework::pipeline::AnalyzerPipeline;
use bsharp_analysis::framework::session::AnalysisSession;
use bsharp_analysis::context::AnalysisContext;
use bsharp_analysis::report::AnalysisReport;
use bsharp_parser::facade::Parser;

let parser = Parser::new();
let (cu, spans) = parser.parse_with_spans(source_code)?;
let ctx = AnalysisContext::new("file.cs", source_code);
let mut session = AnalysisSession::new(ctx, spans);
AnalyzerPipeline::run_with_defaults(&amp;cu, &amp;mut session);
let report: AnalysisReport = AnalysisReport::from_session(&amp;session);
<span class="boring">}</span></code></pre></pre>
<h3 id="3-analysis-execution"><a class="header" href="#3-analysis-execution">3. Analysis Execution</a></h3>
<p>The pipeline runs passes in phases:</p>
<ul>
<li>Index → Metrics (local) → Global (CFG, deps) → Semantic rules → Reporting</li>
</ul>
<p>Artifacts (e.g., <code>AstAnalysis</code>, <code>ControlFlowIndex</code>, <code>DependencyGraph</code>) are inserted into the <code>AnalysisSession</code> and consumed by reporting.</p>
<h3 id="4-results-processing"><a class="header" href="#4-results-processing">4. Results Processing</a></h3>
<p>Analysis results are structured for easy consumption:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Metrics results
println!("Cyclomatic Complexity: {}", metrics.cyclomatic_complexity);
println!("Lines of Code: {}", metrics.lines_of_code);

// Diagnostics
for d in &amp;report.diagnostics.diagnostics {
    println!("{}: {}", d.code, d.message);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="analysis-registry-and-passes"><a class="header" href="#analysis-registry-and-passes">Analysis Registry and Passes</a></h2>
<p>Analyses are implemented as <code>AnalyzerPass</code> implementations registered in an <code>AnalyzerRegistry</code> and executed by the <code>AnalyzerPipeline</code>. Local rulesets and semantic rulesets run alongside passes based on <code>Phase</code>.</p>
<h2 id="configuration-and-customization"><a class="header" href="#configuration-and-customization">Configuration and Customization</a></h2>
<h3 id="analysis-configuration"><a class="header" href="#analysis-configuration">Analysis Configuration</a></h3>
<p>Analyzers can be configured for different scenarios:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = AnalysisConfig {
    max_cyclomatic_complexity: 10,
    max_method_length: 50,
    enforce_naming_conventions: true,
    detect_code_smells: true,
    // ... other configuration options
};

let analyzer = MetricsAnalyzer::with_config(config);
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-rules"><a class="header" href="#custom-rules">Custom Rules</a></h3>
<p>Extend analysis with custom rules:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let custom_analyzer = QualityAnalyzer::new()
    .add_rule(CustomRule::new("no-goto-statements"))
    .add_rule(CustomRule::new("max-parameters", 5))
    .add_rule(CustomRule::new("prefer-composition"));
<span class="boring">}</span></code></pre></pre>
<h3 id="reporting-options"><a class="header" href="#reporting-options">Reporting Options</a></h3>
<p>Flexible reporting formats:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// JSON output
let json_report = analyzer.analyze(&amp;ast).to_json();

// XML output
let xml_report = analyzer.analyze(&amp;ast).to_xml();

// Custom format
let custom_report = analyzer.analyze(&amp;ast).format_with(custom_formatter);
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-points"><a class="header" href="#integration-points">Integration Points</a></h2>
<h3 id="cli-integration"><a class="header" href="#cli-integration">CLI Integration</a></h3>
<p>Analysis capabilities are exposed through the <code>analyze</code> command and configured via options (format, config, include/exclude, enable/disable passes and rulesets, severity overrides). See <code>docs/cli/analyze.md</code> for details.</p>
<h3 id="programmatic-usage"><a class="header" href="#programmatic-usage">Programmatic Usage</a></h3>
<p>Direct integration in tools typically runs the pipeline and pulls artifacts from the session:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::context::AnalysisContext;
use bsharp_analysis::framework::{AnalyzerPipeline, AnalysisSession};
use bsharp_analysis::metrics::AstAnalysis;
use bsharp_parser::facade::Parser;

let source = fs::read_to_string(path)?;
let (cu, spans) = Parser::new().parse_with_spans(&amp;source)?;
let mut session = AnalysisSession::new(AnalysisContext::new(path, &amp;source), spans);
AnalyzerPipeline::run_with_defaults(&amp;cu, &amp;mut session);
if let Some(ast) = session.artifacts.get::&lt;AstAnalysis&gt;() {
    println!("methods={} complexity={}", ast.total_methods, ast.cyclomatic_complexity);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<h3 id="analysis-performance"><a class="header" href="#analysis-performance">Analysis Performance</a></h3>
<ul>
<li><strong>Incremental Analysis</strong>: Support for analyzing only changed parts</li>
<li><strong>Parallel Processing</strong>: Multi-threaded analysis for large codebases</li>
<li><strong>Memory Efficiency</strong>: Minimal memory overhead during analysis</li>
<li><strong>Caching</strong>: Results caching for repeated analysis</li>
</ul>
<h3 id="scalability"><a class="header" href="#scalability">Scalability</a></h3>
<p>The framework scales from single files to large enterprise codebases:</p>
<ul>
<li>Single file analysis: Sub-second performance</li>
<li>Medium projects (100+ files): Seconds to minutes</li>
<li>Large codebases (1000+ files): Minutes with parallel processing</li>
</ul>
<p>This analysis framework provides the foundation for building sophisticated code quality tools, IDE integrations, and automated code review systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analysis-pipeline"><a class="header" href="#analysis-pipeline">Analysis Pipeline</a></h1>
<p>This document describes the analysis pipeline architecture, artifacts, rulesets, configuration toggles, and determinism guarantees in the B# analyzer.</p>
<h2 id="phases"><a class="header" href="#phases">Phases</a></h2>
<p>The pipeline runs in deterministic phases (see <code>src/bsharp_analysis/src/framework/pipeline.rs</code>):</p>
<ul>
<li><strong>Index</strong>
<ul>
<li>Runs early passes like <code>IndexingPass</code> to populate core artifacts (<code>SymbolIndex</code>, <code>NameIndex</code>, <code>FqnMap</code>).</li>
</ul>
</li>
<li><strong>Local Rules</strong>
<ul>
<li>Runs per-file passes such as <code>MetricsPass</code> (Query-based) to compute artifacts like <code>AstAnalysis</code>.</li>
<li>Local rulesets run here as well; use <code>bsharp_analysis::framework::Query</code> for AST enumeration.</li>
</ul>
</li>
<li><strong>Global</strong>
<ul>
<li>Passes that aggregate information across the file (or project) after initial indexing.</li>
</ul>
</li>
<li><strong>Semantic</strong>
<ul>
<li>Rules and passes that require previously built artifacts (e.g., control flow, dependencies).</li>
</ul>
</li>
<li><strong>Reporting</strong>
<ul>
<li>Finalization phase that can synthesize report artifacts.</li>
</ul>
</li>
</ul>
<p>Each phase is explicitly selected in <code>AnalyzerPipeline::run_for_file()</code> using <code>Phase</code> discriminants. Pass and ruleset registration is driven by <code>AnalyzerRegistry</code>.</p>
<h2 id="artifacts"><a class="header" href="#artifacts">Artifacts</a></h2>
<p>Artifacts are stored in the per-file <code>AnalysisSession.artifacts</code> and summarized into an <code>AnalysisReport</code>:</p>
<ul>
<li><strong>Symbols</strong> (<code>src/bsharp_analysis/src/artifacts/symbols.rs</code>)
<ul>
<li><code>SymbolIndex</code> (by id and name), <code>NameIndex</code> (name frequencies), <code>FqnMap</code> (local name → FQNs).</li>
</ul>
</li>
<li><strong>Control Flow</strong> (<code>src/bsharp_analysis/src/artifacts/cfg.rs</code>)
<ul>
<li><code>ControlFlowIndex</code> keyed per method; summarized to <code>CfgSummary</code> with total methods and smell counts.</li>
</ul>
</li>
<li><strong>Dependencies</strong> (<code>src/bsharp_analysis/src/artifacts/dependencies.rs</code>)
<ul>
<li>Graph keyed by symbols; summarized to node/edge counts.</li>
</ul>
</li>
<li><strong>Metrics</strong> (<code>src/bsharp_analysis/src/artifacts/metrics.rs</code> → <code>AstAnalysis</code>)
<ul>
<li>Basic metrics gathered during the local traversal.</li>
</ul>
</li>
</ul>
<p>Artifacts are optional in the final report; missing artifacts simply result in <code>None</code> summaries.</p>
<h2 id="rulesets-and-passes"><a class="header" href="#rulesets-and-passes">Rulesets and Passes</a></h2>
<p>Rules implement the <code>Rule</code> trait and are grouped into logical rulesets. Passes implement <code>AnalyzerPass</code> and declare a <code>Phase</code>:</p>
<ul>
<li>Rulesets are separated into Local vs. Semantic groups and executed during the respective phases.</li>
<li>Passes can be toggled individually by id.</li>
<li>The registry is created with <code>AnalyzerRegistry::from_config(&amp;AnalysisConfig)</code> to honor config toggles.</li>
</ul>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p><code>AnalysisConfig</code> (<code>src/bsharp_analysis/src/context.rs</code>) controls thresholds and toggles:</p>
<ul>
<li><strong>Control flow thresholds</strong>
<ul>
<li><code>cf_high_complexity_threshold</code> (default 10)</li>
<li><code>cf_deep_nesting_threshold</code> (default 4)</li>
</ul>
</li>
<li><strong>Toggles</strong>
<ul>
<li><code>enable_rulesets: HashMap&lt;String, bool&gt;</code></li>
<li><code>enable_passes: HashMap&lt;String, bool&gt;</code></li>
<li><code>rule_severities: HashMap&lt;String, DiagnosticSeverity&gt;</code></li>
</ul>
</li>
<li><strong>Workspace filters</strong>
<ul>
<li><code>workspace.follow_refs: bool</code></li>
<li><code>workspace.include: Vec&lt;String&gt;</code> (glob patterns)</li>
<li><code>workspace.exclude: Vec&lt;String&gt;</code> (glob patterns)</li>
</ul>
</li>
</ul>
<p>CLI maps flags to these fields in <code>src/bsharp_cli/src/commands/analyze.rs</code> and supports TOML/JSON config files.</p>
<h2 id="workspace-analysis-and-determinism"><a class="header" href="#workspace-analysis-and-determinism">Workspace Analysis and Determinism</a></h2>
<p><code>AnalyzerPipeline::run_workspace()</code> and <code>run_workspace_with_config()</code>:</p>
<ul>
<li>Discover files deterministically by sorting absolute paths and deduping.</li>
<li>Analyze each file independently, then merge artifacts into a single <code>AnalysisReport</code>.</li>
<li>Diagnostics are sorted by file, line, column, then diagnostic code for stable output.</li>
<li>Workspace loader warnings/errors are merged into <code>workspace_warnings</code> (sorted, deduped).</li>
<li>When the <code>parallel_analysis</code> feature is enabled, files are analyzed in parallel but merged deterministically in path order.</li>
</ul>
<h2 id="report-schema"><a class="header" href="#report-schema">Report Schema</a></h2>
<p><code>AnalysisReport</code> (<code>src/bsharp_analysis/src/report/mod.rs</code>) includes:</p>
<ul>
<li><code>schema_version: u32</code> (currently 1)</li>
<li><code>diagnostics: DiagnosticCollection</code></li>
<li><code>metrics: Option&lt;AstAnalysis&gt;</code></li>
<li><code>cfg: Option&lt;CfgSummary&gt;</code></li>
<li><code>deps: Option&lt;DependencySummary&gt;</code></li>
<li><code>workspace_warnings: Vec&lt;String&gt;</code></li>
<li><code>workspace_errors: Vec&lt;String&gt;</code> (reserved for future use)</li>
</ul>
<p>The JSON shape is intentionally stable; tests use snapshots with path normalization to ensure cross-platform consistency.</p>
<h2 id="testing-guidance"><a class="header" href="#testing-guidance">Testing Guidance</a></h2>
<ul>
<li>Prefer deterministic fixtures under <code>tests/fixtures/</code>.</li>
<li>Normalize absolute paths in snapshots (see <code>tests/integration/workspace_analysis_snapshot.rs</code>).</li>
<li>For workspace filtering, use <code>run_workspace_with_config()</code> with <code>include</code>/<code>exclude</code> globs and snapshot the resulting report.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analysis-traversal-guide"><a class="header" href="#analysis-traversal-guide">Analysis Traversal Guide</a></h1>
<p>This guide explains how to traverse BSharp AST statements and expressions in analysis passes using the current framework.</p>
<ul>
<li>Source files:
<ul>
<li><code>src/bsharp_analysis/src/framework/walker.rs</code></li>
<li><code>src/bsharp_analysis/src/framework/query/</code></li>
<li><code>src/bsharp_analysis/src/passes/*</code></li>
</ul>
</li>
</ul>
<h2 id="statement-traversal"><a class="header" href="#statement-traversal">Statement traversal</a></h2>
<p>Use <code>AstWalker</code> for single-pass traversal with the <code>Visit</code> trait, or the <code>Query</code> API for typed filtering.</p>
<p>Example using <code>AstWalker</code> + <code>Visit</code> to count <code>if</code> statements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::framework::{AstWalker, Visit, NodeRef, AnalysisSession};

struct CountIfs { pub ifs: usize }
impl Visit for CountIfs {
    fn enter(&amp;mut self, node: &amp;NodeRef, _session: &amp;mut AnalysisSession) {
        if let NodeRef::Statement(s) = node {
            if matches!(s, bsharp_syntax::statements::statement::Statement::If(_)) {
                self.ifs += 1;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="expression-traversal"><a class="header" href="#expression-traversal">Expression traversal</a></h2>
<p>Use <code>Query</code> for typed expression searches:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::framework::{NodeRef, Query};
use bsharp_syntax::expressions::AwaitExpression;

let await_count = Query::from(NodeRef::CompilationUnit(&amp;cu))
    .of::&lt;AwaitExpression&gt;()
    .count();
<span class="boring">}</span></code></pre></pre>
<h2 id="putting-it-together"><a class="header" href="#putting-it-together">Putting it together</a></h2>
<p>When analyzing methods, you typically:</p>
<ul>
<li>Parse the compilation unit and build the analysis session.</li>
<li>For each method body (a <code>Statement::Block</code>), compute metrics by walking statements and expressions.</li>
</ul>
<p>Example (from <code>ControlFlowPass</code> pattern):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::artifacts::cfg::{ControlFlowIndex, MethodControlFlowStats};
use bsharp_syntax::statements::statement::Statement;

fn stats_for_method(body: Option&lt;&amp;Statement&gt;) -&gt; MethodControlFlowStats {
    let complexity = match body { Some(s) =&gt; 1 + decision_points(s), None =&gt; 1 };
    let max_nesting = calc_max_nesting(body, 0);
    let exit_points = count_exit_points(body);
    let statement_count = count_statements(body);
    MethodControlFlowStats { complexity, max_nesting, exit_points, statement_count }
}
<span class="boring">}</span></code></pre></pre>
<p>See <code>src/bsharp_analysis/src/metrics/shared.rs</code> for helpers like <code>decision_points</code>, <code>max_nesting_of</code>, <code>count_statements</code> and <code>src/bsharp_analysis/src/passes/control_flow.rs</code> for usage.</p>
<hr />
<h2 id="see-also-4"><a class="header" href="#see-also-4">See Also</a></h2>
<ul>
<li><a href="analysis/../development/cookbooks.html">Cookbooks</a></li>
<li><a href="analysis/../development/query-cookbook.html">Query Cookbook</a></li>
</ul>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<ul>
<li>Keep walkers side-effect free; accumulate results in closures.</li>
<li>Prefer small, focused passes that use the walkers rather than embedding traversal in each pass.</li>
<li>If a construct is not being traversed, add it to the walker first to avoid duplicated traversal logic.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow-analysis-1"><a class="header" href="#control-flow-analysis-1">Control Flow Analysis</a></h1>
<p>The control flow analysis system analyzes method control flow to calculate complexity metrics, detect control flow smells, and identify potential issues.</p>
<hr />
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p><strong>Location:</strong> <code>src/bsharp_analysis/src/passes/control_flow.rs</code>, <code>src/bsharp_analysis/src/artifacts/cfg.rs</code></p>
<p>Control flow analysis provides:</p>
<ul>
<li>Cyclomatic complexity calculation</li>
<li>Maximum nesting depth tracking</li>
<li>Exit point counting</li>
<li>Statement counting</li>
<li>Control flow smell detection</li>
</ul>
<hr />
<h2 id="control-flow-metrics"><a class="header" href="#control-flow-metrics">Control Flow Metrics</a></h2>
<h3 id="cyclomatic-complexity"><a class="header" href="#cyclomatic-complexity">Cyclomatic Complexity</a></h3>
<p><strong>Definition:</strong> Number of linearly independent paths through a method</p>
<p><strong>Calculation:</strong> <code>CC = 1 + number of decision points</code></p>
<p><strong>Decision Points:</strong></p>
<ul>
<li><code>if</code> statements</li>
<li><code>case</code> labels in <code>switch</code></li>
<li>Loop statements (<code>for</code>, <code>foreach</code>, <code>while</code>, <code>do-while</code>)</li>
<li><code>catch</code> clauses</li>
<li>Logical operators (<code>&amp;&amp;</code>, <code>||</code>) in conditions</li>
<li>Ternary operators (<code>?:</code>)</li>
<li>Null-coalescing operators (<code>??</code>)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void ProcessOrder(Order order) {  // CC = 1 (base)
    if (order == null) {                 // +1 = 2
        throw new ArgumentNullException();
    }
    
    if (order.IsValid) {                 // +1 = 3
        if (order.Amount &gt; 1000) {       // +1 = 4
            ApplyDiscount(order);
        }
        SaveOrder(order);
    }
}
// Total CC = 4
</code></pre>
<h3 id="maximum-nesting-depth"><a class="header" href="#maximum-nesting-depth">Maximum Nesting Depth</a></h3>
<p><strong>Definition:</strong> Deepest level of nested control structures</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void Example() {
    if (condition1) {              // Depth 1
        while (condition2) {       // Depth 2
            if (condition3) {      // Depth 3
                DoSomething();
            }
        }
    }
}
// Max Nesting Depth = 3
</code></pre>
<h3 id="exit-points"><a class="header" href="#exit-points">Exit Points</a></h3>
<p><strong>Definition:</strong> Number of points where method can return</p>
<p><strong>Counted:</strong></p>
<ul>
<li><code>return</code> statements</li>
<li><code>throw</code> statements</li>
<li>End of void method</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public int Calculate(int x) {
    if (x &lt; 0) {
        return -1;        // Exit point 1
    }
    if (x == 0) {
        return 0;         // Exit point 2
    }
    return x * 2;         // Exit point 3
}
// Total Exit Points = 3
</code></pre>
<h3 id="statement-count"><a class="header" href="#statement-count">Statement Count</a></h3>
<p><strong>Definition:</strong> Total number of statements in method body</p>
<p>Includes all statement types:</p>
<ul>
<li>Expression statements</li>
<li>Declaration statements</li>
<li>Control flow statements</li>
<li>Jump statements</li>
</ul>
<hr />
<h2 id="control-flow-artifacts"><a class="header" href="#control-flow-artifacts">Control Flow Artifacts</a></h2>
<h3 id="methodcontrolflowstats"><a class="header" href="#methodcontrolflowstats">MethodControlFlowStats</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MethodControlFlowStats {
    pub complexity: usize,
    pub max_nesting: usize,
    pub exit_points: usize,
    pub statement_count: usize,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="controlflowindex"><a class="header" href="#controlflowindex">ControlFlowIndex</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ControlFlowIndex {
    // Method identifier -&gt; stats
    methods: HashMap&lt;String, MethodControlFlowStats&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cfgsummary"><a class="header" href="#cfgsummary">CfgSummary</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CfgSummary {
    pub total_methods: usize,
    pub high_complexity_count: usize,
    pub deep_nesting_count: usize,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="control-flow-smells"><a class="header" href="#control-flow-smells">Control Flow Smells</a></h2>
<h3 id="high-complexity"><a class="header" href="#high-complexity">High Complexity</a></h3>
<p><strong>Threshold:</strong> Configurable (default: 10)</p>
<p><strong>Detection:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if stats.complexity &gt; config.cf_high_complexity_threshold {
    session.diagnostics.add(
        DiagnosticCode::HighComplexity,
        format!("Method complexity {} exceeds threshold {}", 
               stats.complexity, threshold)
    );
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Diagnostic:</strong></p>
<pre><code>warning[CF002]: High cyclomatic complexity
  --&gt; src/OrderProcessor.cs:42:17
   |
42 |     public void ProcessOrder(Order order) {
   |                 ^^^^^^^^^^^^ complexity = 15 (threshold: 10)
   |
   = help: Consider breaking this method into smaller methods
</code></pre>
<h3 id="deep-nesting"><a class="header" href="#deep-nesting">Deep Nesting</a></h3>
<p><strong>Threshold:</strong> Configurable (default: 4)</p>
<p><strong>Detection:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if stats.max_nesting &gt; config.cf_deep_nesting_threshold {
    session.diagnostics.add(
        DiagnosticCode::DeepNesting,
        format!("Maximum nesting depth {} exceeds threshold {}", 
               stats.max_nesting, threshold)
    );
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Diagnostic:</strong></p>
<pre><code>warning[CF003]: Deep nesting detected
  --&gt; src/Validator.cs:15:9
   |
15 |         if (condition1) {
   |         ^^ nesting depth = 5 (threshold: 4)
   |
   = help: Consider extracting nested logic into separate methods
</code></pre>
<hr />
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="analysis-pass"><a class="header" href="#analysis-pass">Analysis Pass</a></h3>
<p><strong>Location:</strong> <code>src/bsharp_analysis/src/passes/control_flow.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ControlFlowPass;

impl AnalyzerPass for ControlFlowPass {
    fn id(&amp;self) -&gt; &amp;'static str { "control_flow" }
    fn phase(&amp;self) -&gt; Phase { Phase::Semantic }
    
    fn run(&amp;self, cu: &amp;CompilationUnit, session: &amp;mut AnalysisSession) {
        let mut index = ControlFlowIndex::new();
        
        // Analyze all methods in compilation unit
        for decl in &amp;cu.declarations {
            analyze_declaration(decl, &amp;mut index, session);
        }
        
        session.artifacts.cfg = Some(index);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="method-analysis"><a class="header" href="#method-analysis">Method Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn analyze_method(
    method: &amp;MethodDeclaration,
    index: &amp;mut ControlFlowIndex,
    session: &amp;mut AnalysisSession
) {
    let stats = calculate_stats(method.body.as_ref());
    
    // Check thresholds
    if stats.complexity &gt; session.config.cf_high_complexity_threshold {
        session.diagnostics.add(/* high complexity diagnostic */);
    }
    
    if stats.max_nesting &gt; session.config.cf_deep_nesting_threshold {
        session.diagnostics.add(/* deep nesting diagnostic */);
    }
    
    // Store in index
    index.add_method(&amp;method.identifier.name, stats);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="stats-calculation"><a class="header" href="#stats-calculation">Stats Calculation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_stats(body: Option&lt;&amp;Statement&gt;) -&gt; MethodControlFlowStats {
    let complexity = match body {
        Some(stmt) =&gt; 1 + count_decision_points(stmt),
        None =&gt; 1,
    };
    
    let max_nesting = calculate_max_nesting(body, 0);
    let exit_points = count_exit_points(body);
    let statement_count = count_statements(body);
    
    MethodControlFlowStats {
        complexity,
        max_nesting,
        exit_points,
        statement_count,
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<h3 id="thresholds"><a class="header" href="#thresholds">Thresholds</a></h3>
<pre><code class="language-toml">[analysis.control_flow]
cf_high_complexity_threshold = 10
cf_deep_nesting_threshold = 4
</code></pre>
<h3 id="cli-usage"><a class="header" href="#cli-usage">CLI Usage</a></h3>
<pre><code class="language-bash"># Analyze with custom thresholds
bsharp analyze MyProject.csproj --config .bsharp.toml

# Enable control flow pass
bsharp analyze MyProject.csproj --enable-pass control_flow
</code></pre>
<hr />
<h2 id="integration-with-pipeline"><a class="header" href="#integration-with-pipeline">Integration with Pipeline</a></h2>
<h3 id="phase-semantic"><a class="header" href="#phase-semantic">Phase: Semantic</a></h3>
<p>Control flow analysis runs in the <strong>Semantic</strong> phase after symbol indexing:</p>
<pre><code>Phase::Index    -&gt; Build SymbolIndex
Phase::Local    -&gt; Collect metrics
Phase::Semantic -&gt; Control flow analysis
</code></pre>
<h3 id="artifacts-1"><a class="header" href="#artifacts-1">Artifacts</a></h3>
<p>Results stored in <code>AnalysisSession</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>session.artifacts.cfg = Some(ControlFlowIndex { ... });
<span class="boring">}</span></code></pre></pre>
<p>Summarized in <code>AnalysisReport</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>report.cfg = Some(CfgSummary {
    total_methods: 87,
    high_complexity_count: 5,
    deep_nesting_count: 3,
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="related-documentation"><a class="header" href="#related-documentation">Related Documentation</a></h2>
<ul>
<li><a href="analysis/./pipeline.html">Analysis Pipeline</a> - Pipeline integration</li>
<li><a href="analysis/./metrics.html">Metrics Collection</a> - Related metrics</li>
<li><a href="analysis/./quality.html">Code Quality</a> - Quality rules</li>
<li><a href="analysis/./traversal-guide.html">Traversal Guide</a> - AST traversal</li>
</ul>
<hr />
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/bsharp_analysis/src/passes/control_flow.rs</code></li>
<li><strong>Artifacts:</strong> <code>src/bsharp_analysis/src/artifacts/cfg.rs</code></li>
<li><strong>Tests:</strong> <code>src/bsharp_tests/src/analysis/control_flow/</code> (planned)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependency-analysis-1"><a class="header" href="#dependency-analysis-1">Dependency Analysis</a></h1>
<p>The dependency analysis system tracks relationships between types, methods, and other symbols in C# code to identify coupling, circular dependencies, and architectural issues.</p>
<hr />
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p><strong>Location:</strong> <code>src/bsharp_analysis/src/artifacts/dependencies.rs</code></p>
<p>The dependency analysis builds a directed graph of symbol relationships, where:</p>
<ul>
<li><strong>Nodes</strong> represent symbols (classes, interfaces, methods, etc.)</li>
<li><strong>Edges</strong> represent dependencies (inheritance, method calls, field types, etc.)</li>
</ul>
<hr />
<h2 id="dependency-types"><a class="header" href="#dependency-types">Dependency Types</a></h2>
<h3 id="type-dependencies"><a class="header" href="#type-dependencies">Type Dependencies</a></h3>
<p><strong>Inheritance:</strong></p>
<pre><code class="language-csharp">public class Derived : Base { }  // Derived depends on Base
</code></pre>
<p><strong>Interface Implementation:</strong></p>
<pre><code class="language-csharp">public class MyClass : IInterface { }  // MyClass depends on IInterface
</code></pre>
<p><strong>Field Types:</strong></p>
<pre><code class="language-csharp">public class Container {
    private Helper helper;  // Container depends on Helper
}
</code></pre>
<p><strong>Method Parameters and Return Types:</strong></p>
<pre><code class="language-csharp">public Response Process(Request req) { }  // Process depends on Request and Response
</code></pre>
<h3 id="member-dependencies"><a class="header" href="#member-dependencies">Member Dependencies</a></h3>
<p><strong>Method Calls:</strong></p>
<pre><code class="language-csharp">public void Caller() {
    Helper.DoSomething();  // Caller depends on Helper.DoSomething
}
</code></pre>
<p><strong>Property Access:</strong></p>
<pre><code class="language-csharp">var value = obj.Property;  // Depends on Property
</code></pre>
<p><strong>Constructor Calls:</strong></p>
<pre><code class="language-csharp">var instance = new MyClass();  // Depends on MyClass constructor
</code></pre>
<hr />
<h2 id="dependency-graph-structure"><a class="header" href="#dependency-graph-structure">Dependency Graph Structure</a></h2>
<h3 id="dependencygraph"><a class="header" href="#dependencygraph">DependencyGraph</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DependencyGraph {
    // Symbol ID -&gt; list of symbols it depends on
    dependencies: HashMap&lt;SymbolId, Vec&lt;SymbolId&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="operations"><a class="header" href="#operations">Operations</a></h3>
<p><strong>Adding Dependencies:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>graph.add_dependency(from_symbol, to_symbol);
<span class="boring">}</span></code></pre></pre>
<p><strong>Querying Dependencies:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Direct dependencies
let deps = graph.get_dependencies(symbol_id);

// Transitive dependencies
let all_deps = graph.get_transitive_dependencies(symbol_id);

// Reverse dependencies (who depends on this symbol)
let dependents = graph.get_dependents(symbol_id);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="circular-dependency-detection"><a class="header" href="#circular-dependency-detection">Circular Dependency Detection</a></h2>
<h3 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h3>
<p>The analysis uses depth-first search to detect cycles in the dependency graph:</p>
<ol>
<li>Start from each symbol</li>
<li>Traverse dependencies depth-first</li>
<li>Track visited nodes in current path</li>
<li>If we revisit a node in current path, cycle detected</li>
</ol>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-csharp">public class A {
    private B b;  // A depends on B
}

public class B {
    private C c;  // B depends on C
}

public class C {
    private A a;  // C depends on A -&gt; CYCLE: A -&gt; B -&gt; C -&gt; A
}
</code></pre>
<p><strong>Detection:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cycles = graph.find_cycles();
for cycle in cycles {
    // Report diagnostic for circular dependency
    session.diagnostics.add(
        DiagnosticCode::CircularDependency,
        format!("Circular dependency detected: {:?}", cycle)
    );
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="coupling-metrics"><a class="header" href="#coupling-metrics">Coupling Metrics</a></h2>
<h3 id="afferent-coupling-ca"><a class="header" href="#afferent-coupling-ca">Afferent Coupling (Ca)</a></h3>
<p><strong>Definition:</strong> Number of types that depend on this type (incoming dependencies)</p>
<p><strong>Interpretation:</strong></p>
<ul>
<li>High Ca = Many types depend on this type (responsibility)</li>
<li>Type is stable and hard to change</li>
</ul>
<h3 id="efferent-coupling-ce"><a class="header" href="#efferent-coupling-ce">Efferent Coupling (Ce)</a></h3>
<p><strong>Definition:</strong> Number of types this type depends on (outgoing dependencies)</p>
<p><strong>Interpretation:</strong></p>
<ul>
<li>High Ce = This type depends on many others</li>
<li>Type is unstable and sensitive to changes</li>
</ul>
<h3 id="instability-i"><a class="header" href="#instability-i">Instability (I)</a></h3>
<p><strong>Formula:</strong> <code>I = Ce / (Ca + Ce)</code></p>
<p><strong>Range:</strong> 0.0 to 1.0</p>
<ul>
<li><strong>0.0</strong> = Maximally stable (only incoming dependencies)</li>
<li><strong>1.0</strong> = Maximally unstable (only outgoing dependencies)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ca = graph.afferent_coupling(symbol_id);
let ce = graph.efferent_coupling(symbol_id);
let instability = ce as f64 / (ca + ce) as f64;

if instability &gt; 0.8 {
    // Highly unstable type - consider refactoring
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="dependency-summary"><a class="header" href="#dependency-summary">Dependency Summary</a></h2>
<h3 id="dependencysummary"><a class="header" href="#dependencysummary">DependencySummary</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DependencySummary {
    pub total_nodes: usize,
    pub total_edges: usize,
    pub circular_dependencies: usize,
    pub max_depth: usize,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Generated by:</strong> <code>DependencyGraph::summarize()</code></p>
<p><strong>Included in:</strong> <code>AnalysisReport</code></p>
<hr />
<h2 id="usage-in-analysis-pipeline"><a class="header" href="#usage-in-analysis-pipeline">Usage in Analysis Pipeline</a></h2>
<h3 id="phase-global"><a class="header" href="#phase-global">Phase: Global</a></h3>
<p>Dependency analysis runs in the <strong>Global</strong> phase after symbol indexing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In AnalyzerPipeline
Phase::Index   -&gt; Build SymbolIndex
Phase::Global  -&gt; Build DependencyGraph
Phase::Semantic -&gt; Use dependencies for semantic analysis
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-with-passes"><a class="header" href="#integration-with-passes">Integration with Passes</a></h3>
<p><strong>DependencyPass</strong> (if implemented):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AnalyzerPass for DependencyPass {
    fn id(&amp;self) -&gt; &amp;'static str { "dependencies" }
    fn phase(&amp;self) -&gt; Phase { Phase::Global }
    
    fn run(&amp;self, cu: &amp;CompilationUnit, session: &amp;mut AnalysisSession) {
        let graph = build_dependency_graph(cu, &amp;session.artifacts.symbols);
        session.artifacts.dependencies = Some(graph);
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="building-dependency-graph"><a class="header" href="#building-dependency-graph">Building Dependency Graph</a></h2>
<h3 id="from-compilationunit"><a class="header" href="#from-compilationunit">From CompilationUnit</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn build_dependency_graph(
    cu: &amp;CompilationUnit,
    symbols: &amp;SymbolIndex
) -&gt; DependencyGraph {
    let mut graph = DependencyGraph::new();
    
    // Visit all declarations
    for decl in &amp;cu.declarations {
        match decl {
            TopLevelDeclaration::Class(class) =&gt; {
                analyze_class_dependencies(class, symbols, &amp;mut graph);
            }
            // ... other declaration types
        }
    }
    
    graph
}
<span class="boring">}</span></code></pre></pre>
<h3 id="from-class-declaration"><a class="header" href="#from-class-declaration">From Class Declaration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn analyze_class_dependencies(
    class: &amp;ClassDeclaration,
    symbols: &amp;SymbolIndex,
    graph: &amp;mut DependencyGraph
) {
    let class_symbol = symbols.lookup(&amp;class.identifier.name);
    
    // Base types
    for base_type in &amp;class.base_types {
        if let Some(base_symbol) = resolve_type(base_type, symbols) {
            graph.add_dependency(class_symbol, base_symbol);
        }
    }
    
    // Members
    for member in &amp;class.body_declarations {
        analyze_member_dependencies(member, class_symbol, symbols, graph);
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="dependency-visualization"><a class="header" href="#dependency-visualization">Dependency Visualization</a></h2>
<h3 id="dependency-matrix"><a class="header" href="#dependency-matrix">Dependency Matrix</a></h3>
<p>Generate a matrix showing which types depend on which:</p>
<pre><code>        A  B  C  D
    A   -  X  -  X
    B   -  -  X  -
    C   X  -  -  -
    D   -  -  -  -
</code></pre>
<ul>
<li>Row A, Column B = X means A depends on B</li>
</ul>
<h3 id="dependency-tree"><a class="header" href="#dependency-tree">Dependency Tree</a></h3>
<pre><code>MyApp
├── Services
│   ├── UserService
│   │   ├── IUserRepository
│   │   └── IEmailService
│   └── OrderService
│       ├── IOrderRepository
│       └── IPaymentService
└── Models
    ├── User
    └── Order
</code></pre>
<hr />
<h2 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h2>
<h3 id="circular-dependency-warning"><a class="header" href="#circular-dependency-warning">Circular Dependency Warning</a></h3>
<pre><code>warning[DEP001]: Circular dependency detected
  --&gt; src/ClassA.cs:3:5
   |
 3 |     private ClassB b;
   |             ^^^^^^ ClassA depends on ClassB
   |
   = note: Dependency cycle: ClassA -&gt; ClassB -&gt; ClassC -&gt; ClassA
</code></pre>
<h3 id="high-coupling-warning"><a class="header" href="#high-coupling-warning">High Coupling Warning</a></h3>
<pre><code>warning[DEP002]: High efferent coupling detected
  --&gt; src/GodClass.cs:1:14
   |
 1 | public class GodClass {
   |              ^^^^^^^^ depends on 25 other types
   |
   = help: Consider breaking this class into smaller, focused classes
</code></pre>
<h3 id="unstable-dependency-warning"><a class="header" href="#unstable-dependency-warning">Unstable Dependency Warning</a></h3>
<pre><code>warning[DEP003]: Stable type depends on unstable type
  --&gt; src/StableClass.cs:5:5
   |
 5 |     private UnstableClass helper;
   |             ^^^^^^^^^^^^^ instability = 0.95
   |
   = note: Stable types (instability &lt; 0.2) should not depend on unstable types (instability &gt; 0.8)
</code></pre>
<hr />
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<h3 id="thresholds-1"><a class="header" href="#thresholds-1">Thresholds</a></h3>
<pre><code class="language-toml">[analysis.dependencies]
max_efferent_coupling = 20
max_afferent_coupling = 10
max_instability = 0.8
warn_circular_dependencies = true
</code></pre>
<h3 id="cli-usage-1"><a class="header" href="#cli-usage-1">CLI Usage</a></h3>
<pre><code class="language-bash"># Analyze dependencies
bsharp analyze MyProject.csproj --enable-pass dependencies

# Generate dependency report
bsharp analyze MyProject.sln --out deps.json --format pretty-json
</code></pre>
<hr />
<h2 id="future-enhancements"><a class="header" href="#future-enhancements">Future Enhancements</a></h2>
<h3 id="planned-features"><a class="header" href="#planned-features">Planned Features</a></h3>
<ol>
<li>
<p><strong>Package-Level Dependencies</strong></p>
<ul>
<li>Track dependencies between namespaces/assemblies</li>
<li>Identify layering violations</li>
</ul>
</li>
<li>
<p><strong>Dependency Metrics Dashboard</strong></p>
<ul>
<li>Visual dependency graphs</li>
<li>Coupling heatmaps</li>
<li>Trend analysis over time</li>
</ul>
</li>
<li>
<p><strong>Architectural Rules</strong></p>
<ul>
<li>Define allowed/forbidden dependencies</li>
<li>Enforce layered architecture</li>
<li>Prevent specific coupling patterns</li>
</ul>
</li>
<li>
<p><strong>Dependency Injection Analysis</strong></p>
<ul>
<li>Track DI container registrations</li>
<li>Verify dependency lifetimes</li>
<li>Detect missing registrations</li>
</ul>
</li>
</ol>
<hr />
<h2 id="implementation-status"><a class="header" href="#implementation-status">Implementation Status</a></h2>
<p><strong>Current State:</strong></p>
<ul>
<li>Basic dependency graph structure defined</li>
<li>Integration with analysis pipeline planned</li>
<li>Circular dependency detection algorithm ready</li>
</ul>
<p><strong>TODO:</strong></p>
<ul>
<li>Implement full dependency extraction from AST</li>
<li>Add coupling metrics calculation</li>
<li>Create dependency visualization tools</li>
<li>Add comprehensive tests</li>
</ul>
<hr />
<h2 id="related-documentation-1"><a class="header" href="#related-documentation-1">Related Documentation</a></h2>
<ul>
<li><a href="analysis/./pipeline.html">Analysis Pipeline</a> - How dependency analysis fits in the pipeline</li>
<li><a href="analysis/./control-flow.html">Control Flow Analysis</a> - Related analysis type</li>
<li><a href="analysis/./metrics.html">Metrics Collection</a> - Coupling metrics</li>
<li><a href="analysis/../development/architecture.html">Architecture Decisions</a> - Design rationale</li>
</ul>
<hr />
<h2 id="references-3"><a class="header" href="#references-3">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/bsharp_analysis/src/artifacts/dependencies.rs</code></li>
<li><strong>Tests:</strong> <code>src/bsharp_tests/src/analysis/dependencies/</code> (planned)</li>
<li><strong>Related Passes:</strong> <code>src/bsharp_analysis/src/passes/</code> (when implemented)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics Collection</a></h1>
<p>The BSharp metrics system collects comprehensive code metrics during analysis to assess code complexity, size, and maintainability.</p>
<hr />
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p><strong>Location:</strong> <code>src/bsharp_analysis/src/metrics/</code></p>
<p>The metrics system provides:</p>
<ul>
<li><strong>Basic Metrics</strong> - Lines of code, statement counts, declaration counts</li>
<li><strong>Complexity Metrics</strong> - Cyclomatic complexity, cognitive complexity, nesting depth</li>
<li><strong>Maintainability Metrics</strong> - Maintainability index, Halstead metrics</li>
</ul>
<hr />
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<h3 id="core-components"><a class="header" href="#core-components">Core Components</a></h3>
<pre><code>src/bsharp_analysis/src/metrics/
├── core.rs     # AstAnalysis data structure (aggregated counts)
└── shared.rs   # Helpers: decision_points, max_nesting_of, count_statements, etc.
</code></pre>
<h3 id="how-metrics-are-produced"><a class="header" href="#how-metrics-are-produced">How metrics are produced</a></h3>
<ul>
<li><code>MetricsPass</code> runs in <code>Phase::LocalRules</code> and computes an <code>AstAnalysis</code> artifact using the Query API to enumerate declarations, plus lightweight walkers for statement counts.</li>
<li>Access <code>AstAnalysis</code> from <code>AnalysisSession</code> after running the pipeline.</li>
</ul>
<hr />
<h2 id="metric-types"><a class="header" href="#metric-types">Metric Types</a></h2>
<h3 id="1-basic-metrics"><a class="header" href="#1-basic-metrics">1. Basic Metrics</a></h3>
<p><strong>AstAnalysis Structure:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AstAnalysis {
    // Size metrics
    pub total_lines: usize,
    pub code_lines: usize,
    pub comment_lines: usize,
    pub blank_lines: usize,
    
    // Declaration counts
    pub namespace_count: usize,
    pub class_count: usize,
    pub interface_count: usize,
    pub struct_count: usize,
    pub enum_count: usize,
    pub method_count: usize,
    pub property_count: usize,
    pub field_count: usize,
    
    // Statement counts
    pub statement_count: usize,
    pub expression_count: usize,
    
    // Complexity (aggregated)
    pub total_complexity: usize,
    pub max_complexity: usize,
    pub max_nesting_depth: usize,
}
<span class="boring">}</span></code></pre></pre>
<!-- Collection via trait impl removed; metrics are produced by MetricsPass during the pipeline. -->
<h3 id="2-complexity-metrics"><a class="header" href="#2-complexity-metrics">2. Complexity Metrics</a></h3>
<h4 id="cyclomatic-complexity-1"><a class="header" href="#cyclomatic-complexity-1">Cyclomatic Complexity</a></h4>
<p><strong>Definition:</strong> Number of linearly independent paths through code</p>
<p><strong>Formula:</strong> <code>CC = E - N + 2P</code></p>
<ul>
<li>E = edges in control flow graph</li>
<li>N = nodes in control flow graph</li>
<li>P = connected components (usually 1)</li>
</ul>
<p><strong>Simplified:</strong> <code>CC = 1 + number of decision points</code></p>
<p><strong>Decision Points:</strong></p>
<ul>
<li><code>if</code>, <code>else if</code></li>
<li><code>case</code> in <code>switch</code></li>
<li><code>for</code>, <code>foreach</code>, <code>while</code>, <code>do-while</code></li>
<li><code>&amp;&amp;</code>, <code>||</code> in conditions</li>
<li><code>catch</code> clauses</li>
<li><code>?:</code> ternary operator</li>
<li><code>??</code> null-coalescing operator</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void ProcessOrder(Order order) {  // CC = 1 (base)
    if (order == null) {                 // +1 = 2
        throw new ArgumentNullException();
    }
    
    if (order.IsValid) {                 // +1 = 3
        if (order.Amount &gt; 1000) {       // +1 = 4
            ApplyDiscount(order);
        }
        SaveOrder(order);
    } else {                             // else doesn't add
        LogError(order);
    }
}
// Total CC = 4
</code></pre>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn cyclomatic_complexity(method: &amp;MethodDeclaration) -&gt; usize {
    let mut complexity = 1;  // Base complexity
    
    if let Some(body) = &amp;method.body {
        complexity += count_decision_points(body);
    }
    
    complexity
}

fn count_decision_points(stmt: &amp;Statement) -&gt; usize {
    let mut count = 0;
    
    walk_statements(stmt, &amp;mut |s| {
        match s {
            Statement::If(_) =&gt; count += 1,
            Statement::For(_) =&gt; count += 1,
            Statement::ForEach(_) =&gt; count += 1,
            Statement::While(_) =&gt; count += 1,
            Statement::DoWhile(_) =&gt; count += 1,
            Statement::Switch(sw) =&gt; {
                // Each case is a decision point
                count += sw.sections.len();
            }
            Statement::Try(try_stmt) =&gt; {
                // Each catch is a decision point
                count += try_stmt.catch_clauses.len();
            }
            _ =&gt; {}
        }
    });
    
    // Also count logical operators in expressions
    // count += count_logical_operators(stmt);
    
    count
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Thresholds:</strong></p>
<ul>
<li><strong>1-10:</strong> Simple, low risk</li>
<li><strong>11-20:</strong> Moderate complexity, moderate risk</li>
<li><strong>21-50:</strong> Complex, high risk</li>
<li><strong>50+:</strong> Very complex, very high risk - refactor recommended</li>
</ul>
<h4 id="cognitive-complexity"><a class="header" href="#cognitive-complexity">Cognitive Complexity</a></h4>
<p><strong>Definition:</strong> Measure of how difficult code is to understand</p>
<p><strong>Increments:</strong></p>
<ul>
<li><strong>+1</strong> for each: <code>if</code>, <code>else if</code>, <code>switch</code>, <code>for</code>, <code>foreach</code>, <code>while</code>, <code>do-while</code>, <code>catch</code>, <code>?:</code>, <code>??</code></li>
<li><strong>+1</strong> for each level of nesting (nested control structures)</li>
<li><strong>+1</strong> for each <code>break</code> or <code>continue</code> that jumps out of nested structure</li>
<li><strong>+1</strong> for each recursive call</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void Process(List&lt;int&gt; items) {
    if (items != null) {                 // +1 (if)
        foreach (var item in items) {    // +1 (loop) +1 (nesting) = +2
            if (item &gt; 0) {              // +1 (if) +2 (nesting) = +3
                Process(item);           // +1 (recursion) +3 (nesting) = +4
            }
        }
    }
}
// Total Cognitive Complexity = 1 + 2 + 3 + 4 = 10
</code></pre>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn cognitive_complexity(method: &amp;MethodDeclaration) -&gt; usize {
    let mut complexity = 0;
    
    if let Some(body) = &amp;method.body {
        complexity = calculate_cognitive_complexity(body, 0);
    }
    
    complexity
}

fn calculate_cognitive_complexity(stmt: &amp;Statement, nesting_level: usize) -&gt; usize {
    let mut complexity = 0;
    
    match stmt {
        Statement::If(if_stmt) =&gt; {
            complexity += 1 + nesting_level;  // if + nesting penalty
            complexity += calculate_cognitive_complexity(&amp;if_stmt.consequence, nesting_level + 1);
            if let Some(alt) = &amp;if_stmt.alternative {
                complexity += calculate_cognitive_complexity(alt, nesting_level + 1);
            }
        }
        Statement::For(for_stmt) =&gt; {
            complexity += 1 + nesting_level;
            if let Some(body) = &amp;for_stmt.body {
                complexity += calculate_cognitive_complexity(body, nesting_level + 1);
            }
        }
        // ... other statement types
        _ =&gt; {}
    }
    
    complexity
}
<span class="boring">}</span></code></pre></pre>
<h4 id="nesting-depth"><a class="header" href="#nesting-depth">Nesting Depth</a></h4>
<p><strong>Definition:</strong> Maximum depth of nested control structures</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void Example() {
    if (condition1) {              // Depth 1
        while (condition2) {       // Depth 2
            if (condition3) {      // Depth 3
                for (int i = 0; i &lt; 10; i++) {  // Depth 4
                    // Code here
                }
            }
        }
    }
}
// Max Nesting Depth = 4
</code></pre>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn max_nesting_depth(method: &amp;MethodDeclaration) -&gt; usize {
    method.body.as_ref()
        .map(|body| calculate_max_nesting(body, 0))
        .unwrap_or(0)
}

fn calculate_max_nesting(stmt: &amp;Statement, current_depth: usize) -&gt; usize {
    let mut max_depth = current_depth;
    
    match stmt {
        Statement::If(if_stmt) =&gt; {
            let then_depth = calculate_max_nesting(&amp;if_stmt.consequence, current_depth + 1);
            max_depth = max_depth.max(then_depth);
            
            if let Some(alt) = &amp;if_stmt.alternative {
                let else_depth = calculate_max_nesting(alt, current_depth + 1);
                max_depth = max_depth.max(else_depth);
            }
        }
        Statement::Block(stmts) =&gt; {
            for s in stmts {
                let depth = calculate_max_nesting(s, current_depth);
                max_depth = max_depth.max(depth);
            }
        }
        // ... other nesting statements
        _ =&gt; {}
    }
    
    max_depth
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Thresholds:</strong></p>
<ul>
<li><strong>1-3:</strong> Acceptable</li>
<li><strong>4-5:</strong> Consider refactoring</li>
<li><strong>6+:</strong> Refactor recommended</li>
</ul>
<h3 id="planned-maintainability-metrics"><a class="header" href="#planned-maintainability-metrics">Planned: Maintainability Metrics</a></h3>
<h4 id="maintainability-index"><a class="header" href="#maintainability-index">Maintainability Index</a></h4>
<p><strong>Definition:</strong> Composite metric indicating code maintainability</p>
<p><strong>Formula (Microsoft version):</strong></p>
<pre><code>MI = MAX(0, (171 - 5.2 * ln(HV) - 0.23 * CC - 16.2 * ln(LOC)) * 100 / 171)
</code></pre>
<p>Where:</p>
<ul>
<li><strong>HV</strong> = Halstead Volume</li>
<li><strong>CC</strong> = Cyclomatic Complexity</li>
<li><strong>LOC</strong> = Lines of Code</li>
</ul>
<p><strong>Scale:</strong></p>
<ul>
<li><strong>85-100:</strong> Good maintainability (green)</li>
<li><strong>65-84:</strong> Moderate maintainability (yellow)</li>
<li><strong>0-64:</strong> Difficult to maintain (red)</li>
</ul>
<p>Note: Maintainability Index is not implemented in the current codebase. This section outlines potential future work.</p>
<pre><pre class="playground"><code class="language-rust">pub fn maintainability_index(
    halstead_volume: f64,
    cyclomatic_complexity: usize,
    lines_of_code: usize
) -&gt; f64 {
    let hv_term = 5.2 * halstead_volume.ln();
    let cc_term = 0.23 * (cyclomatic_complexity as f64);
    let loc_term = 16.2 * (lines_of_code as f64).ln();
    
    let mi = 171.0 - hv_term - cc_term - loc_term;
    let normalized = (mi * 100.0 / 171.0).max(0.0);
    
    normalized
}</code></pre></pre>
<h4 id="planned-halstead-metrics"><a class="header" href="#planned-halstead-metrics">Planned: Halstead Metrics</a></h4>
<p><strong>Operators and Operands:</strong></p>
<ul>
<li><strong>n1</strong> = number of distinct operators</li>
<li><strong>n2</strong> = number of distinct operands</li>
<li><strong>N1</strong> = total number of operators</li>
<li><strong>N2</strong> = total number of operands</li>
</ul>
<p><strong>Derived Metrics:</strong></p>
<ul>
<li><strong>Program Vocabulary:</strong> <code>n = n1 + n2</code></li>
<li><strong>Program Length:</strong> <code>N = N1 + N2</code></li>
<li><strong>Calculated Length:</strong> <code>N' = n1 * log2(n1) + n2 * log2(n2)</code></li>
<li><strong>Volume:</strong> <code>V = N * log2(n)</code></li>
<li><strong>Difficulty:</strong> <code>D = (n1 / 2) * (N2 / n2)</code></li>
<li><strong>Effort:</strong> <code>E = D * V</code></li>
<li><strong>Time to Program:</strong> <code>T = E / 18</code> seconds</li>
<li><strong>Bugs Delivered:</strong> <code>B = V / 3000</code></li>
</ul>
<p>Note: Halstead metrics are not implemented in the current codebase.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HalsteadMetrics {
    pub distinct_operators: usize,    // n1
    pub distinct_operands: usize,     // n2
    pub total_operators: usize,       // N1
    pub total_operands: usize,        // N2
    pub vocabulary: usize,            // n
    pub length: usize,                // N
    pub volume: f64,                  // V
    pub difficulty: f64,              // D
    pub effort: f64,                  // E
    pub time_to_program: f64,         // T
    pub bugs_delivered: f64,          // B
}

impl HalsteadMetrics {
    pub fn calculate(operators: &amp;HashSet&lt;String&gt;, operands: &amp;HashSet&lt;String&gt;,
                     op_count: usize, operand_count: usize) -&gt; Self {
        let n1 = operators.len();
        let n2 = operands.len();
        let n = n1 + n2;
        let N = op_count + operand_count;
        
        let volume = (N as f64) * (n as f64).log2();
        let difficulty = (n1 as f64 / 2.0) * (operand_count as f64 / n2 as f64);
        let effort = difficulty * volume;
        let time = effort / 18.0;
        let bugs = volume / 3000.0;
        
        HalsteadMetrics {
            distinct_operators: n1,
            distinct_operands: n2,
            total_operators: op_count,
            total_operands: operand_count,
            vocabulary: n,
            length: N,
            volume,
            difficulty,
            effort,
            time_to_program: time,
            bugs_delivered: bugs,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="metrics-collection-in-the-pipeline"><a class="header" href="#metrics-collection-in-the-pipeline">Metrics Collection in the Pipeline</a></h2>
<p><code>MetricsPass</code> is registered in the analyzer registry and runs during <code>Phase::LocalRules</code>. It enumerates classes/structs/methods via <code>Query</code> and uses helpers from <code>bsharp_analysis::metrics::shared</code> to compute statement counts, decision points (cyclomatic complexity), and nesting.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::context::AnalysisContext;
use bsharp_analysis::framework::pipeline::AnalyzerPipeline;
use bsharp_analysis::framework::session::AnalysisSession;
use bsharp_analysis::metrics::AstAnalysis;
use bsharp_parser::facade::Parser;

let source = r#"public class C { public void M() { if (true) { } } }"#;
let (cu, spans) = Parser::new().parse_with_spans(source)?;
let mut session = AnalysisSession::new(AnalysisContext::new("file.cs", source), spans);
AnalyzerPipeline::run_with_defaults(&amp;cu, &amp;mut session);
let ast = session.artifacts.get::&lt;AstAnalysis&gt;().expect("AstAnalysis");
println!("classes={}, methods={}, ifs={}", ast.total_classes, ast.total_methods, ast.total_if_statements);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="cli-usage-2"><a class="header" href="#cli-usage-2">CLI Usage</a></h2>
<h3 id="analyze-metrics"><a class="header" href="#analyze-metrics">Analyze Metrics</a></h3>
<pre><code class="language-bash"># Analyze single file
bsharp analyze MyFile.cs

# Analyze project
bsharp analyze MyProject.csproj --out metrics.json

# Analyze solution
bsharp analyze MySolution.sln --out metrics.json --format pretty-json
</code></pre>
<h3 id="example-output"><a class="header" href="#example-output">Example Output</a></h3>
<pre><code class="language-json">{
  "schema_version": 1,
  "metrics": {
    "total_lines": 1250,
    "code_lines": 980,
    "comment_lines": 150,
    "blank_lines": 120,
    "class_count": 15,
    "method_count": 87,
    "total_complexity": 245,
    "max_complexity": 18,
    "max_nesting_depth": 5
  }
}
</code></pre>
<hr />
<h2 id="thresholds-and-warnings"><a class="header" href="#thresholds-and-warnings">Thresholds and Warnings</a></h2>
<h3 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h3>
<pre><code class="language-toml">[analysis.metrics]
max_cyclomatic_complexity = 10
max_cognitive_complexity = 15
max_nesting_depth = 4
max_method_length = 50
min_maintainability_index = 65
</code></pre>
<h3 id="diagnostics-1"><a class="header" href="#diagnostics-1">Diagnostics</a></h3>
<p><strong>High Complexity Warning:</strong></p>
<pre><code>warning[MET001]: Method has high cyclomatic complexity
  --&gt; src/OrderProcessor.cs:42:17
   |
42 |     public void ProcessOrder(Order order) {
   |                 ^^^^^^^^^^^^ complexity = 18 (threshold: 10)
   |
   = help: Consider breaking this method into smaller methods
</code></pre>
<p><strong>Deep Nesting Warning:</strong></p>
<pre><code>warning[MET002]: Deep nesting detected
  --&gt; src/Validator.cs:15:9
   |
15 |         if (condition1) {
   |         ^^ nesting depth = 5 (threshold: 4)
   |
   = help: Consider extracting nested logic into separate methods
</code></pre>
<hr />
<h2 id="programmatic-usage-1"><a class="header" href="#programmatic-usage-1">Programmatic Usage</a></h2>
<h3 id="analyzing-a-method"><a class="header" href="#analyzing-a-method">Analyzing a Method</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::metrics::{cyclomatic_complexity, cognitive_complexity, max_nesting_depth};

let method = parse_method("public void MyMethod() { ... }");

let cc = cyclomatic_complexity(&amp;method);
let cog = cognitive_complexity(&amp;method);
let nesting = max_nesting_depth(&amp;method);

println!("Cyclomatic Complexity: {}", cc);
println!("Cognitive Complexity: {}", cog);
println!("Max Nesting Depth: {}", nesting);
<span class="boring">}</span></code></pre></pre>
<h3 id="analyzing-a-file-via-the-pipeline"><a class="header" href="#analyzing-a-file-via-the-pipeline">Analyzing a file via the pipeline</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (cu, spans) = Parser::new().parse_with_spans(source_code)?;
let mut session = AnalysisSession::new(AnalysisContext::new("file.cs", source_code), spans);
AnalyzerPipeline::run_with_defaults(&amp;cu, &amp;mut session);
let metrics = session.artifacts.get::&lt;AstAnalysis&gt;().expect("AstAnalysis");
println!("Classes: {}", metrics.total_classes);
println!("Methods: {}", metrics.total_methods);
println!("Cyclomatic Complexity: {}", metrics.cyclomatic_complexity);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="related-documentation-2"><a class="header" href="#related-documentation-2">Related Documentation</a></h2>
<ul>
<li><a href="analysis/./pipeline.html">Analysis Pipeline</a> - How metrics fit in the pipeline</li>
<li><a href="analysis/./control-flow.html">Control Flow Analysis</a> - Related complexity analysis</li>
<li><a href="analysis/./quality.html">Code Quality</a> - Quality assessment using metrics</li>
<li><a href="analysis/../development/architecture.html">Architecture</a> - Design decisions</li>
</ul>
<hr />
<h2 id="references-4"><a class="header" href="#references-4">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/bsharp_analysis/src/metrics/</code></li>
<li><strong>Pass:</strong> <code>src/bsharp_analysis/src/passes/metrics.rs</code></li>
<li><strong>Tests:</strong> <code>src/bsharp_tests/src/analysis/metrics/</code> (planned)</li>
<li><strong>Standards:</strong> ISO/IEC 25023 (Software Quality Metrics)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-analysis-1"><a class="header" href="#type-analysis-1">Type Analysis</a></h1>
<p>The type analysis system provides insights into type usage, inheritance hierarchies, and type-related patterns in C# code.</p>
<hr />
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p><strong>Status:</strong> Planned (module not implemented yet)</p>
<p>Type analysis tracks:</p>
<ul>
<li>Type definitions and their relationships</li>
<li>Inheritance hierarchies</li>
<li>Interface implementations</li>
<li>Generic type usage</li>
<li>Type references and dependencies</li>
</ul>
<hr />
<h2 id="type-information"><a class="header" href="#type-information">Type Information</a></h2>
<h3 id="type-categories-1"><a class="header" href="#type-categories-1">Type Categories</a></h3>
<p><strong>Value Types:</strong></p>
<ul>
<li>Primitives (<code>int</code>, <code>bool</code>, <code>double</code>, etc.)</li>
<li>Structs</li>
<li>Enums</li>
</ul>
<p><strong>Reference Types:</strong></p>
<ul>
<li>Classes</li>
<li>Interfaces</li>
<li>Delegates</li>
<li>Arrays</li>
</ul>
<p><strong>Special Types:</strong></p>
<ul>
<li>Generic type parameters</li>
<li>Nullable types</li>
<li>Tuple types</li>
<li>Anonymous types</li>
</ul>
<hr />
<h2 id="inheritance-analysis"><a class="header" href="#inheritance-analysis">Inheritance Analysis</a></h2>
<h3 id="class-hierarchies"><a class="header" href="#class-hierarchies">Class Hierarchies</a></h3>
<p><strong>Tracking Inheritance:</strong></p>
<pre><code class="language-csharp">public class Animal { }
public class Mammal : Animal { }
public class Dog : Mammal { }
</code></pre>
<p><strong>Hierarchy Representation:</strong></p>
<pre><code>Animal
└── Mammal
    └── Dog
</code></pre>
<p><strong>Analysis:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InheritanceHierarchy {
    // Type -&gt; Base Type
    base_types: HashMap&lt;TypeId, TypeId&gt;,
    // Type -&gt; Derived Types
    derived_types: HashMap&lt;TypeId, Vec&lt;TypeId&gt;&gt;,
}

impl InheritanceHierarchy {
    pub fn get_base_type(&amp;self, type_id: TypeId) -&gt; Option&lt;TypeId&gt;;
    pub fn get_derived_types(&amp;self, type_id: TypeId) -&gt; &amp;[TypeId];
    pub fn get_all_ancestors(&amp;self, type_id: TypeId) -&gt; Vec&lt;TypeId&gt;;
    pub fn get_all_descendants(&amp;self, type_id: TypeId) -&gt; Vec&lt;TypeId&gt;;
    pub fn inheritance_depth(&amp;self, type_id: TypeId) -&gt; usize;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="interface-implementation"><a class="header" href="#interface-implementation">Interface Implementation</a></h3>
<p><strong>Tracking Implementations:</strong></p>
<pre><code class="language-csharp">public interface IRepository { }
public interface IUserRepository : IRepository { }
public class UserRepository : IUserRepository { }
</code></pre>
<p><strong>Analysis:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InterfaceImplementations {
    // Type -&gt; Interfaces it implements
    implementations: HashMap&lt;TypeId, Vec&lt;TypeId&gt;&gt;,
    // Interface -&gt; Types that implement it
    implementers: HashMap&lt;TypeId, Vec&lt;TypeId&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="generic-type-analysis"><a class="header" href="#generic-type-analysis">Generic Type Analysis</a></h2>
<h3 id="type-parameters-1"><a class="header" href="#type-parameters-1">Type Parameters</a></h3>
<p><strong>Tracking Generic Definitions:</strong></p>
<pre><code class="language-csharp">public class Container&lt;T&gt; where T : class { }
public class Repository&lt;TEntity, TKey&gt; where TEntity : class { }
</code></pre>
<p><strong>Analysis:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GenericTypeInfo {
    pub type_parameters: Vec&lt;TypeParameter&gt;,
    pub constraints: Vec&lt;TypeConstraint&gt;,
}

pub struct TypeParameter {
    pub name: String,
    pub variance: Option&lt;Variance&gt;,  // in, out
}

pub struct TypeConstraint {
    pub parameter: String,
    pub kind: ConstraintKind,
}

pub enum ConstraintKind {
    Class,              // where T : class
    Struct,             // where T : struct
    New,                // where T : new()
    BaseType(TypeId),   // where T : BaseClass
    Interface(TypeId),  // where T : IInterface
}
<span class="boring">}</span></code></pre></pre>
<h3 id="generic-type-usage"><a class="header" href="#generic-type-usage">Generic Type Usage</a></h3>
<p><strong>Tracking Instantiations:</strong></p>
<pre><code class="language-csharp">var list = new List&lt;int&gt;();
var dict = new Dictionary&lt;string, User&gt;();
</code></pre>
<p><strong>Analysis:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GenericInstantiation {
    pub generic_type: TypeId,
    pub type_arguments: Vec&lt;TypeId&gt;,
}

pub fn find_generic_instantiations(cu: &amp;CompilationUnit) -&gt; Vec&lt;GenericInstantiation&gt;;
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="type-usage-patterns"><a class="header" href="#type-usage-patterns">Type Usage Patterns</a></h2>
<h3 id="frequency-analysis"><a class="header" href="#frequency-analysis">Frequency Analysis</a></h3>
<p><strong>Most Used Types:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TypeUsageStats {
    pub type_references: HashMap&lt;TypeId, usize&gt;,
}

impl TypeUsageStats {
    pub fn most_used_types(&amp;self, limit: usize) -&gt; Vec&lt;(TypeId, usize)&gt;;
    pub fn usage_count(&amp;self, type_id: TypeId) -&gt; usize;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="type-categories-distribution"><a class="header" href="#type-categories-distribution">Type Categories Distribution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TypeDistribution {
    pub class_count: usize,
    pub interface_count: usize,
    pub struct_count: usize,
    pub enum_count: usize,
    pub delegate_count: usize,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="type-metrics"><a class="header" href="#type-metrics">Type Metrics</a></h2>
<h3 id="depth-of-inheritance-tree-dit"><a class="header" href="#depth-of-inheritance-tree-dit">Depth of Inheritance Tree (DIT)</a></h3>
<p><strong>Definition:</strong> Maximum depth from type to root of hierarchy</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">class A { }              // DIT = 0 (or 1 from Object)
class B : A { }          // DIT = 1 (or 2 from Object)
class C : B { }          // DIT = 2 (or 3 from Object)
</code></pre>
<p><strong>Interpretation:</strong></p>
<ul>
<li><strong>Low DIT (0-2):</strong> Simple hierarchy, easy to understand</li>
<li><strong>Medium DIT (3-4):</strong> Moderate complexity</li>
<li><strong>High DIT (5+):</strong> Complex hierarchy, may indicate over-engineering</li>
</ul>
<h3 id="number-of-children-noc"><a class="header" href="#number-of-children-noc">Number of Children (NOC)</a></h3>
<p><strong>Definition:</strong> Number of immediate subclasses</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">class Animal { }
class Dog : Animal { }
class Cat : Animal { }
class Bird : Animal { }
// Animal has NOC = 3
</code></pre>
<p><strong>Interpretation:</strong></p>
<ul>
<li><strong>High NOC:</strong> Type is heavily reused (good abstraction or god class)</li>
<li><strong>Low NOC:</strong> Specialized type or leaf in hierarchy</li>
</ul>
<h3 id="lack-of-cohesion-of-methods-lcom"><a class="header" href="#lack-of-cohesion-of-methods-lcom">Lack of Cohesion of Methods (LCOM)</a></h3>
<p><strong>Definition:</strong> Measure of how well methods in a class are related</p>
<p><strong>Simplified Calculation:</strong></p>
<ul>
<li>Count pairs of methods that don't share instance variables</li>
<li>High LCOM suggests class should be split</li>
</ul>
<hr />
<h2 id="type-compatibility-analysis"><a class="header" href="#type-compatibility-analysis">Type Compatibility Analysis</a></h2>
<h3 id="assignability"><a class="header" href="#assignability">Assignability</a></h3>
<p><strong>Checking Compatibility:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is_assignable_to(from: &amp;Type, to: &amp;Type, context: &amp;TypeContext) -&gt; bool {
    // Check if 'from' type can be assigned to 'to' type
    // Considers inheritance, interface implementation, variance, etc.
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Rules:</strong></p>
<ul>
<li>Derived type assignable to base type</li>
<li>Type assignable to implemented interface</li>
<li>Covariant/contravariant generic types</li>
<li>Nullable value types</li>
<li>Implicit conversions</li>
</ul>
<h3 id="type-conversions"><a class="header" href="#type-conversions">Type Conversions</a></h3>
<p><strong>Tracking Conversions:</strong></p>
<pre><code class="language-csharp">int x = 42;
long y = x;              // Implicit conversion
string s = x.ToString(); // Explicit conversion
</code></pre>
<p><strong>Analysis:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ConversionKind {
    Implicit,
    Explicit,
    UserDefined,
}

pub struct TypeConversion {
    pub from: TypeId,
    pub to: TypeId,
    pub kind: ConversionKind,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="nullable-reference-types-analysis"><a class="header" href="#nullable-reference-types-analysis">Nullable Reference Types Analysis</a></h2>
<h3 id="nullability-tracking"><a class="header" href="#nullability-tracking">Nullability Tracking</a></h3>
<p><strong>C# 8+ Nullable Annotations:</strong></p>
<pre><code class="language-csharp">string? nullable = null;      // Nullable reference
string nonNull = "value";     // Non-nullable reference
</code></pre>
<p><strong>Analysis:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NullabilityInfo {
    pub is_nullable: bool,
    pub nullability_context: NullabilityContext,
}

pub enum NullabilityContext {
    Enabled,
    Disabled,
    Warnings,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="null-safety-diagnostics"><a class="header" href="#null-safety-diagnostics">Null Safety Diagnostics</a></h3>
<p><strong>Potential Null Reference:</strong></p>
<pre><code>warning[TYPE001]: Possible null reference
  --&gt; src/UserService.cs:15:9
   |
15 |     user.Name = "John";
   |     ^^^^ 'user' may be null here
   |
   = help: Add null check or use null-conditional operator
</code></pre>
<hr />
<h2 id="type-analysis-in-pipeline"><a class="header" href="#type-analysis-in-pipeline">Type Analysis in Pipeline</a></h2>
<h3 id="integration"><a class="header" href="#integration">Integration</a></h3>
<p>Type analysis is not part of the default registry yet. The intended phase is Semantic (after symbol indexing and global artifacts). This page outlines the planned scope.</p>
<hr />
<h2 id="programmatic-usage-2"><a class="header" href="#programmatic-usage-2">Programmatic Usage</a></h2>
<h3 id="analyzing-type-hierarchy"><a class="header" href="#analyzing-type-hierarchy">Analyzing Type Hierarchy</a></h3>
<p>Planned APIs will expose hierarchy queries once implemented.</p>
<h3 id="finding-generic-instantiations"><a class="header" href="#finding-generic-instantiations">Finding Generic Instantiations</a></h3>
<p>Planned helper(s) to enumerate generic instantiations will be documented here after implementation.</p>
<hr />
<h2 id="future-enhancements-1"><a class="header" href="#future-enhancements-1">Future Enhancements</a></h2>
<h3 id="planned-features-1"><a class="header" href="#planned-features-1">Planned Features</a></h3>
<ol>
<li>
<p><strong>Type Inference Tracking</strong></p>
<ul>
<li>Track <code>var</code> usage and inferred types</li>
<li>Analyze type inference patterns</li>
</ul>
</li>
<li>
<p><strong>Variance Analysis</strong></p>
<ul>
<li>Detect variance violations</li>
<li>Suggest covariant/contravariant annotations</li>
</ul>
</li>
<li>
<p><strong>Type Safety Metrics</strong></p>
<ul>
<li>Measure use of <code>dynamic</code></li>
<li>Track unsafe casts</li>
<li>Nullable reference type coverage</li>
</ul>
</li>
<li>
<p><strong>Design Pattern Detection</strong></p>
<ul>
<li>Identify common patterns (Factory, Strategy, etc.)</li>
<li>Detect anti-patterns</li>
</ul>
</li>
</ol>
<hr />
<h2 id="implementation-status-1"><a class="header" href="#implementation-status-1">Implementation Status</a></h2>
<p><strong>Current State:</strong></p>
<ul>
<li>Basic type tracking infrastructure in place</li>
<li>Type analysis module integrated with analysis framework</li>
<li>Foundation for inheritance and generic analysis established</li>
</ul>
<p><strong>In Progress:</strong></p>
<ul>
<li>Full inheritance hierarchy analysis</li>
<li>Generic type instantiation tracking</li>
<li>Type usage statistics collection</li>
<li>Comprehensive test coverage</li>
</ul>
<p><strong>Planned:</strong></p>
<ul>
<li>Variance analysis</li>
<li>Type safety metrics</li>
<li>Design pattern detection based on type relationships</li>
</ul>
<hr />
<h2 id="related-documentation-3"><a class="header" href="#related-documentation-3">Related Documentation</a></h2>
<ul>
<li><a href="analysis/./pipeline.html">Analysis Pipeline</a> - Pipeline integration</li>
<li><a href="analysis/./dependencies.html">Dependency Analysis</a> - Type dependencies</li>
<li><a href="analysis/./metrics.html">Metrics Collection</a> - Type-related metrics</li>
<li><a href="analysis/../parser/ast-structure.html">AST Structure</a> - Type representations</li>
</ul>
<hr />
<h2 id="references-5"><a class="header" href="#references-5">References</a></h2>
<ul>
<li><strong>Implementation:</strong> Planned</li>
<li><strong>Tests:</strong> Planned (under <code>src/bsharp_tests/src/analysis/types/</code>)</li>
<li><strong>Related:</strong> <code>docs/analysis/dependencies.md</code>, <code>docs/parser/ast-structure.md</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-quality-analysis-conceptual--future-plan"><a class="header" href="#code-quality-analysis-conceptual--future-plan">Code Quality Analysis (Conceptual / Future Plan)</a></h1>
<p>This document describes a future-facing design for quality analysis. The legacy <code>quality</code> module and <code>QualityPass</code> were removed from the codebase in the purge. Consider this document a proposal/reference for potential future work rather than current implementation.</p>
<hr />
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p><strong>Status:</strong> Not implemented. The legacy module was removed; this page documents future direction.</p>
<p>Quality analysis provides:</p>
<ul>
<li>Code smell detection</li>
<li>Best practice validation</li>
<li>Design pattern recognition</li>
<li>Maintainability assessment</li>
<li>Technical debt identification</li>
</ul>
<hr />
<h2 id="code-smells"><a class="header" href="#code-smells">Code Smells</a></h2>
<h3 id="method-level-smells"><a class="header" href="#method-level-smells">Method-Level Smells</a></h3>
<h4 id="long-method"><a class="header" href="#long-method">Long Method</a></h4>
<p><strong>Description:</strong> Method with too many lines of code</p>
<p><strong>Threshold:</strong> &gt; 50 lines (configurable)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void ProcessOrder(Order order) {
    // 150 lines of code...
}
</code></pre>
<p><strong>Diagnostic:</strong></p>
<pre><code>warning[QUAL001]: Long method detected
  --&gt; src/OrderService.cs:42:17
   |
42 |     public void ProcessOrder(Order order) {
   |                 ^^^^^^^^^^^^ method has 150 lines (threshold: 50)
   |
   = help: Consider breaking this method into smaller, focused methods
</code></pre>
<p><strong>Refactoring:</strong></p>
<ul>
<li>Extract method</li>
<li>Decompose into smaller methods</li>
<li>Apply Single Responsibility Principle</li>
</ul>
<h4 id="long-parameter-list"><a class="header" href="#long-parameter-list">Long Parameter List</a></h4>
<p><strong>Description:</strong> Method with too many parameters</p>
<p><strong>Threshold:</strong> &gt; 5 parameters (configurable)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void CreateUser(string firstName, string lastName, string email, 
                      string phone, string address, string city, string zip) {
    // ...
}
</code></pre>
<p><strong>Refactoring:</strong></p>
<ul>
<li>Introduce parameter object</li>
<li>Use builder pattern</li>
<li>Group related parameters into DTOs</li>
</ul>
<h4 id="complex-conditional"><a class="header" href="#complex-conditional">Complex Conditional</a></h4>
<p><strong>Description:</strong> Deeply nested or complex conditional logic</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">if (user != null &amp;&amp; user.IsActive &amp;&amp; (user.Role == "Admin" || user.Role == "Manager") 
    &amp;&amp; user.Department != null &amp;&amp; user.Department.Budget &gt; 10000) {
    // ...
}
</code></pre>
<p><strong>Refactoring:</strong></p>
<ul>
<li>Extract condition to well-named method</li>
<li>Use guard clauses</li>
<li>Simplify boolean logic</li>
</ul>
<h3 id="class-level-smells"><a class="header" href="#class-level-smells">Class-Level Smells</a></h3>
<h4 id="large-class-god-class"><a class="header" href="#large-class-god-class">Large Class (God Class)</a></h4>
<p><strong>Description:</strong> Class with too many responsibilities</p>
<p><strong>Indicators:</strong></p>
<ul>
<li>Too many methods (&gt; 20)</li>
<li>Too many fields (&gt; 10)</li>
<li>High cyclomatic complexity</li>
<li>Low cohesion</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public class UserManager {
    // 50 methods handling user CRUD, authentication, authorization,
    // email sending, logging, caching, validation, etc.
}
</code></pre>
<p><strong>Refactoring:</strong></p>
<ul>
<li>Split into multiple classes</li>
<li>Apply Single Responsibility Principle</li>
<li>Extract related functionality</li>
</ul>
<h4 id="feature-envy"><a class="header" href="#feature-envy">Feature Envy</a></h4>
<p><strong>Description:</strong> Method uses more features of another class than its own</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public class OrderProcessor {
    public decimal CalculateTotal(Order order) {
        decimal total = 0;
        foreach (var item in order.Items) {
            total += item.Price * item.Quantity;
        }
        total -= order.Discount;
        total += order.Tax;
        return total;
    }
}
</code></pre>
<p><strong>Refactoring:</strong></p>
<ul>
<li>Move method to <code>Order</code> class</li>
<li>Method should be where the data is</li>
</ul>
<h4 id="data-class"><a class="header" href="#data-class">Data Class</a></h4>
<p><strong>Description:</strong> Class with only fields and getters/setters, no behavior</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public class User {
    public string Name { get; set; }
    public string Email { get; set; }
    public int Age { get; set; }
    // No methods, just data
}
</code></pre>
<p><strong>Note:</strong> Sometimes acceptable for DTOs, but domain objects should have behavior</p>
<h3 id="code-organization-smells"><a class="header" href="#code-organization-smells">Code Organization Smells</a></h3>
<h4 id="duplicate-code"><a class="header" href="#duplicate-code">Duplicate Code</a></h4>
<p><strong>Description:</strong> Identical or very similar code in multiple places</p>
<p><strong>Detection:</strong></p>
<ul>
<li>Token-based comparison</li>
<li>AST structure comparison</li>
<li>Minimum clone size threshold</li>
</ul>
<p><strong>Refactoring:</strong></p>
<ul>
<li>Extract method</li>
<li>Extract class</li>
<li>Use inheritance or composition</li>
</ul>
<h4 id="dead-code"><a class="header" href="#dead-code">Dead Code</a></h4>
<p><strong>Description:</strong> Code that is never executed</p>
<p><strong>Examples:</strong></p>
<ul>
<li>Unreachable statements after <code>return</code></li>
<li>Unused private methods</li>
<li>Unused fields</li>
<li>Conditions that are always true/false</li>
</ul>
<p><strong>Diagnostic:</strong></p>
<pre><code>warning[QUAL010]: Unreachable code detected
  --&gt; src/Calculator.cs:15:9
   |
14 |     return result;
15 |     Console.WriteLine("Done");  // Never executed
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement
</code></pre>
<h4 id="magic-numbers"><a class="header" href="#magic-numbers">Magic Numbers</a></h4>
<p><strong>Description:</strong> Unexplained numeric literals in code</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">if (order.Total &gt; 1000) {  // What does 1000 mean?
    ApplyDiscount(order, 0.1);  // What does 0.1 mean?
}
</code></pre>
<p><strong>Refactoring:</strong></p>
<pre><code class="language-csharp">const decimal BULK_ORDER_THRESHOLD = 1000m;
const decimal BULK_ORDER_DISCOUNT = 0.1m;

if (order.Total &gt; BULK_ORDER_THRESHOLD) {
    ApplyDiscount(order, BULK_ORDER_DISCOUNT);
}
</code></pre>
<hr />
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h3>
<p><strong>Rules:</strong></p>
<ul>
<li>Classes: PascalCase</li>
<li>Methods: PascalCase</li>
<li>Properties: PascalCase</li>
<li>Fields: camelCase with <code>_</code> prefix for private</li>
<li>Constants: UPPER_CASE or PascalCase</li>
<li>Interfaces: PascalCase with <code>I</code> prefix</li>
</ul>
<p><strong>Violations:</strong></p>
<pre><code>warning[QUAL020]: Naming convention violation
  --&gt; src/UserService.cs:5:17
   |
 5 |     private int UserCount;
   |                 ^^^^^^^^^ private field should use camelCase with _ prefix
   |
   = help: Rename to '_userCount'
</code></pre>
<h3 id="exception-handling"><a class="header" href="#exception-handling">Exception Handling</a></h3>
<p><strong>Anti-patterns:</strong></p>
<p><strong>Empty Catch Block:</strong></p>
<pre><code class="language-csharp">try {
    RiskyOperation();
} catch (Exception) {
    // Silent failure - BAD!
}
</code></pre>
<p><strong>Catching Generic Exception:</strong></p>
<pre><code class="language-csharp">try {
    SpecificOperation();
} catch (Exception ex) {  // Too broad
    // ...
}
</code></pre>
<p><strong>Best Practices:</strong></p>
<ul>
<li>Catch specific exceptions</li>
<li>Log exceptions</li>
<li>Don't swallow exceptions</li>
<li>Use <code>finally</code> for cleanup</li>
</ul>
<h3 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h3>
<p><strong>Using Statement:</strong></p>
<pre><code class="language-csharp">// Good
using (var file = File.OpenRead("data.txt")) {
    // Use file
}

// Better (C# 8+)
using var file = File.OpenRead("data.txt");
// Disposed at end of scope
</code></pre>
<p><strong>Diagnostic:</strong></p>
<pre><code>warning[QUAL030]: IDisposable not properly disposed
  --&gt; src/FileProcessor.cs:10:9
   |
10 |     var file = File.OpenRead("data.txt");
   |         ^^^^ should be wrapped in using statement
</code></pre>
<hr />
<h2 id="design-patterns-and-anti-patterns"><a class="header" href="#design-patterns-and-anti-patterns">Design Patterns and Anti-Patterns</a></h2>
<h3 id="detected-patterns"><a class="header" href="#detected-patterns">Detected Patterns</a></h3>
<h4 id="singleton-pattern"><a class="header" href="#singleton-pattern">Singleton Pattern</a></h4>
<p><strong>Detection:</strong></p>
<ul>
<li>Private constructor</li>
<li>Static instance field</li>
<li>Public static accessor</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public class Logger {
    private static Logger _instance;
    private Logger() { }
    
    public static Logger Instance {
        get {
            if (_instance == null) {
                _instance = new Logger();
            }
            return _instance;
        }
    }
}
</code></pre>
<h4 id="factory-pattern"><a class="header" href="#factory-pattern">Factory Pattern</a></h4>
<p><strong>Detection:</strong></p>
<ul>
<li>Method returning interface or base class</li>
<li>Creates different concrete types based on parameters</li>
</ul>
<h3 id="anti-patterns"><a class="header" href="#anti-patterns">Anti-Patterns</a></h3>
<h4 id="god-object"><a class="header" href="#god-object">God Object</a></h4>
<p><strong>Detection:</strong></p>
<ul>
<li>High number of methods and fields</li>
<li>Low cohesion</li>
<li>High coupling</li>
</ul>
<h4 id="spaghetti-code"><a class="header" href="#spaghetti-code">Spaghetti Code</a></h4>
<p><strong>Detection:</strong></p>
<ul>
<li>High cyclomatic complexity</li>
<li>Deep nesting</li>
<li>Lack of structure</li>
</ul>
<h4 id="lava-flow"><a class="header" href="#lava-flow">Lava Flow</a></h4>
<p><strong>Detection:</strong></p>
<ul>
<li>Dead code</li>
<li>Commented-out code</li>
<li>Unused variables/methods</li>
</ul>
<hr />
<h2 id="quality-metrics"><a class="header" href="#quality-metrics">Quality Metrics</a></h2>
<h3 id="code-quality-score"><a class="header" href="#code-quality-score">Code Quality Score</a></h3>
<p><strong>Composite Score (0-100):</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct QualityScore {
    pub overall: f64,
    pub maintainability: f64,
    pub complexity: f64,
    pub duplication: f64,
    pub test_coverage: f64,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Calculation:</strong></p>
<pre><code>Overall = (Maintainability * 0.3) + 
          (Complexity * 0.3) + 
          (Duplication * 0.2) + 
          (TestCoverage * 0.2)
</code></pre>
<h3 id="technical-debt"><a class="header" href="#technical-debt">Technical Debt</a></h3>
<p><strong>Estimation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TechnicalDebt {
    pub total_issues: usize,
    pub estimated_hours: f64,
    pub debt_ratio: f64,  // debt / total development time
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Calculation:</strong></p>
<ul>
<li>Each code smell assigned time cost</li>
<li>Sum all issues</li>
<li>Compare to total codebase size</li>
</ul>
<hr />
<h2 id="quality-rules"><a class="header" href="#quality-rules">Quality Rules</a></h2>
<h3 id="rule-system"><a class="header" href="#rule-system">Rule System</a></h3>
<p><strong>Rule Definition:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait QualityRule {
    fn id(&amp;self) -&gt; &amp;'static str;
    fn name(&amp;self) -&gt; &amp;'static str;
    fn description(&amp;self) -&gt; &amp;'static str;
    fn check(&amp;self, node: &amp;NodeRef, session: &amp;mut AnalysisSession);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Example Rule:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LongMethodRule {
    max_lines: usize,
}

impl QualityRule for LongMethodRule {
    fn id(&amp;self) -&gt; &amp;'static str { "long_method" }
    fn name(&amp;self) -&gt; &amp;'static str { "Long Method" }
    
    fn check(&amp;self, node: &amp;NodeRef, session: &amp;mut AnalysisSession) {
        if let NodeRef::MethodDeclaration(method) = node {
            let line_count = count_lines(method);
            if line_count &gt; self.max_lines {
                session.diagnostics.add(
                    DiagnosticCode::LongMethod,
                    format!("Method has {} lines (threshold: {})", 
                           line_count, self.max_lines)
                );
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="rule-categories"><a class="header" href="#rule-categories">Rule Categories</a></h3>
<p><strong>Maintainability Rules:</strong></p>
<ul>
<li>Long method</li>
<li>Long parameter list</li>
<li>Large class</li>
<li>Complex method</li>
</ul>
<p><strong>Reliability Rules:</strong></p>
<ul>
<li>Empty catch blocks</li>
<li>Null reference risks</li>
<li>Resource leaks</li>
<li>Unhandled exceptions</li>
</ul>
<p><strong>Security Rules:</strong></p>
<ul>
<li>SQL injection risks</li>
<li>XSS vulnerabilities</li>
<li>Hardcoded credentials</li>
<li>Insecure random</li>
</ul>
<p><strong>Performance Rules:</strong></p>
<ul>
<li>Inefficient loops</li>
<li>Unnecessary allocations</li>
<li>String concatenation in loops</li>
<li>Boxing/unboxing</li>
</ul>
<hr />
<h2 id="configuration-4"><a class="header" href="#configuration-4">Configuration</a></h2>
<h3 id="quality-thresholds"><a class="header" href="#quality-thresholds">Quality Thresholds</a></h3>
<pre><code class="language-toml">[analysis.quality]
max_method_lines = 50
max_parameters = 5
max_class_methods = 20
max_cyclomatic_complexity = 10
max_nesting_depth = 4

[analysis.quality.rules]
long_method = "warning"
long_parameter_list = "warning"
god_class = "error"
empty_catch = "error"
magic_numbers = "info"
</code></pre>
<h3 id="severity-levels"><a class="header" href="#severity-levels">Severity Levels</a></h3>
<ul>
<li><strong>Error:</strong> Must be fixed</li>
<li><strong>Warning:</strong> Should be fixed</li>
<li><strong>Info:</strong> Consider fixing</li>
<li><strong>Hint:</strong> Suggestion for improvement</li>
</ul>
<hr />
<h2 id="cli-usage-3"><a class="header" href="#cli-usage-3">CLI Usage</a></h2>
<h3 id="quality-analysis"><a class="header" href="#quality-analysis">Quality Analysis</a></h3>
<pre><code class="language-bash"># Analyze code quality
bsharp analyze MyProject.csproj --enable-ruleset quality

# Generate quality report
bsharp analyze MySolution.sln --out quality-report.json

# Filter by severity
bsharp analyze MyFile.cs --severity error,warning
</code></pre>
<h3 id="example-output-1"><a class="header" href="#example-output-1">Example Output</a></h3>
<pre><code class="language-json">{
  "quality_score": {
    "overall": 72.5,
    "maintainability": 68.0,
    "complexity": 75.0,
    "duplication": 80.0
  },
  "technical_debt": {
    "total_issues": 45,
    "estimated_hours": 12.5,
    "debt_ratio": 0.08
  },
  "diagnostics": [
    {
      "code": "QUAL001",
      "severity": "warning",
      "message": "Long method detected",
      "file": "src/OrderService.cs",
      "line": 42,
      "column": 17
    }
  ]
}
</code></pre>
<hr />
<h2 id="integration-with-pipeline-1"><a class="header" href="#integration-with-pipeline-1">Integration with Pipeline</a></h2>
<h3 id="quality-ruleset"><a class="header" href="#quality-ruleset">Quality Ruleset</a></h3>
<p><strong>Registration:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In AnalyzerRegistry
registry.add_ruleset(QualityRuleset {
    id: "quality",
    rules: vec![
        Box::new(LongMethodRule::new()),
        Box::new(LongParameterListRule::new()),
        Box::new(GodClassRule::new()),
        Box::new(EmptyCatchRule::new()),
        // ... more rules
    ],
});
<span class="boring">}</span></code></pre></pre>
<p><strong>Execution:</strong></p>
<ul>
<li>Rules run during Local or Semantic phase</li>
<li>Visitor pattern for AST traversal</li>
<li>Diagnostics collected in session</li>
</ul>
<hr />
<h2 id="programmatic-usage-3"><a class="header" href="#programmatic-usage-3">Programmatic Usage</a></h2>
<h3 id="running-quality-analysis"><a class="header" href="#running-quality-analysis">Running Quality Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::quality::QualityAnalyzer;

let parser = Parser::new();
let cu = parser.parse(source_code)?;

let analyzer = QualityAnalyzer::new();
let report = analyzer.analyze(&amp;cu);

println!("Quality Score: {}", report.quality_score.overall);
println!("Issues Found: {}", report.diagnostics.len());
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-rules-1"><a class="header" href="#custom-rules-1">Custom Rules</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::quality::QualityRule;

struct CustomRule;

impl QualityRule for CustomRule {
    fn id(&amp;self) -&gt; &amp;'static str { "custom_rule" }
    fn name(&amp;self) -&gt; &amp;'static str { "Custom Rule" }
    
    fn check(&amp;self, node: &amp;NodeRef, session: &amp;mut AnalysisSession) {
        // Custom logic
    }
}

// Register custom rule
analyzer.add_rule(Box::new(CustomRule));
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="future-enhancements-2"><a class="header" href="#future-enhancements-2">Future Enhancements</a></h2>
<h3 id="planned-features-2"><a class="header" href="#planned-features-2">Planned Features</a></h3>
<ol>
<li>
<p><strong>Machine Learning-Based Detection</strong></p>
<ul>
<li>Learn from codebase patterns</li>
<li>Detect project-specific smells</li>
</ul>
</li>
<li>
<p><strong>Refactoring Suggestions</strong></p>
<ul>
<li>Automated refactoring proposals</li>
<li>Preview refactoring impact</li>
</ul>
</li>
<li>
<p><strong>Quality Trends</strong></p>
<ul>
<li>Track quality over time</li>
<li>Identify degradation</li>
<li>Measure improvement</li>
</ul>
</li>
<li>
<p><strong>Team Metrics</strong></p>
<ul>
<li>Per-developer quality metrics</li>
<li>Code review insights</li>
<li>Best practice adoption</li>
</ul>
</li>
</ol>
<hr />
<h2 id="related-documentation-4"><a class="header" href="#related-documentation-4">Related Documentation</a></h2>
<ul>
<li><a href="analysis/./pipeline.html">Analysis Pipeline</a> - Pipeline integration</li>
<li><a href="analysis/./metrics.html">Metrics Collection</a> - Quality metrics</li>
<li><a href="analysis/./control-flow.html">Control Flow Analysis</a> - Complexity analysis</li>
<li><a href="analysis/../development/architecture.html">Architecture</a> - Design decisions</li>
</ul>
<hr />
<h2 id="references-6"><a class="header" href="#references-6">References</a></h2>
<ul>
<li><strong>Standards:</strong> Clean Code (Robert C. Martin), Refactoring (Martin Fowler)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="passes-and-rules-registry"><a class="header" href="#passes-and-rules-registry">Passes and Rules Registry</a></h1>
<p>This page summarizes the default analysis registry: which passes and rulesets are registered by default and when they run.</p>
<hr />
<h2 id="default-registry"><a class="header" href="#default-registry">Default Registry</a></h2>
<p>Source: <code>src/bsharp_analysis/src/framework/registry.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simplified summary based on default_registry()
- Pass: indexing::IndexingPass          // indexing/symbols
- Pass: pe_loader::PeLoaderPass         // external PE metadata (if available)
- Pass: metrics::MetricsPass            // local metrics (Query-based)
- Ruleset (local): rules::naming        // naming conventions
- Ruleset (local): rules::semantic      // baseline semantic checks (local)
- Pass: control_flow::ControlFlowPass   // control flow stats and diagnostics
- Pass: dependencies::DependenciesPass  // dependency graph &amp; summary
- Ruleset (semantic): control_flow_smells // consumes global artifacts
- Pass: reporting::ReportingPass        // consolidate artifacts into report
<span class="boring">}</span></code></pre></pre>
<p>Notes:</p>
<ul>
<li>Each pass declares its own <code>Phase</code> (<code>AnalyzerPass::phase()</code>), e.g. <code>MetricsPass</code> runs in <code>Phase::LocalRules</code>.</li>
<li>Semantic rulesets (e.g., <code>control_flow_smells</code>) run after global artifacts are produced.</li>
</ul>
<hr />
<h2 id="phases-1"><a class="header" href="#phases-1">Phases</a></h2>
<ul>
<li><strong>Index</strong>: Build indexes (symbols, FQNs) and load external metadata.</li>
<li><strong>LocalRules</strong>: Run per-file local analyses (e.g., metrics) and baseline rules.</li>
<li><strong>Global/Semantic</strong>: Build global artifacts (control flow, dependencies), then run semantic rules consuming them.</li>
<li><strong>Reporting</strong>: Finalize results into <code>AnalysisReport</code>.</li>
</ul>
<hr />
<h2 id="configuration-enablingdisabling"><a class="header" href="#configuration-enablingdisabling">Configuration: Enabling/Disabling</a></h2>
<p>Toggles are driven by <code>AnalysisConfig</code>:</p>
<ul>
<li>Passes: <code>enable_passes[pass_id] = true|false</code></li>
<li>Rulesets: <code>enable_rulesets[ruleset_id] = true|false</code></li>
<li>Severities: <code>rule_severities["CODE"] = Error|Warning|Info|Hint</code></li>
</ul>
<p>The CLI maps flags to these fields (see <code>docs/cli/analyze.md</code>).</p>
<hr />
<h2 id="ids"><a class="header" href="#ids">IDs</a></h2>
<ul>
<li>Pass IDs (<code>AnalyzerPass::id()</code>):
<ul>
<li><code>passes.indexing</code></li>
<li><code>passes.pe_loader</code></li>
<li><code>passes.metrics</code></li>
<li><code>passes.control_flow</code></li>
<li><code>passes.dependencies</code></li>
<li><code>passes.reporting</code></li>
</ul>
</li>
<li>Ruleset IDs depend on the ruleset constructors (e.g., <code>naming</code>, <code>semantic</code>, <code>control_flow_smells</code>).</li>
</ul>
<hr />
<h2 id="references-7"><a class="header" href="#references-7">References</a></h2>
<ul>
<li><code>src/bsharp_analysis/src/framework/registry.rs</code></li>
<li><code>src/bsharp_analysis/src/passes/*</code></li>
<li><code>src/bsharp_analysis/src/rules/*</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analysis-report-schema"><a class="header" href="#analysis-report-schema">Analysis Report Schema</a></h1>
<p>The <code>AnalysisReport</code> summarizes diagnostics and artifacts produced by the analysis pipeline.</p>
<hr />
<h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<p>Source: <code>src/bsharp_analysis/src/report/mod.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct CfgSummary {
    pub total_methods: usize,
    pub high_complexity_methods: usize,
    pub deep_nesting_methods: usize,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct AnalysisReport {
    pub schema_version: u32,
    pub diagnostics: DiagnosticCollection,
    pub metrics: Option&lt;AstAnalysis&gt;,
    pub cfg: Option&lt;CfgSummary&gt;,
    pub deps: Option&lt;DependencySummary&gt;,
    pub workspace_warnings: Vec&lt;String&gt;,
    pub workspace_errors: Vec&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="field-details"><a class="header" href="#field-details">Field Details</a></h2>
<ul>
<li><code>schema_version</code> – current schema version (1)</li>
<li><code>diagnostics</code> – all emitted diagnostics with codes, severities, locations</li>
<li><code>metrics</code> – aggregated <code>AstAnalysis</code> when <code>MetricsPass</code> runs</li>
<li><code>cfg</code> – summarized control flow stats when <code>ControlFlowPass</code> runs</li>
<li><code>deps</code> – dependency summary when <code>DependenciesPass</code> runs</li>
<li><code>workspace_warnings</code> – non-fatal workspace-level messages</li>
<li><code>workspace_errors</code> – reserved for future use</li>
</ul>
<hr />
<h2 id="example-pretty-json"><a class="header" href="#example-pretty-json">Example (pretty JSON)</a></h2>
<pre><code class="language-json">{
  "schema_version": 1,
  "diagnostics": {
    "diagnostics": [
      {
        "code": "CF002",
        "severity": "warning",
        "message": "High cyclomatic complexity",
        "file": "src/OrderProcessor.cs",
        "line": 42,
        "column": 17
      }
    ]
  },
  "metrics": {
    "total_classes": 15,
    "total_interfaces": 3,
    "total_structs": 2,
    "total_enums": 1,
    "total_records": 0,
    "total_delegates": 0,
    "total_methods": 87,
    "total_properties": 21,
    "total_fields": 12,
    "total_events": 0,
    "total_constructors": 15,
    "total_if_statements": 20,
    "total_for_loops": 5,
    "total_while_loops": 2,
    "total_switch_statements": 3,
    "total_try_statements": 1,
    "total_using_statements": 2,
    "cyclomatic_complexity": 245,
    "lines_of_code": 980,
    "max_nesting_depth": 5,
    "documented_methods": 0,
    "documented_classes": 0
  },
  "cfg": {
    "total_methods": 87,
    "high_complexity_methods": 5,
    "deep_nesting_methods": 3
  },
  "deps": {
    "nodes": 42,
    "edges": 120
  },
  "workspace_warnings": [],
  "workspace_errors": []
}
</code></pre>
<hr />
<h2 id="where-it-comes-from"><a class="header" href="#where-it-comes-from">Where It Comes From</a></h2>
<p><code>AnalysisReport::from_session(&amp;session)</code> collects:</p>
<ul>
<li><code>metrics</code> from <code>session.artifacts.get::&lt;AstAnalysis&gt;()</code></li>
<li><code>cfg</code> by summarizing the <code>ControlFlowIndex</code> artifact against thresholds</li>
<li><code>deps</code> by summarizing <code>DependencyGraph</code></li>
<li><code>diagnostics</code> copied from <code>session.diagnostics</code></li>
</ul>
<hr />
<h2 id="related"><a class="header" href="#related">Related</a></h2>
<ul>
<li><code>docs/cli/analyze.md</code> – CLI options and examples</li>
<li><code>docs/analysis/pipeline.md</code> – Where in the pipeline artifacts are produced</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-an-analyzer-pass"><a class="header" href="#writing-an-analyzer-pass">Writing an Analyzer Pass</a></h1>
<p>This guide shows how to create a new analysis pass by implementing <code>AnalyzerPass</code> and registering it in the analysis pipeline.</p>
<hr />
<h2 id="trait"><a class="header" href="#trait">Trait</a></h2>
<p>Source: <code>src/bsharp_analysis/src/framework/passes.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait AnalyzerPass: Send + Sync + 'static {
    fn id(&amp;self) -&gt; &amp;'static str;
    fn phase(&amp;self) -&gt; Phase;                 // Index | LocalRules | Global | Semantic | Reporting
    fn depends_on(&amp;self) -&gt; &amp;'static [&amp;'static str] { &amp;[] }
    fn run(&amp;self, cu: &amp;CompilationUnit, session: &amp;mut AnalysisSession) {}
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="minimal-pass"><a class="header" href="#minimal-pass">Minimal Pass</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::framework::{AnalyzerPass, Phase, AnalysisSession};
use bsharp_syntax::CompilationUnit;

pub struct MyPass;

impl AnalyzerPass for MyPass {
    fn id(&amp;self) -&gt; &amp;'static str { "passes.my_pass" }
    fn phase(&amp;self) -&gt; Phase { Phase::LocalRules }

    fn run(&amp;self, cu: &amp;CompilationUnit, session: &amp;mut AnalysisSession) {
        // Inspect `cu` and write results into `session.artifacts` or `session.diagnostics`
        // Example: count classes and log a note (pseudo)
        let mut count = 0usize;
        for _c in bsharp_analysis::framework::Query::from(cu).of::&lt;bsharp_syntax::ClassDeclaration&gt;() {
            count += 1;
        }
        // session.artifacts.insert(MyArtifact { class_count: count });
        // session.diagnostics.add(...);
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="registration"><a class="header" href="#registration">Registration</a></h2>
<p>Add your pass to the default registry in <code>src/bsharp_analysis/src/framework/registry.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>reg.register_pass(crate::passes::my_pass::MyPass);
<span class="boring">}</span></code></pre></pre>
<p>Or, build a custom registry for experiments:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut reg = AnalyzerRegistry::default_registry();
reg.register_pass(MyPass);
AnalyzerPipeline::run_for_file(&amp;cu, &amp;mut session, &amp;reg);
<span class="boring">}</span></code></pre></pre>
<p>You can also toggle passes via <code>AnalysisConfig.enable_passes["passes.my_pass"] = true|false</code> (see configuration docs).</p>
<hr />
<h2 id="tips-1"><a class="header" href="#tips-1">Tips</a></h2>
<ul>
<li><strong>Keep passes small</strong>: Focus on one responsibility.</li>
<li><strong>Prefer Query/AstWalker</strong>: Use <code>Query</code> for typed enumeration or <code>AstWalker</code> with <code>Visit</code> for custom traversal.</li>
<li><strong>Write artifacts</strong>: Insert results with <code>session.artifacts.insert(T)</code> when they may be consumed later.</li>
<li><strong>Determinism</strong>: Avoid non-deterministic ordering; use sorted maps/lists if needed.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-a-ruleset"><a class="header" href="#writing-a-ruleset">Writing a Ruleset</a></h1>
<p>This guide shows how to define rules and bundle them into a <code>RuleSet</code> to be executed by the analysis pipeline.</p>
<hr />
<h2 id="traits-and-types"><a class="header" href="#traits-and-types">Traits and Types</a></h2>
<p>Source: <code>src/bsharp_analysis/src/framework/rules.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum RuleTarget { All, Declarations, Members, Statements, Expressions }

pub trait Rule: Send + Sync + 'static {
    fn id(&amp;self) -&gt; &amp;'static str;
    fn category(&amp;self) -&gt; &amp;'static str;
    fn applies_to(&amp;self) -&gt; RuleTarget { RuleTarget::All }
    fn visit(&amp;self, _node: &amp;NodeRef, _session: &amp;mut AnalysisSession) {}
}

pub struct RuleSet { pub id: &amp;'static str, pub rules: Vec&lt;Box&lt;dyn Rule&gt;&gt; }
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="minimal-rule"><a class="header" href="#minimal-rule">Minimal Rule</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::framework::{Rule, RuleTarget, NodeRef, AnalysisSession};

pub struct NoEmptyCatch;

impl Rule for NoEmptyCatch {
    fn id(&amp;self) -&gt; &amp;'static str { "QUAL010" }
    fn category(&amp;self) -&gt; &amp;'static str { "quality" }
    fn applies_to(&amp;self) -&gt; RuleTarget { RuleTarget::Statements }

    fn visit(&amp;self, node: &amp;NodeRef, session: &amp;mut AnalysisSession) {
        if let NodeRef::Statement(stmt) = node {
            if let bsharp_syntax::statements::statement::Statement::Try(t) = stmt {
                for c in &amp;t.catches {
                    if c.block_is_empty() {
                        session.diagnostics.add(
                            bsharp_analysis::DiagnosticCode::from_static("QUAL010"),
                            "Empty catch block",
                            None,
                        );
                    }
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="building-a-ruleset"><a class="header" href="#building-a-ruleset">Building a RuleSet</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::framework::RuleSet;

pub fn ruleset() -&gt; RuleSet {
    RuleSet::new("quality")
        .with_rule(NoEmptyCatch)
        // .with_rule(AnotherRule)
}
<span class="boring">}</span></code></pre></pre>
<p>Register in the default registry (<code>src/bsharp_analysis/src/framework/registry.rs</code>) or construct a custom registry.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>reg.register_ruleset(crate::rules::quality::ruleset());         // local rules
reg.register_semantic_ruleset(crate::rules::control_flow_smells::ruleset());
<span class="boring">}</span></code></pre></pre>
<p>Rulesets can be enabled/disabled via <code>AnalysisConfig.enable_rulesets["quality"] = true|false</code>.</p>
<hr />
<h2 id="tips-2"><a class="header" href="#tips-2">Tips</a></h2>
<ul>
<li><strong>Choose RuleTarget</strong> thoughtfully to avoid unnecessary visits.</li>
<li><strong>Emit diagnostics</strong> with specific codes and helpful messages.</li>
<li><strong>Keep rules independent</strong>; accumulate state in <code>AnalysisSession</code> artifacts when needed.</li>
<li><strong>Honor config toggles</strong>; only run if your ruleset is enabled.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface"><a class="header" href="#command-line-interface">Command Line Interface</a></h1>
<p>The BSharp CLI provides command-line tools for parsing, analyzing, and visualizing C# code.</p>
<hr />
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="from-source"><a class="header" href="#from-source">From Source</a></h3>
<pre><code class="language-bash">git clone https://github.com/mikserek/bsharp.git
cd bsharp
cargo build --release
</code></pre>
<p>The binary will be available at <code>target/release/bsharp</code>.</p>
<h3 id="add-to-path"><a class="header" href="#add-to-path">Add to PATH</a></h3>
<pre><code class="language-bash"># Linux/macOS
export PATH="$PATH:/path/to/bsharp/target/release"

# Windows
# Add to System Environment Variables
</code></pre>
<hr />
<h2 id="command-structure"><a class="header" href="#command-structure">Command Structure</a></h2>
<pre><code class="language-bash">bsharp &lt;COMMAND&gt; [OPTIONS] &lt;INPUT&gt;
</code></pre>
<h3 id="global-options"><a class="header" href="#global-options">Global Options</a></h3>
<pre><code class="language-bash">--help, -h      Show help information
--version, -V   Show version information
</code></pre>
<h3 id="argument-files-file"><a class="header" href="#argument-files-file">Argument Files (@file)</a></h3>
<p>All commands support argument files via <code>@file</code> syntax. Example:</p>
<pre><code class="language-bash">bsharp @args.txt
</code></pre>
<p>Where <code>args.txt</code> contains one argument per line (comments and quoting follow standard shell parsing rules).</p>
<hr />
<h2 id="available-commands"><a class="header" href="#available-commands">Available Commands</a></h2>
<h3 id="parse"><a class="header" href="#parse">parse</a></h3>
<p>Parse C# source code and print a textual AST tree to stdout.</p>
<pre><code class="language-bash">bsharp parse &lt;INPUT&gt;
</code></pre>
<p><strong>See:</strong> <a href="cli/./parse.html">Parse Command</a></p>
<h3 id="tree"><a class="header" href="#tree">tree</a></h3>
<p>Generate a visualization of the Abstract Syntax Tree.</p>
<pre><code class="language-bash">bsharp tree &lt;INPUT&gt; [--output &lt;FILE&gt;] [--format mermaid|dot]
</code></pre>
<p>Notes:</p>
<ul>
<li>Default format is <code>mermaid</code>; output defaults to <code>&lt;input&gt;.mmd</code>.</li>
<li>For DOT/Graphviz, use <code>--format dot</code> (or <code>graphviz</code>); output defaults to <code>&lt;input&gt;.dot</code>.</li>
</ul>
<p><strong>See:</strong> <a href="cli/./tree.html">Tree Visualization</a></p>
<!-- compile command intentionally omitted (experimental/disabled) -->
<h3 id="analyze"><a class="header" href="#analyze">analyze</a></h3>
<p>Analyze C# code and generate comprehensive analysis report.</p>
<pre><code class="language-bash">bsharp analyze &lt;INPUT&gt; [OPTIONS]
</code></pre>
<p><strong>See:</strong> <a href="cli/./analyze.html">Analysis Command</a></p>
<h3 id="format"><a class="header" href="#format">format</a></h3>
<p>Format C# files using the built-in formatter and syntax emitters.</p>
<pre><code class="language-bash">bsharp format &lt;INPUT&gt; [--write] [--newline-mode lf|crlf] [--max-consecutive-blank-lines &lt;N&gt;] \
  [--blank-line-between-members &lt;BOOL&gt;] [--trim-trailing-whitespace &lt;BOOL&gt;] \
  [--emit-trace] [--emit-trace-file &lt;FILE&gt;]
</code></pre>
<p>Notes:</p>
<ul>
<li><code>&lt;INPUT&gt;</code> can be a file or directory (recursively formats .cs files; skips hidden/bin/obj/target).</li>
<li><code>--write</code> defaults to true; when false and a single file is given, the formatted output is printed to stdout.</li>
<li>Emission tracing can be enabled by <code>--emit-trace</code> or environment variable <code>BSHARP_EMIT_TRACE=1</code>.</li>
</ul>
<p><strong>See:</strong> <a href="cli/./format.html">Format Command</a></p>
<hr />
<h2 id="common-usage-patterns"><a class="header" href="#common-usage-patterns">Common Usage Patterns</a></h2>
<h3 id="quick-parse-check"><a class="header" href="#quick-parse-check">Quick Parse Check</a></h3>
<pre><code class="language-bash"># Check if file parses successfully
bsharp parse MyFile.cs
</code></pre>
<h3 id="generate-ast-for-inspection"><a class="header" href="#generate-ast-for-inspection">Generate AST for Inspection</a></h3>
<pre><code class="language-bash"># Pretty-printed JSON
bsharp parse MyFile.cs --output ast.json
</code></pre>
<h3 id="visualize-code-structure"><a class="header" href="#visualize-code-structure">Visualize Code Structure</a></h3>
<pre><code class="language-bash"># Generate Mermaid diagram (default), writes MyClass.mmd
bsharp tree MyClass.cs

# Generate Graphviz DOT diagram
bsharp tree MyClass.cs --format dot --output diagram.dot
</code></pre>
<h3 id="analyze-project-quality"><a class="header" href="#analyze-project-quality">Analyze Project Quality</a></h3>
<pre><code class="language-bash"># Full analysis with report
bsharp analyze MyProject.csproj --out report.json --format pretty-json
</code></pre>
<h3 id="analyze-solution"><a class="header" href="#analyze-solution">Analyze Solution</a></h3>
<pre><code class="language-bash"># Analyze entire solution
bsharp analyze MySolution.sln --follow-refs true
</code></pre>
<hr />
<h2 id="input-types"><a class="header" href="#input-types">Input Types</a></h2>
<h3 id="single-file"><a class="header" href="#single-file">Single File</a></h3>
<pre><code class="language-bash">bsharp parse Program.cs
</code></pre>
<h3 id="project-file-csproj"><a class="header" href="#project-file-csproj">Project File (.csproj)</a></h3>
<pre><code class="language-bash">bsharp analyze MyProject.csproj
</code></pre>
<h3 id="solution-file-sln"><a class="header" href="#solution-file-sln">Solution File (.sln)</a></h3>
<pre><code class="language-bash">bsharp analyze MySolution.sln
</code></pre>
<h3 id="directory"><a class="header" href="#directory">Directory</a></h3>
<pre><code class="language-bash">bsharp analyze ./src
</code></pre>
<hr />
<h2 id="output-formats"><a class="header" href="#output-formats">Output Formats</a></h2>
<h3 id="json-compact"><a class="header" href="#json-compact">JSON (Compact)</a></h3>
<pre><code class="language-bash">bsharp analyze MyFile.cs --format json
</code></pre>
<p><strong>Output:</strong> Single-line JSON, optimized for machine consumption</p>
<h3 id="pretty-json"><a class="header" href="#pretty-json">Pretty JSON</a></h3>
<pre><code class="language-bash">bsharp analyze MyFile.cs --format pretty-json
</code></pre>
<p><strong>Output:</strong> Indented JSON, human-readable</p>
<h3 id="mermaiddot-tree-command"><a class="header" href="#mermaiddot-tree-command">Mermaid/DOT (Tree Command)</a></h3>
<pre><code class="language-bash"># Mermaid (default)
bsharp tree MyFile.cs --output diagram.mmd

# Graphviz DOT
bsharp tree MyFile.cs --format dot --output diagram.dot
</code></pre>
<p><strong>Output:</strong> Mermaid (.mmd) or Graphviz DOT (.dot)</p>
<hr />
<h2 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h2>
<h3 id="parse-errors"><a class="header" href="#parse-errors">Parse Errors</a></h3>
<pre><code class="language-bash">$ bsharp parse InvalidSyntax.cs
Error: Parse failed at line 5, column 12
Expected ';' but found 'class'

public class MyClass
            ^
</code></pre>
<h3 id="file-not-found"><a class="header" href="#file-not-found">File Not Found</a></h3>
<pre><code class="language-bash">$ bsharp parse NonExistent.cs
Error: File not found: NonExistent.cs
</code></pre>
<h3 id="invalid-project"><a class="header" href="#invalid-project">Invalid Project</a></h3>
<pre><code class="language-bash">$ bsharp analyze Invalid.csproj
Error: Failed to parse project file: Invalid XML
</code></pre>
<hr />
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<h3 id="rust_log"><a class="header" href="#rust_log">RUST_LOG</a></h3>
<p>Control logging verbosity:</p>
<pre><code class="language-bash"># Show all logs
RUST_LOG=debug bsharp parse MyFile.cs

# Show only warnings and errors
RUST_LOG=warn bsharp analyze MyProject.csproj

# Show specific module logs
RUST_LOG=bsharp::parser=debug bsharp parse MyFile.cs
</code></pre>
<h3 id="rust_backtrace"><a class="header" href="#rust_backtrace">RUST_BACKTRACE</a></h3>
<p>Enable stack traces on panic:</p>
<pre><code class="language-bash">RUST_BACKTRACE=1 bsharp parse MyFile.cs
</code></pre>
<hr />
<h2 id="performance-considerations-2"><a class="header" href="#performance-considerations-2">Performance Considerations</a></h2>
<h3 id="large-files"><a class="header" href="#large-files">Large Files</a></h3>
<p>For large files (&gt; 10,000 lines), parsing may take several seconds:</p>
<pre><code class="language-bash"># Monitor progress with debug logging
RUST_LOG=info bsharp parse LargeFile.cs
</code></pre>
<h3 id="large-solutions"><a class="header" href="#large-solutions">Large Solutions</a></h3>
<p>For solutions with many projects, use parallel analysis:</p>
<pre><code class="language-bash"># Requires parallel_analysis feature
cargo build --release --features parallel_analysis
bsharp analyze LargeSolution.sln
</code></pre>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<p>Memory usage scales with AST size. For very large codebases:</p>
<pre><code class="language-bash"># Analyze incrementally by project
for proj in **/*.csproj; do
    bsharp analyze "$proj" --out "$(basename $proj .csproj).json"
done
</code></pre>
<hr />
<h2 id="integration-with-other-tools"><a class="header" href="#integration-with-other-tools">Integration with Other Tools</a></h2>
<h3 id="cicd-pipeline"><a class="header" href="#cicd-pipeline">CI/CD Pipeline</a></h3>
<pre><code class="language-yaml"># GitHub Actions example
- name: Analyze Code Quality
  run: |
    bsharp analyze MySolution.sln --out analysis.json
    # Upload analysis.json as artifact
</code></pre>
<h3 id="pre-commit-hook"><a class="header" href="#pre-commit-hook">Pre-commit Hook</a></h3>
<pre><code class="language-bash">#!/bin/bash
# .git/hooks/pre-commit

changed_files=$(git diff --cached --name-only --diff-filter=ACM | grep '\.cs$')

for file in $changed_files; do
    if ! bsharp parse "$file" &gt; /dev/null 2&gt;&amp;1; then
        echo "Parse error in $file"
        exit 1
    fi
done
</code></pre>
<h3 id="editor-integration"><a class="header" href="#editor-integration">Editor Integration</a></h3>
<pre><code class="language-json">// VS Code tasks.json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Analyze Current File",
            "type": "shell",
            "command": "bsharp",
            "args": [
                "analyze",
                "${file}",
                "--out",
                "${file}.analysis.json"
            ]
        }
    ]
}
</code></pre>
<hr />
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="command-not-found"><a class="header" href="#command-not-found">Command Not Found</a></h3>
<pre><code class="language-bash">$ bsharp: command not found
</code></pre>
<p><strong>Solution:</strong> Add bsharp to PATH or use full path:</p>
<pre><code class="language-bash">/path/to/bsharp/target/release/bsharp parse MyFile.cs
</code></pre>
<h3 id="permission-denied"><a class="header" href="#permission-denied">Permission Denied</a></h3>
<pre><code class="language-bash">$ bsharp parse MyFile.cs
Permission denied
</code></pre>
<p><strong>Solution:</strong> Make binary executable:</p>
<pre><code class="language-bash">chmod +x /path/to/bsharp
</code></pre>
<h3 id="out-of-memory"><a class="header" href="#out-of-memory">Out of Memory</a></h3>
<pre><code class="language-bash">$ bsharp analyze HugeSolution.sln
Error: memory allocation failed
</code></pre>
<p><strong>Solution:</strong> Analyze smaller subsets or increase system memory</p>
<hr />
<h2 id="configuration-files"><a class="header" href="#configuration-files">Configuration Files</a></h2>
<h3 id="analysis-configuration-1"><a class="header" href="#analysis-configuration-1">Analysis Configuration</a></h3>
<p>Create <code>.bsharp.toml</code> in project root:</p>
<pre><code class="language-toml">[analysis]
max_cyclomatic_complexity = 10
max_method_length = 50

[analysis.quality]
long_method = "warning"
god_class = "error"

[workspace]
follow_refs = true
include = ["**/*.cs"]
exclude = ["**/obj/**", "**/bin/**"]
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash"># Automatically loads .bsharp.toml from current directory
bsharp analyze MyProject.csproj
</code></pre>
<hr />
<h2 id="shell-completion"><a class="header" href="#shell-completion">Shell Completion</a></h2>
<p>Shell completion generation is currently not available in the CLI.</p>
<hr />
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="example-1-quick-syntax-check"><a class="header" href="#example-1-quick-syntax-check">Example 1: Quick Syntax Check</a></h3>
<pre><code class="language-bash"># Check if all C# files in directory parse correctly
find . -name "*.cs" -exec bsharp parse {} \; 2&gt;&amp;1 | grep -i error
</code></pre>
<h3 id="example-2-generate-documentation"><a class="header" href="#example-2-generate-documentation">Example 2: Generate Documentation</a></h3>
<pre><code class="language-bash"># Parse all files and extract class/method names
for file in src/**/*.cs; do
    bsharp parse "$file" --output "${file}.json"
done

# Process JSON to generate documentation
# (custom script)
</code></pre>
<h3 id="example-3-code-quality-gate"><a class="header" href="#example-3-code-quality-gate">Example 3: Code Quality Gate</a></h3>
<pre><code class="language-bash">#!/bin/bash
# quality-gate.sh

bsharp analyze MyProject.csproj --out report.json --format json

# Extract error count
errors=$(jq '.diagnostics | map(select(.severity == "error")) | length' report.json)

if [ "$errors" -gt 0 ]; then
    echo "Quality gate failed: $errors errors found"
    exit 1
fi

echo "Quality gate passed"
</code></pre>
<h3 id="example-4-complexity-report"><a class="header" href="#example-4-complexity-report">Example 4: Complexity Report</a></h3>
<pre><code class="language-bash"># Generate complexity report for all methods
bsharp analyze MySolution.sln --out complexity.json

# Extract high-complexity methods
jq '.diagnostics | map(select(.code == "MET001"))' complexity.json
</code></pre>
<hr />
<h2 id="cli-architecture"><a class="header" href="#cli-architecture">CLI Architecture</a></h2>
<h3 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h3>
<p><strong>Location:</strong> <code>src/bsharp_cli/</code></p>
<pre><code>src/bsharp_cli/
├── src/
│   ├── main.rs         # CLI entry point, clap definitions
│   └── commands/
│       ├── mod.rs      # Command module exports
│       ├── parse.rs    # Parse command implementation
│       ├── tree.rs     # AST visualization command (Mermaid/DOT)
│       └── analyze.rs  # Analysis command
└── Cargo.toml
</code></pre>
<h3 id="command-pattern"><a class="header" href="#command-pattern">Command Pattern</a></h3>
<p>Each command follows this pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn execute(input: PathBuf, /* other args */) -&gt; Result&lt;()&gt; {
    // 1. Validate input
    // 2. Load/parse files
    // 3. Perform operation
    // 4. Generate output
    // 5. Handle errors
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="future-enhancements-3"><a class="header" href="#future-enhancements-3">Future Enhancements</a></h2>
<h3 id="planned-features-3"><a class="header" href="#planned-features-3">Planned Features</a></h3>
<ol>
<li>
<p><strong>Interactive Mode</strong></p>
<ul>
<li>REPL for exploring AST</li>
<li>Interactive analysis</li>
</ul>
</li>
<li>
<p><strong>Watch Mode</strong></p>
<ul>
<li>Monitor files for changes</li>
<li>Re-analyze on save</li>
</ul>
</li>
<li>
<p><strong>Language Server</strong></p>
<ul>
<li>LSP implementation</li>
<li>IDE integration</li>
</ul>
</li>
<li>
<p><strong>Web Interface</strong></p>
<ul>
<li>Browser-based visualization</li>
<li>Interactive reports</li>
</ul>
</li>
</ol>
<hr />
<h2 id="related-documentation-5"><a class="header" href="#related-documentation-5">Related Documentation</a></h2>
<ul>
<li><a href="cli/./parse.html">Parse Command</a> - Detailed parse command documentation</li>
<li><a href="cli/./tree.html">Tree Visualization</a> - AST visualization</li>
<li><a href="cli/../analysis/pipeline.html">Analysis Pipeline</a> - Analysis internals</li>
</ul>
<hr />
<h2 id="references-8"><a class="header" href="#references-8">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/bsharp_cli/</code></li>
<li><strong>Commands:</strong> <code>src/bsharp_cli/src/commands/</code></li>
<li><strong>Clap Documentation:</strong> https://docs.rs/clap/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parse-command"><a class="header" href="#parse-command">Parse Command</a></h1>
<p>The <code>parse</code> command parses C# source code and prints a textual AST tree representation to stdout.</p>
<hr />
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<pre><code class="language-bash">bsharp parse &lt;INPUT&gt; [--errors-json] [--no-color] [--lenient]
</code></pre>
<h3 id="arguments"><a class="header" href="#arguments">Arguments</a></h3>
<p><strong><code>&lt;INPUT&gt;</code></strong> (required)</p>
<ul>
<li>Path to C# source file</li>
<li>Must have <code>.cs</code> extension</li>
<li>File must exist and be readable</li>
</ul>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<p><strong><code>--errors-json</code></strong></p>
<ul>
<li>Print a machine-readable JSON error object to stdout on parse failure and exit non-zero</li>
<li>Disables pretty error output</li>
</ul>
<p>See: <a href="cli/./errors-json.html">Parse Errors JSON Output</a></p>
<p><strong><code>--no-color</code></strong></p>
<ul>
<li>Disable ANSI colors in pretty error output</li>
</ul>
<p><strong><code>--lenient</code></strong></p>
<ul>
<li>Enable best-effort recovery mode (default is strict)</li>
</ul>
<hr />
<p>Note: The <code>--output</code> option is currently not used; the command writes the textual tree to stdout.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="basic-parsing"><a class="header" href="#basic-parsing">Basic Parsing</a></h3>
<pre><code class="language-bash"># Parse and print textual AST tree to stdout
bsharp parse Program.cs
</code></pre>
<h3 id="batch-parsing"><a class="header" href="#batch-parsing">Batch Parsing</a></h3>
<pre><code class="language-bash"># Parse all C# files in a directory (prints textual trees)
for file in src/**/*.cs; do
    bsharp parse "$file"
done
</code></pre>
<hr />
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<p>The command prints a human-readable textual tree describing the AST. For visualization outputs (Mermaid/DOT), use the <code>tree</code> command.</p>
<hr />
<h2 id="error-handling-6"><a class="header" href="#error-handling-6">Error Handling</a></h2>
<h3 id="parse-errors-1"><a class="header" href="#parse-errors-1">Parse Errors</a></h3>
<pre><code class="language-bash">$ bsharp parse InvalidSyntax.cs
Error: Parse failed

0: at line 5, in keyword "class":
public clas MyClass { }
       ^--- expected keyword "class"

1: in context "class declaration"
</code></pre>
<p><strong>Error Information:</strong></p>
<ul>
<li>Line and column numbers</li>
<li>Context stack showing where parsing failed</li>
<li>Expected vs. actual input</li>
<li>Helpful error messages</li>
</ul>
<h3 id="file-errors"><a class="header" href="#file-errors">File Errors</a></h3>
<pre><code class="language-bash">$ bsharp parse NonExistent.cs
Error: Failed to read file: NonExistent.cs
Caused by: No such file or directory (os error 2)
</code></pre>
<hr />
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h2>
<h3 id="1-syntax-validation"><a class="header" href="#1-syntax-validation">1. Syntax Validation</a></h3>
<pre><code class="language-bash"># Check if file has valid syntax
if bsharp parse MyFile.cs &gt; /dev/null 2&gt;&amp;1; then
    echo "Syntax OK"
else
    echo "Syntax Error"
    exit 1
fi
</code></pre>
<h3 id="2-ast-inspection"><a class="header" href="#2-ast-inspection">2. AST Inspection</a></h3>
<pre><code class="language-bash"># Parse and inspect AST structure
bsharp parse MyClass.cs --output ast.json
jq '.declarations[0].Class.name.name' ast.json
</code></pre>
<h3 id="3-documentation-input"><a class="header" href="#3-documentation-input">3. Documentation Input</a></h3>
<pre><code class="language-bash"># Parse C# and generate documentation using your own script
bsharp parse MyFile.cs --output ast.json
python generate_docs.py ast.json &gt; docs.md
</code></pre>
<h3 id="4-static-analysis"><a class="header" href="#4-static-analysis">4. Static Analysis</a></h3>
<pre><code class="language-bash"># Parse and analyze with custom tool
bsharp parse MyFile.cs --output ast.json
./my-analyzer ast.json
</code></pre>
<hr />
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<h3 id="parsing-speed"><a class="header" href="#parsing-speed">Parsing Speed</a></h3>
<ul>
<li><strong>Small files</strong> (&lt; 100 lines): &lt; 10ms</li>
<li><strong>Medium files</strong> (100-1000 lines): 10-100ms</li>
<li><strong>Large files</strong> (1000-10000 lines): 100ms-1s</li>
<li><strong>Very large files</strong> (&gt; 10000 lines): 1-10s</li>
</ul>
<h3 id="memory-usage-1"><a class="header" href="#memory-usage-1">Memory Usage</a></h3>
<ul>
<li>Memory usage scales linearly with file size</li>
<li>Typical: 1-5 MB per 1000 lines of code</li>
<li>Peak memory during AST construction</li>
</ul>
<hr />
<h2 id="integration-1"><a class="header" href="#integration-1">Integration</a></h2>
<h3 id="cicd-pipeline-1"><a class="header" href="#cicd-pipeline-1">CI/CD Pipeline</a></h3>
<pre><code class="language-yaml"># GitHub Actions
- name: Validate C# Syntax
  run: |
    find . -name "*.cs" | while read file; do
      bsharp parse "$file" || exit 1
    done
</code></pre>
<h3 id="pre-commit-hook-1"><a class="header" href="#pre-commit-hook-1">Pre-commit Hook</a></h3>
<pre><code class="language-bash">#!/bin/bash
# .git/hooks/pre-commit

git diff --cached --name-only --diff-filter=ACM | grep '\.cs$' | while read file; do
    if ! bsharp parse "$file" &gt; /dev/null 2&gt;&amp;1; then
        echo "Parse error in $file"
        exit 1
    fi
done
</code></pre>
<h3 id="build-script"><a class="header" href="#build-script">Build Script</a></h3>
<pre><code class="language-bash">#!/bin/bash
# validate-syntax.sh

errors=0
for file in src/**/*.cs; do
    if ! bsharp parse "$file" &gt; /dev/null 2&gt;&amp;1; then
        echo "ERROR: $file"
        ((errors++))
    fi
done

if [ $errors -gt 0 ]; then
    echo "Found $errors files with syntax errors"
    exit 1
fi
</code></pre>
<hr />
<h2 id="comparison-with-other-tools"><a class="header" href="#comparison-with-other-tools">Comparison with Other Tools</a></h2>
<h3 id="vs-roslyn"><a class="header" href="#vs-roslyn">vs. Roslyn</a></h3>
<ul>
<li><strong>BSharp:</strong> Fast, standalone, JSON output</li>
<li><strong>Roslyn:</strong> Full compiler, .NET required, complex API</li>
</ul>
<h3 id="vs-tree-sitter"><a class="header" href="#vs-tree-sitter">vs. Tree-sitter</a></h3>
<ul>
<li><strong>BSharp:</strong> C#-specific, complete AST</li>
<li><strong>Tree-sitter:</strong> Multi-language, syntax tree only</li>
</ul>
<hr />
<h2 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h2>
<p><strong>Location:</strong> <code>src/bsharp_cli/src/commands/parse.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn execute(
    input: PathBuf,
    output: Option&lt;PathBuf&gt;,
    errors_json: bool,
    no_color: bool,
    lenient: bool,
) -&gt; Result&lt;()&gt; {
    // Read file, choose strict/lenient, parse, and write &lt;input&gt;.json by default
    // See the source file for detailed behavior and error formatting.
<span class="boring">    Ok(())
</span>}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="related-documentation-6"><a class="header" href="#related-documentation-6">Related Documentation</a></h2>
<ul>
<li><a href="cli/./overview.html">CLI Overview</a> - General CLI usage</li>
<li><a href="cli/./tree.html">Tree Visualization</a> - Visualize parsed AST</li>
<li><a href="cli/../parser/ast-structure.html">AST Structure</a> - AST node reference</li>
<li><a href="cli/../parser/error-handling.html">Error Handling</a> - Parse error details</li>
</ul>
<hr />
<h2 id="references-9"><a class="header" href="#references-9">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/bsharp_cli/src/commands/parse.rs</code></li>
<li><strong>Parser:</strong> <code>src/bsharp_parser/src/</code></li>
<li><strong>AST Definitions:</strong> <code>src/bsharp_syntax/src/</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-visualization-command"><a class="header" href="#tree-visualization-command">Tree Visualization Command</a></h1>
<p>The <code>tree</code> command generates a visualization of the Abstract Syntax Tree (AST) from C# source code in Mermaid or Graphviz DOT format.</p>
<hr />
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<pre><code class="language-bash">bsharp tree &lt;INPUT&gt; [--output &lt;FILE&gt;] [--format mermaid|dot]
</code></pre>
<h3 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h3>
<p><strong><code>&lt;INPUT&gt;</code></strong> (required)</p>
<ul>
<li>Path to C# source file</li>
<li>Must have <code>.cs</code> extension</li>
</ul>
<h3 id="options-1"><a class="header" href="#options-1">Options</a></h3>
<p><strong><code>--output, -o &lt;FILE&gt;</code></strong> (optional)</p>
<ul>
<li>Output file path</li>
<li>Default: <code>&lt;input&gt;.mmd</code> for Mermaid, <code>&lt;input&gt;.dot</code> for DOT</li>
</ul>
<p><strong><code>--format &lt;FORMAT&gt;</code></strong> (optional)</p>
<ul>
<li>One of: <code>mermaid</code> (default), <code>dot</code> (alias: <code>graphviz</code>)</li>
</ul>
<hr />
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="basic-visualization"><a class="header" href="#basic-visualization">Basic Visualization</a></h3>
<pre><code class="language-bash"># Generate Mermaid diagram (default)
bsharp tree Program.cs              # writes Program.mmd

# Generate Graphviz DOT diagram
bsharp tree Program.cs --format dot # writes Program.dot

# Specify output file
bsharp tree Program.cs --format dot --output ast-diagram.dot
</code></pre>
<h3 id="viewrender"><a class="header" href="#viewrender">View/Render</a></h3>
<pre><code class="language-bash"># Mermaid preview (e.g., VS Code Mermaid extension) or CLI renderer
# Graphviz render to PNG
dot -Tpng Program.dot -o Program.png
</code></pre>
<hr />
<h2 id="output-formats-1"><a class="header" href="#output-formats-1">Output Formats</a></h2>
<h3 id="mermaid"><a class="header" href="#mermaid">Mermaid</a></h3>
<p>Outputs a simple top-level graph in Mermaid syntax (<code>.mmd</code>).</p>
<pre><code class="language-text">graph TD
n0["CompilationUnit\\nUsings: 1\\nDecls: 1"]
u0["Using using System;"]
n0 --&gt; u0
d0["Class: Program"]
n0 --&gt; d0
</code></pre>
<h3 id="graphviz-dot"><a class="header" href="#graphviz-dot">Graphviz DOT</a></h3>
<p>Outputs a simple top-level graph in DOT syntax (<code>.dot</code>).</p>
<pre><code class="language-text">digraph AST {
  node [shape=box, fontname="Courier New"];
  n0 [label="CompilationUnit\\nUsings: 1\\nDecls: 1"];
  u0 [label="Using using System;"];
  n0 -&gt; u0;
  d0 [label="Class: Program"];
  n0 -&gt; d0;
}
</code></pre>
<h3 id="color-scheme"><a class="header" href="#color-scheme">Color Scheme</a></h3>
<ul>
<li><strong>Gray</strong> - Root nodes (CompilationUnit)</li>
<li><strong>Blue</strong> - Type declarations (Class, Interface, Struct)</li>
<li><strong>Green</strong> - Member declarations (Method, Property, Field)</li>
<li><strong>Yellow</strong> - Statements (If, For, While)</li>
<li><strong>Orange</strong> - Expressions (Binary, Invocation)</li>
<li><strong>Purple</strong> - Types (Primitive, Named, Generic)</li>
</ul>
<hr />
<h2 id="visualization-features"><a class="header" href="#visualization-features">Visualization Features</a></h2>
<h3 id="node-information"><a class="header" href="#node-information">Node Information</a></h3>
<p>Each node displays:</p>
<ul>
<li><strong>Node Type</strong> - AST node type name</li>
<li><strong>Identifier</strong> - Name (for named nodes)</li>
<li><strong>Additional Info</strong> - Modifiers, types, etc.</li>
</ul>
<h3 id="tree-layout"><a class="header" href="#tree-layout">Tree Layout</a></h3>
<ul>
<li><strong>Top-down</strong> - Root at top, leaves at bottom</li>
<li><strong>Hierarchical</strong> - Parent-child relationships clear</li>
<li><strong>Balanced</strong> - Nodes distributed evenly</li>
<li><strong>Scalable</strong> - Adjusts to tree size</li>
</ul>
<hr />
<h2 id="use-cases-2"><a class="header" href="#use-cases-2">Use Cases</a></h2>
<h3 id="1-understanding-code-structure"><a class="header" href="#1-understanding-code-structure">1. Understanding Code Structure</a></h3>
<pre><code class="language-bash"># Visualize complex class
bsharp tree ComplexClass.cs --output structure.svg
</code></pre>
<h3 id="2-teachingdocumentation"><a class="header" href="#2-teachingdocumentation">2. Teaching/Documentation</a></h3>
<pre><code class="language-bash"># Generate diagrams for documentation
bsharp tree Example.cs --output docs/ast-example.svg
</code></pre>
<h3 id="3-debugging-parser"><a class="header" href="#3-debugging-parser">3. Debugging Parser</a></h3>
<pre><code class="language-bash"># Verify parser output
bsharp tree TestCase.cs --output debug.svg
</code></pre>
<h3 id="4-code-review"><a class="header" href="#4-code-review">4. Code Review</a></h3>
<pre><code class="language-bash"># Visualize changes
bsharp tree NewFeature.cs --output review.svg
</code></pre>
<hr />
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<h3 id="large-files-1"><a class="header" href="#large-files-1">Large Files</a></h3>
<ul>
<li>Files &gt; 1000 lines may produce very large SVGs</li>
<li>Consider visualizing specific classes/methods only</li>
</ul>
<h3 id="complex-nesting"><a class="header" href="#complex-nesting">Complex Nesting</a></h3>
<ul>
<li>Deeply nested structures may be hard to read</li>
<li>SVG may require horizontal scrolling</li>
</ul>
<h3 id="performance-1"><a class="header" href="#performance-1">Performance</a></h3>
<ul>
<li>Generation time increases with AST size</li>
<li>Large files (&gt; 5000 lines) may take several seconds</li>
</ul>
<hr />
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<h3 id="selective-visualization"><a class="header" href="#selective-visualization">Selective Visualization</a></h3>
<pre><code class="language-bash"># Extract specific class and visualize
# (requires custom script to extract class)
extract-class.sh MyFile.cs MyClass &gt; temp.cs
bsharp tree temp.cs --output MyClass-ast.svg
rm temp.cs
</code></pre>
<h3 id="batch-generation"><a class="header" href="#batch-generation">Batch Generation</a></h3>
<pre><code class="language-bash"># Generate visualizations for all files
for file in src/**/*.cs; do
    output="diagrams/$(basename $file .cs).svg"
    bsharp tree "$file" --output "$output"
done
</code></pre>
<h3 id="integration-with-documentation"><a class="header" href="#integration-with-documentation">Integration with Documentation</a></h3>
<pre><code class="language-markdown"># MyClass Documentation

## AST Structure

![AST Diagram](./diagrams/MyClass.svg)

The class structure shows...
</code></pre>
<hr />
<h2 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h2>
<p><strong>Location:</strong> <code>src/bsharp_cli/src/commands/tree.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn execute(args: Box&lt;TreeArgs&gt;) -&gt; Result&lt;()&gt; {
    // Parses input in lenient mode, then writes Mermaid (.mmd) or DOT (.dot)
    // using bsharp_syntax::node::render::{to_mermaid, to_dot}.
<span class="boring">    Ok(())
</span>}
<span class="boring">}</span></code></pre></pre>
<p>Renderer functions live in <code>src/bsharp_syntax/src/node/render.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>to_mermaid(&amp;ast);
to_dot(&amp;ast);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="customization"><a class="header" href="#customization">Customization</a></h2>
<h3 id="future-enhancements-4"><a class="header" href="#future-enhancements-4">Future Enhancements</a></h3>
<ol>
<li>
<p><strong>Interactive SVG</strong></p>
<ul>
<li>Click to expand/collapse nodes</li>
<li>Hover for details</li>
<li>Search functionality</li>
</ul>
</li>
<li>
<p><strong>Export Formats</strong></p>
<ul>
<li>PNG/PDF export</li>
<li>DOT format for Graphviz</li>
<li>PlantUML format</li>
</ul>
</li>
<li>
<p><strong>Filtering</strong></p>
<ul>
<li>Show only specific node types</li>
<li>Hide implementation details</li>
<li>Focus on structure</li>
</ul>
</li>
<li>
<p><strong>Styling</strong></p>
<ul>
<li>Custom color schemes</li>
<li>Font customization</li>
<li>Layout options</li>
</ul>
</li>
</ol>
<hr />
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="svg-too-large"><a class="header" href="#svg-too-large">SVG Too Large</a></h3>
<p><strong>Problem:</strong> Generated SVG is too large to view</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Visualize smaller code sections</li>
<li>Use SVG viewer with zoom/pan</li>
<li>Export to PDF for printing</li>
</ul>
<h3 id="overlapping-nodes"><a class="header" href="#overlapping-nodes">Overlapping Nodes</a></h3>
<p><strong>Problem:</strong> Nodes overlap in complex trees</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Increase SVG dimensions</li>
<li>Simplify code structure</li>
<li>Use horizontal layout (future feature)</li>
</ul>
<h3 id="missing-nodes"><a class="header" href="#missing-nodes">Missing Nodes</a></h3>
<p><strong>Problem:</strong> Some AST nodes not shown</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Check parser output with <code>parse</code> command</li>
<li>Report issue if nodes are missing</li>
</ul>
<hr />
<h2 id="related-documentation-7"><a class="header" href="#related-documentation-7">Related Documentation</a></h2>
<ul>
<li><a href="cli/./overview.html">CLI Overview</a> - General CLI usage</li>
<li><a href="cli/./parse.html">Parse Command</a> - Parse textual AST tree</li>
<li><a href="cli/../parser/ast-structure.html">AST Structure</a> - AST node reference</li>
</ul>
<hr />
<h2 id="references-10"><a class="header" href="#references-10">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/bsharp_cli/src/commands/tree.rs</code></li>
<li><strong>Formats:</strong> Mermaid or Graphviz DOT</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analyze-command"><a class="header" href="#analyze-command">Analyze Command</a></h1>
<p>The <code>analyze</code> command performs comprehensive code analysis on C# files, projects, or solutions, generating detailed reports with diagnostics, metrics, and quality assessments.</p>
<hr />
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<pre><code class="language-bash">bsharp analyze &lt;INPUT&gt; [OPTIONS]
</code></pre>
<h3 id="arguments-2"><a class="header" href="#arguments-2">Arguments</a></h3>
<p><strong><code>&lt;INPUT&gt;</code></strong> (required)</p>
<ul>
<li>Path to C# source file (<code>.cs</code>)</li>
<li>Path to project file (<code>.csproj</code>)</li>
<li>Path to solution file (<code>.sln</code>)</li>
<li>Path to directory</li>
</ul>
<hr />
<h2 id="options-2"><a class="header" href="#options-2">Options</a></h2>
<h3 id="output-options"><a class="header" href="#output-options">Output Options</a></h3>
<p><strong><code>--out &lt;FILE&gt;</code></strong></p>
<ul>
<li>Output file path for analysis report (JSON)</li>
<li>Default: stdout</li>
<li>Creates parent directories if needed</li>
</ul>
<p><strong><code>--format &lt;FORMAT&gt;</code></strong></p>
<ul>
<li>Output format: <code>json</code> (compact) or <code>pretty-json</code> (indented)</li>
<li>Default: <code>pretty-json</code></li>
</ul>
<h3 id="configuration-5"><a class="header" href="#configuration-5">Configuration</a></h3>
<p><strong><code>--config &lt;FILE&gt;</code></strong></p>
<ul>
<li>Path to analysis configuration file (JSON or TOML)</li>
<li>Overrides default settings</li>
<li>CLI flags override config file settings</li>
</ul>
<p>See: <a href="cli/../configuration/overview.html">Configuration Overview</a></p>
<h3 id="workspace-options"><a class="header" href="#workspace-options">Workspace Options</a></h3>
<p><strong><code>--follow-refs &lt;BOOL&gt;</code></strong></p>
<ul>
<li>Follow ProjectReference dependencies transitively</li>
<li>Default: <code>true</code></li>
<li>Set to <code>false</code> to analyze only specified project</li>
</ul>
<p><strong><code>--include &lt;GLOB&gt;...</code></strong></p>
<ul>
<li>Include only files matching glob patterns</li>
<li>Multiple patterns allowed</li>
<li>Example: <code>--include "**/*Service.cs" "**/*Controller.cs"</code></li>
</ul>
<p><strong><code>--exclude &lt;GLOB&gt;...</code></strong></p>
<ul>
<li>Exclude files matching glob patterns</li>
<li>Multiple patterns allowed</li>
<li>Example: <code>--exclude "**/obj/**" "**/bin/**" "**/Tests/**"</code></li>
</ul>
<h3 id="analysis-control"><a class="header" href="#analysis-control">Analysis Control</a></h3>
<p><strong><code>--enable-ruleset &lt;ID&gt;...</code></strong></p>
<ul>
<li>Enable specific rulesets by ID</li>
<li>Multiple IDs allowed</li>
<li>Overrides config file</li>
<li>Example: <code>--enable-ruleset naming quality</code></li>
</ul>
<p><strong><code>--disable-ruleset &lt;ID&gt;...</code></strong></p>
<ul>
<li>Disable specific rulesets by ID</li>
<li>Multiple IDs allowed</li>
<li>Example: <code>--disable-ruleset experimental</code></li>
</ul>
<p><strong><code>--enable-pass &lt;ID&gt;...</code></strong></p>
<ul>
<li>Enable specific analysis passes by ID</li>
<li>Multiple IDs allowed</li>
<li>Example: <code>--enable-pass indexing control_flow</code></li>
</ul>
<p><strong><code>--disable-pass &lt;ID&gt;...</code></strong></p>
<ul>
<li>Disable specific analysis passes by ID</li>
<li>Multiple IDs allowed</li>
<li>Example: <code>--disable-pass dependencies</code></li>
</ul>
<p><strong><code>--severity &lt;CODE=LEVEL&gt;...</code></strong></p>
<ul>
<li>Override diagnostic severity for specific codes</li>
<li>Format: <code>CODE=level</code> where level is <code>error</code>, <code>warning</code>, <code>info</code>, or <code>hint</code></li>
<li>Multiple overrides allowed</li>
<li>Example: <code>--severity MET001=error QUAL010=warning</code></li>
</ul>
<h3 id="legacy-options-single-file-mode"><a class="header" href="#legacy-options-single-file-mode">Legacy Options (Single File Mode)</a></h3>
<p><strong><code>--symbol &lt;NAME&gt;</code></strong></p>
<ul>
<li>Search for specific symbol by name</li>
<li>Only works in single-file mode</li>
<li>Prints symbol locations and information</li>
</ul>
<hr />
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="basic-analysis"><a class="header" href="#basic-analysis">Basic Analysis</a></h3>
<pre><code class="language-bash"># Analyze single file
bsharp analyze MyFile.cs

# Analyze project
bsharp analyze MyProject.csproj

# Analyze solution
bsharp analyze MySolution.sln
</code></pre>
<h3 id="output-to-file"><a class="header" href="#output-to-file">Output to File</a></h3>
<pre><code class="language-bash"># Save report to file
bsharp analyze MyProject.csproj --out report.json

# Compact JSON format
bsharp analyze MyProject.csproj --out report.json --format json
</code></pre>
<h3 id="using-configuration-file"><a class="header" href="#using-configuration-file">Using Configuration File</a></h3>
<pre><code class="language-bash"># Load config from file
bsharp analyze MyProject.csproj --config .bsharp.toml

# Config file with CLI overrides
bsharp analyze MyProject.csproj \
    --config .bsharp.toml \
    --enable-ruleset quality \
    --severity MET001=error
</code></pre>
<h3 id="workspace-filtering"><a class="header" href="#workspace-filtering">Workspace Filtering</a></h3>
<pre><code class="language-bash"># Analyze only service files
bsharp analyze MySolution.sln --include "**/*Service.cs"

# Exclude test files
bsharp analyze MySolution.sln --exclude "**/Tests/**"

# Multiple filters
bsharp analyze MySolution.sln \
    --include "src/**/*.cs" \
    --exclude "**/obj/**" "**/bin/**" "**/Tests/**"
</code></pre>
<h3 id="controlling-analysis"><a class="header" href="#controlling-analysis">Controlling Analysis</a></h3>
<pre><code class="language-bash"># Enable specific rulesets
bsharp analyze MyProject.csproj \
    --enable-ruleset naming quality control_flow

# Disable experimental features
bsharp analyze MyProject.csproj \
    --disable-ruleset experimental

# Enable/disable specific passes
bsharp analyze MyProject.csproj \
    --enable-pass indexing control_flow \
    --disable-pass dependencies
</code></pre>
<h3 id="severity-overrides"><a class="header" href="#severity-overrides">Severity Overrides</a></h3>
<pre><code class="language-bash"># Treat specific warnings as errors
bsharp analyze MyProject.csproj \
    --severity MET001=error \
    --severity QUAL001=error

# Downgrade specific errors to warnings
bsharp analyze MyProject.csproj \
    --severity CS0168=warning
</code></pre>
<h3 id="symbol-search-single-file"><a class="header" href="#symbol-search-single-file">Symbol Search (Single File)</a></h3>
<pre><code class="language-bash"># Find symbol in file
bsharp analyze MyFile.cs --symbol MyClass

# Output:
# Found symbol 'MyClass' at line 10, column 14
</code></pre>
<hr />
<h2 id="analysis-modes"><a class="header" href="#analysis-modes">Analysis Modes</a></h2>
<h3 id="single-file-mode"><a class="header" href="#single-file-mode">Single File Mode</a></h3>
<p><strong>Triggered when:</strong> Input is a <code>.cs</code> file</p>
<p><strong>Behavior:</strong></p>
<ul>
<li>Parses single file</li>
<li>Runs analysis pipeline on CompilationUnit</li>
<li>Supports <code>--symbol</code> option for symbol search</li>
<li>Faster for quick checks</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">bsharp analyze Program.cs --out analysis.json
</code></pre>
<h3 id="workspace-mode"><a class="header" href="#workspace-mode">Workspace Mode</a></h3>
<p><strong>Triggered when:</strong> Input is <code>.sln</code>, <code>.csproj</code>, or directory</p>
<p><strong>Behavior:</strong></p>
<ul>
<li>Loads entire workspace</li>
<li>Discovers all source files</li>
<li>Follows project references (if <code>--follow-refs true</code>)</li>
<li>Applies include/exclude filters</li>
<li>Analyzes all files deterministically</li>
<li>Aggregates results into single report</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">bsharp analyze MySolution.sln \
    --follow-refs true \
    --exclude "**/Tests/**" \
    --out workspace-analysis.json
</code></pre>
<hr />
<h2 id="configuration-file-format"><a class="header" href="#configuration-file-format">Configuration File Format</a></h2>
<h3 id="toml-format"><a class="header" href="#toml-format">TOML Format</a></h3>
<p><strong><code>.bsharp.toml</code>:</strong></p>
<pre><code class="language-toml">[analysis]
max_cyclomatic_complexity = 10
max_method_length = 50

[analysis.control_flow]
cf_high_complexity_threshold = 10
cf_deep_nesting_threshold = 4

[analysis.quality]
long_method = "warning"
god_class = "error"
empty_catch = "error"

[workspace]
follow_refs = true
include = ["src/**/*.cs"]
exclude = ["**/obj/**", "**/bin/**", "**/Tests/**"]

[enable_rulesets]
naming = true
quality = true
control_flow = true

[enable_passes]
indexing = true
control_flow = true
dependencies = true

[rule_severities]
MET001 = "error"
QUAL001 = "warning"
</code></pre>
<h3 id="json-format"><a class="header" href="#json-format">JSON Format</a></h3>
<p><strong><code>.bsharp.json</code>:</strong></p>
<pre><code class="language-json">{
  "analysis": {
    "max_cyclomatic_complexity": 10,
    "max_method_length": 50,
    "control_flow": {
      "cf_high_complexity_threshold": 10,
      "cf_deep_nesting_threshold": 4
    }
  },
  "workspace": {
    "follow_refs": true,
    "include": ["src/**/*.cs"],
    "exclude": ["**/obj/**", "**/bin/**"]
  },
  "enable_rulesets": {
    "naming": true,
    "quality": true
  },
  "enable_passes": {
    "indexing": true,
    "control_flow": true
  },
  "rule_severities": {
    "MET001": "error",
    "QUAL001": "warning"
  }
}
</code></pre>
<hr />
<h2 id="output-format"><a class="header" href="#output-format">Output Format</a></h2>
<h3 id="analysis-report-structure"><a class="header" href="#analysis-report-structure">Analysis Report Structure</a></h3>
<pre><code class="language-json">{
  "schema_version": 1,
  "diagnostics": {
    "items": [
      {
        "code": "MET001",
        "severity": "warning",
        "message": "Method has high cyclomatic complexity",
        "file": "src/OrderService.cs",
        "line": 42,
        "column": 17,
        "end_line": 85,
        "end_column": 5
      }
    ]
  },
  "metrics": {
    "total_lines": 1250,
    "code_lines": 980,
    "comment_lines": 150,
    "blank_lines": 120,
    "class_count": 15,
    "interface_count": 3,
    "method_count": 87,
    "total_complexity": 245,
    "max_complexity": 18,
    "max_nesting_depth": 5
  },
  "cfg": {
    "total_methods": 87,
    "high_complexity_count": 5,
    "deep_nesting_count": 3
  },
  "deps": {
    "total_nodes": 15,
    "total_edges": 42,
    "circular_dependencies": 0,
    "max_depth": 4
  },
  "workspace_warnings": [
    "Failed to parse project: MyBrokenProject.csproj"
  ]
}
</code></pre>
<h3 id="diagnostic-fields"><a class="header" href="#diagnostic-fields">Diagnostic Fields</a></h3>
<ul>
<li><strong>code</strong>: Diagnostic code (e.g., <code>MET001</code>, <code>QUAL010</code>)</li>
<li><strong>severity</strong>: <code>error</code>, <code>warning</code>, <code>info</code>, or <code>hint</code></li>
<li><strong>message</strong>: Human-readable description</li>
<li><strong>file</strong>: Source file path</li>
<li><strong>line/column</strong>: Start position</li>
<li><strong>end_line/end_column</strong>: End position (optional)</li>
</ul>
<h3 id="metrics-fields"><a class="header" href="#metrics-fields">Metrics Fields</a></h3>
<ul>
<li><strong>total_lines</strong>: Total lines including blank/comments</li>
<li><strong>code_lines</strong>: Lines with actual code</li>
<li><strong>comment_lines</strong>: Lines with comments</li>
<li><strong>blank_lines</strong>: Empty lines</li>
<li><strong>class_count</strong>: Number of classes</li>
<li><strong>interface_count</strong>: Number of interfaces</li>
<li><strong>method_count</strong>: Number of methods</li>
<li><strong>total_complexity</strong>: Sum of all method complexities</li>
<li><strong>max_complexity</strong>: Highest method complexity</li>
<li><strong>max_nesting_depth</strong>: Deepest nesting level</li>
</ul>
<hr />
<h2 id="available-rulesets"><a class="header" href="#available-rulesets">Available Rulesets</a></h2>
<h3 id="built-in-rulesets"><a class="header" href="#built-in-rulesets">Built-in Rulesets</a></h3>
<p><strong><code>naming</code></strong> - Naming convention rules</p>
<ul>
<li>Class names: PascalCase</li>
<li>Method names: PascalCase</li>
<li>Field names: camelCase with <code>_</code> prefix</li>
<li>Constant names: UPPER_CASE or PascalCase</li>
</ul>
<p><strong><code>quality</code></strong> - Code quality rules</p>
<ul>
<li>Long method detection</li>
<li>Long parameter list</li>
<li>God class detection</li>
<li>Empty catch blocks</li>
<li>Magic numbers</li>
</ul>
<p><strong><code>control_flow</code></strong> - Control flow rules</p>
<ul>
<li>High complexity warnings</li>
<li>Deep nesting warnings</li>
<li>Unreachable code detection</li>
</ul>
<p><strong><code>semantic</code></strong> - Semantic rules</p>
<ul>
<li>Type checking</li>
<li>Null reference analysis</li>
<li>Resource leak detection</li>
</ul>
<hr />
<h2 id="available-passes"><a class="header" href="#available-passes">Available Passes</a></h2>
<h3 id="built-in-passes"><a class="header" href="#built-in-passes">Built-in Passes</a></h3>
<p><strong><code>indexing</code></strong> (Phase: Index)</p>
<ul>
<li>Builds symbol index</li>
<li>Creates name index</li>
<li>Generates FQN map</li>
</ul>
<p><strong><code>control_flow</code></strong> (Phase: Semantic)</p>
<ul>
<li>Analyzes control flow</li>
<li>Calculates complexity metrics</li>
<li>Detects control flow smells</li>
</ul>
<p><strong><code>dependencies</code></strong> (Phase: Global)</p>
<ul>
<li>Builds dependency graph</li>
<li>Detects circular dependencies</li>
<li>Calculates coupling metrics</li>
</ul>
<p><strong><code>reporting</code></strong> (Phase: Reporting)</p>
<ul>
<li>Generates final report</li>
<li>Aggregates diagnostics</li>
<li>Summarizes artifacts</li>
</ul>
<hr />
<h2 id="diagnostic-codes"><a class="header" href="#diagnostic-codes">Diagnostic Codes</a></h2>
<h3 id="metrics-met"><a class="header" href="#metrics-met">Metrics (MET)</a></h3>
<ul>
<li><strong>MET001</strong>: High cyclomatic complexity</li>
<li><strong>MET002</strong>: Deep nesting detected</li>
<li><strong>MET003</strong>: Long method</li>
<li><strong>MET004</strong>: Long parameter list</li>
</ul>
<h3 id="quality-qual"><a class="header" href="#quality-qual">Quality (QUAL)</a></h3>
<ul>
<li><strong>QUAL001</strong>: Long method</li>
<li><strong>QUAL002</strong>: Long parameter list</li>
<li><strong>QUAL010</strong>: Empty catch block</li>
<li><strong>QUAL020</strong>: Naming convention violation</li>
<li><strong>QUAL030</strong>: Resource not disposed</li>
</ul>
<h3 id="control-flow-cf"><a class="header" href="#control-flow-cf">Control Flow (CF)</a></h3>
<ul>
<li><strong>CF001</strong>: Unreachable code</li>
<li><strong>CF002</strong>: High complexity</li>
<li><strong>CF003</strong>: Deep nesting</li>
</ul>
<h3 id="dependencies-dep"><a class="header" href="#dependencies-dep">Dependencies (DEP)</a></h3>
<ul>
<li><strong>DEP001</strong>: Circular dependency</li>
<li><strong>DEP002</strong>: High coupling</li>
<li><strong>DEP003</strong>: Unstable dependency</li>
</ul>
<hr />
<h2 id="performance-2"><a class="header" href="#performance-2">Performance</a></h2>
<h3 id="analysis-speed"><a class="header" href="#analysis-speed">Analysis Speed</a></h3>
<ul>
<li><strong>Single file</strong> (&lt; 1000 lines): &lt; 100ms</li>
<li><strong>Small project</strong> (&lt; 10 files): &lt; 500ms</li>
<li><strong>Medium project</strong> (10-50 files): 500ms-2s</li>
<li><strong>Large solution</strong> (100+ files): 2-10s</li>
</ul>
<h3 id="memory-usage-2"><a class="header" href="#memory-usage-2">Memory Usage</a></h3>
<ul>
<li>Scales with codebase size</li>
<li>Typical: 50-200 MB for medium projects</li>
<li>Artifacts cached in memory during analysis</li>
</ul>
<h3 id="parallel-analysis"><a class="header" href="#parallel-analysis">Parallel Analysis</a></h3>
<p>With <code>parallel_analysis</code> feature enabled:</p>
<pre><code class="language-bash">cargo build --release --features parallel_analysis
</code></pre>
<p>Files analyzed in parallel, significantly faster for large workspaces.</p>
<hr />
<h2 id="integration-2"><a class="header" href="#integration-2">Integration</a></h2>
<h3 id="cicd-pipeline-2"><a class="header" href="#cicd-pipeline-2">CI/CD Pipeline</a></h3>
<pre><code class="language-yaml"># GitHub Actions
- name: Code Quality Analysis
  run: |
    bsharp analyze MySolution.sln \
      --out analysis.json \
      --format json \
      --severity MET001=error QUAL001=error
    
    # Check for errors
    errors=$(jq '.diagnostics.items | map(select(.severity == "error")) | length' analysis.json)
    if [ "$errors" -gt 0 ]; then
      echo "Quality gate failed: $errors errors"
      exit 1
    fi
</code></pre>
<h3 id="pre-commit-hook-2"><a class="header" href="#pre-commit-hook-2">Pre-commit Hook</a></h3>
<pre><code class="language-bash">#!/bin/bash
# .git/hooks/pre-commit

changed_files=$(git diff --cached --name-only --diff-filter=ACM | grep '\.cs$')

for file in $changed_files; do
    result=$(bsharp analyze "$file" --format json 2&gt;/dev/null)
    errors=$(echo "$result" | jq '.diagnostics.items | map(select(.severity == "error")) | length')
    
    if [ "$errors" -gt 0 ]; then
        echo "Analysis errors in $file"
        exit 1
    fi
done
</code></pre>
<h3 id="quality-gate-script"><a class="header" href="#quality-gate-script">Quality Gate Script</a></h3>
<pre><code class="language-bash">#!/bin/bash
# quality-gate.sh

bsharp analyze MySolution.sln \
    --out report.json \
    --format json \
    --enable-ruleset naming quality control_flow \
    --severity MET001=error QUAL001=error

# Extract metrics
errors=$(jq '.diagnostics.items | map(select(.severity == "error")) | length' report.json)
max_complexity=$(jq '.metrics.max_complexity' report.json)

echo "Errors: $errors"
echo "Max Complexity: $max_complexity"

if [ "$errors" -gt 0 ]; then
    echo "❌ Quality gate failed: $errors errors found"
    exit 1
fi

if [ "$max_complexity" -gt 15 ]; then
    echo "❌ Quality gate failed: complexity $max_complexity exceeds threshold 15"
    exit 1
fi

echo "✅ Quality gate passed"
</code></pre>
<hr />
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="analysis-fails"><a class="header" href="#analysis-fails">Analysis Fails</a></h3>
<pre><code class="language-bash">$ bsharp analyze MyProject.csproj
Error: Failed to load workspace
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Check project file is valid XML</li>
<li>Verify all referenced projects exist</li>
<li>Use <code>--follow-refs false</code> to skip references</li>
</ul>
<h3 id="out-of-memory-1"><a class="header" href="#out-of-memory-1">Out of Memory</a></h3>
<pre><code class="language-bash">Error: memory allocation failed
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Analyze smaller subsets with <code>--include</code>/<code>--exclude</code></li>
<li>Disable expensive passes with <code>--disable-pass</code></li>
<li>Increase system memory</li>
</ul>
<h3 id="slow-analysis"><a class="header" href="#slow-analysis">Slow Analysis</a></h3>
<p><strong>Solutions:</strong></p>
<ul>
<li>Build with <code>parallel_analysis</code> feature</li>
<li>Exclude unnecessary files</li>
<li>Disable unused rulesets/passes</li>
</ul>
<hr />
<h2 id="related-documentation-8"><a class="header" href="#related-documentation-8">Related Documentation</a></h2>
<ul>
<li><a href="cli/./overview.html">CLI Overview</a> - General CLI usage</li>
<li><a href="cli/../analysis/pipeline.html">Analysis Pipeline</a> - Analysis internals</li>
<li><a href="cli/../analysis/metrics.html">Metrics Collection</a> - Metrics details</li>
<li><a href="cli/../analysis/quality.html">Code Quality</a> - Quality rules</li>
<li><a href="cli/../analysis/report-schema.html">Report Schema</a> - Output JSON layout</li>
<li><a href="cli/../configuration/overview.html">Configuration Overview</a> - Config fields and examples</li>
</ul>
<hr />
<h2 id="references-11"><a class="header" href="#references-11">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/bsharp_cli/src/commands/analyze.rs</code></li>
<li><strong>Pipeline:</strong> <code>src/bsharp_analysis/src/framework/pipeline.rs</code></li>
<li><strong>Configuration:</strong> <code>src/bsharp_analysis/src/context.rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="format-command"><a class="header" href="#format-command">Format Command</a></h1>
<p>The <code>format</code> command formats C# code using the built-in formatter and syntax emitters.</p>
<hr />
<h2 id="usage-5"><a class="header" href="#usage-5">Usage</a></h2>
<pre><code class="language-bash">bsharp format &lt;INPUT&gt; [--write &lt;BOOL&gt;] [--print] [--newline-mode lf|crlf] \
  [--max-consecutive-blank-lines &lt;N&gt;] [--blank-line-between-members &lt;BOOL&gt;] \
  [--trim-trailing-whitespace &lt;BOOL&gt;] [--emit-trace] [--emit-trace-file &lt;FILE&gt;]
</code></pre>
<h3 id="arguments-3"><a class="header" href="#arguments-3">Arguments</a></h3>
<p><strong><code>&lt;INPUT&gt;</code></strong> (required)</p>
<ul>
<li>Path to <code>.cs</code> file or directory</li>
<li>When a directory is given, formats all <code>.cs</code> files recursively</li>
<li>Hidden directories and <code>bin/</code>, <code>obj/</code>, <code>target/</code> are skipped</li>
</ul>
<h3 id="options-3"><a class="header" href="#options-3">Options</a></h3>
<p><strong><code>--write, -w &lt;BOOL&gt;</code></strong></p>
<ul>
<li>Write changes to files in-place</li>
<li>Default: <code>true</code></li>
<li>When <code>false</code> and <code>&lt;INPUT&gt;</code> is a single file, the formatted content is printed to stdout</li>
<li>When <code>false</code> and formatting differences are found for multiple files, exits with code <code>2</code></li>
</ul>
<p><strong><code>--print</code></strong></p>
<ul>
<li>Always print formatted output for a single-file input and exit</li>
<li>Useful for piping to other tools; does not write to disk regardless of <code>--write</code></li>
</ul>
<p><strong><code>--newline-mode &lt;MODE&gt;</code></strong></p>
<ul>
<li>Newline mode: <code>lf</code> (default) or <code>crlf</code></li>
</ul>
<p><strong><code>--max-consecutive-blank-lines &lt;N&gt;</code></strong></p>
<ul>
<li>Maximum consecutive blank lines to keep (default: <code>1</code>)</li>
</ul>
<p><strong><code>--blank-line-between-members &lt;BOOL&gt;</code></strong></p>
<ul>
<li>Insert a blank line between type members (default: <code>true</code>)</li>
</ul>
<p><strong><code>--trim-trailing-whitespace &lt;BOOL&gt;</code></strong></p>
<ul>
<li>Trim trailing whitespace (default: <code>true</code>)</li>
</ul>
<p><strong><code>--emit-trace</code></strong></p>
<ul>
<li>Enable emission tracing (JSONL) for debugging formatter behavior</li>
<li>Can also be enabled via environment variable <code>BSHARP_EMIT_TRACE=1</code></li>
</ul>
<p><strong><code>--emit-trace-file &lt;FILE&gt;</code></strong></p>
<ul>
<li>Path to write the trace JSONL (defaults to stdout when omitted)</li>
</ul>
<hr />
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<pre><code class="language-bash"># Format a single file in-place
bsharp format Program.cs

# Print formatted output to stdout (do not write)
bsharp format Program.cs --write false

# Force printing formatted output even if --write is not set
bsharp format Program.cs --print

# Format a directory recursively
bsharp format src/

# Use CRLF newlines and avoid extra blank lines
bsharp format Program.cs --newline-mode crlf --max-consecutive-blank-lines 1

# Enable emission tracing to a file
bsharp format Program.cs --emit-trace --emit-trace-file format_trace.jsonl
</code></pre>
<hr />
<h2 id="implementation-4"><a class="header" href="#implementation-4">Implementation</a></h2>
<ul>
<li><strong>Command:</strong> <code>src/bsharp_cli/src/commands/format.rs</code></li>
<li><strong>Formatter:</strong> <code>bsharp_syntax::Formatter</code> with <code>FormatOptions</code></li>
<li>Emission tracing is controlled by CLI flags or <code>BSHARP_EMIT_TRACE</code> and recorded as JSONL.</li>
<li>Files that fail to parse are skipped; a summary is printed and they are not modified.</li>
</ul>
<hr />
<h2 id="related-documentation-9"><a class="header" href="#related-documentation-9">Related Documentation</a></h2>
<ul>
<li><a href="cli/./overview.html">CLI Overview</a></li>
<li><a href="cli/../parser/ast-structure.html">AST Structure</a></li>
<li><a href="cli/../syntax/formatter.html">Formatter Design</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parse-errors-json-output"><a class="header" href="#parse-errors-json-output">Parse Errors JSON Output</a></h1>
<p>When <code>bsharp parse</code> is run with <code>--errors-json</code>, parse failures are emitted as a single JSON object to stdout and the process exits with a non-zero code.</p>
<hr />
<h2 id="schema"><a class="header" href="#schema">Schema</a></h2>
<pre><code class="language-json">{
  "error": {
    "kind": "parse_error",
    "file": "&lt;path&gt;",
    "line": 0,
    "column": 0,
    "expected": "",
    "found": "",
    "line_text": "",
    "message": "&lt;pretty formatted message&gt;"
  }
}
</code></pre>
<ul>
<li><code>kind</code> – always <code>parse_error</code> for parse failures.</li>
<li><code>file</code> – path of the file being parsed.</li>
<li><code>line</code>, <code>column</code> – 1-based location of the deepest error span.</li>
<li><code>expected</code>, <code>found</code> – reserved fields (currently empty strings).</li>
<li><code>line_text</code> – the full source line at the error location.</li>
<li><code>message</code> – multi-line pretty message formatted from the parser's error tree.</li>
</ul>
<hr />
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><code class="language-bash">bsharp parse Invalid.cs --errors-json | jq
</code></pre>
<pre><code class="language-json">{
  "error": {
    "kind": "parse_error",
    "file": "Invalid.cs",
    "line": 7,
    "column": 12,
    "expected": "",
    "found": "",
    "line_text": "public clas Program { }",
    "message": "0: at 7:12: expected keyword \"class\"\n  public clas Program { }\n           ^\nContexts:\n  - class declaration\n"
  }
}
</code></pre>
<hr />
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li>In pretty (non-JSON) mode, errors are sent to stderr with optional ANSI colors (disable via <code>--no-color</code> or <code>NO_COLOR=1</code>).</li>
<li><code>--errors-json</code> disables pretty errors and always prints the JSON object.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-loading"><a class="header" href="#workspace-loading">Workspace Loading</a></h1>
<p>The BSharp workspace loading system provides comprehensive support for loading C# projects and solutions, including solution files (.sln), project files (.csproj), and directory-based discovery.</p>
<hr />
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p><strong>Location:</strong> <code>src/bsharp_analysis/src/workspace/</code></p>
<p>The workspace loader:</p>
<ul>
<li>Parses Visual Studio solution files (.sln)</li>
<li>Parses MSBuild project files (.csproj)</li>
<li>Discovers source files</li>
<li>Resolves project references</li>
<li>Handles multiple projects deterministically</li>
</ul>
<hr />
<h2 id="workspace-model"><a class="header" href="#workspace-model">Workspace Model</a></h2>
<h3 id="core-types-1"><a class="header" href="#core-types-1">Core Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Workspace {
    pub root: PathBuf,
    pub projects: Vec&lt;Project&gt;,
    pub solution: Option&lt;Solution&gt;,
    pub source_map: SourceMap,
}

pub struct Project {
    pub name: String,
    pub path: PathBuf,
    pub target_framework: String,
    pub output_type: String,
    pub files: Vec&lt;ProjectFile&gt;,
    pub references: Vec&lt;ProjectRef&gt;,
    pub package_references: Vec&lt;PackageReference&gt;,
    pub errors: Vec&lt;String&gt;,
}

pub struct Solution {
    pub name: String,
    pub path: PathBuf,
    pub projects: Vec&lt;SolutionProject&gt;,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="loading-workspaces"><a class="header" href="#loading-workspaces">Loading Workspaces</a></h2>
<h3 id="workspaceloader-api"><a class="header" href="#workspaceloader-api">WorkspaceLoader API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WorkspaceLoader;

impl WorkspaceLoader {
    // Load from any path (auto-detects type)
    pub fn from_path(path: &amp;Path) -&gt; Result&lt;Workspace&gt;;
    
    // Load with options
    pub fn from_path_with_options(
        path: &amp;Path, 
        opts: WorkspaceLoadOptions
    ) -&gt; Result&lt;Workspace&gt;;
}

pub struct WorkspaceLoadOptions {
    pub follow_refs: bool,  // Follow ProjectReference transitively
}
<span class="boring">}</span></code></pre></pre>
<h3 id="loading-from-solution-file"><a class="header" href="#loading-from-solution-file">Loading from Solution File</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::workspace::WorkspaceLoader;

let workspace = WorkspaceLoader::from_path(Path::new("MySolution.sln"))?;

println!("Loaded {} projects", workspace.projects.len());
for project in &amp;workspace.projects {
    println!("  - {}: {} files", project.name, project.files.len());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="loading-from-project-file"><a class="header" href="#loading-from-project-file">Loading from Project File</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let workspace = WorkspaceLoader::from_path(Path::new("MyProject.csproj"))?;

// Automatically follows ProjectReference if follow_refs = true
assert!(workspace.projects.len() &gt;= 1);
<span class="boring">}</span></code></pre></pre>
<h3 id="loading-from-directory"><a class="header" href="#loading-from-directory">Loading from Directory</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let workspace = WorkspaceLoader::from_path(Path::new("./src"))?;

// Discovers .sln or .csproj files in directory
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="solution-file-parsing"><a class="header" href="#solution-file-parsing">Solution File Parsing</a></h2>
<h3 id="solution-format"><a class="header" href="#solution-format">Solution Format</a></h3>
<p><strong>Example .sln:</strong></p>
<pre><code>Microsoft Visual Studio Solution File, Format Version 12.00
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MyApp", "MyApp\MyApp.csproj", "{GUID}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MyLib", "MyLib\MyLib.csproj", "{GUID}"
EndProject
</code></pre>
<h3 id="parsing-implementation"><a class="header" href="#parsing-implementation">Parsing Implementation</a></h3>
<p><strong>Location:</strong> <code>src/bsharp_analysis/src/workspace/sln/reader.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SolutionReader;

impl SolutionReader {
    pub fn read(path: &amp;Path) -&gt; Result&lt;Solution&gt; {
        let content = fs::read_to_string(path)?;
        Self::parse(&amp;content, path)
    }
    
    fn parse(content: &amp;str, base_path: &amp;Path) -&gt; Result&lt;Solution&gt; {
        // Parse solution format
        // Extract project entries
        // Resolve project paths
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="solution-structure"><a class="header" href="#solution-structure">Solution Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Solution {
    pub name: String,
    pub path: PathBuf,
    pub projects: Vec&lt;SolutionProject&gt;,
}

pub struct SolutionProject {
    pub name: String,
    pub path: PathBuf,
    pub type_guid: String,
    pub guid: String,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="project-file-parsing"><a class="header" href="#project-file-parsing">Project File Parsing</a></h2>
<h3 id="project-format"><a class="header" href="#project-format">Project Format</a></h3>
<p><strong>Example .csproj:</strong></p>
<pre><code class="language-xml">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
  &lt;/PropertyGroup&gt;
  
  &lt;ItemGroup&gt;
    &lt;Compile Include="Program.cs" /&gt;
    &lt;Compile Include="Utils.cs" /&gt;
  &lt;/ItemGroup&gt;
  
  &lt;ItemGroup&gt;
    &lt;ProjectReference Include="..\MyLib\MyLib.csproj" /&gt;
  &lt;/ItemGroup&gt;
  
  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Newtonsoft.Json" Version="13.0.1" /&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<h3 id="parsing-implementation-1"><a class="header" href="#parsing-implementation-1">Parsing Implementation</a></h3>
<p><strong>Location:</strong> <code>src/bsharp_analysis/src/workspace/csproj/reader.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CsprojReader;

impl CsprojReader {
    pub fn read(path: &amp;Path) -&gt; Result&lt;Project&gt; {
        let content = fs::read_to_string(path)?;
        Self::parse(&amp;content, path)
    }
    
    fn parse(content: &amp;str, project_path: &amp;Path) -&gt; Result&lt;Project&gt; {
        // Parse XML
        // Extract properties (TargetFramework, OutputType)
        // Discover source files (Compile items)
        // Extract ProjectReference entries
        // Extract PackageReference entries
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="source-file-discovery"><a class="header" href="#source-file-discovery">Source File Discovery</a></h3>
<p><strong>Glob Patterns:</strong></p>
<ul>
<li>Default: <code>**/*.cs</code> (all C# files recursively)</li>
<li>Respects <code>&lt;Compile Include="..." /&gt;</code> items</li>
<li>Respects <code>&lt;Compile Remove="..." /&gt;</code> exclusions</li>
<li>Excludes <code>obj/</code> and <code>bin/</code> directories</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn discover_source_files(project_dir: &amp;Path) -&gt; Vec&lt;ProjectFile&gt; {
    let pattern = project_dir.join("**/*.cs");
    let mut files = Vec::new();
    
    for entry in glob::glob(pattern.to_str().unwrap()) {
        let path = entry.unwrap();
        
        // Skip obj/ and bin/
        if path.components().any(|c| c.as_os_str() == "obj" || c.as_os_str() == "bin") {
            continue;
        }
        
        files.push(ProjectFile {
            path,
            kind: ProjectFileKind::Compile,
        });
    }
    
    files
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="project-references"><a class="header" href="#project-references">Project References</a></h2>
<h3 id="transitive-resolution"><a class="header" href="#transitive-resolution">Transitive Resolution</a></h3>
<p><strong>follow_refs Option:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let opts = WorkspaceLoadOptions { follow_refs: true };
let workspace = WorkspaceLoader::from_path_with_options(path, opts)?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Behavior:</strong></p>
<ul>
<li>Follows <code>&lt;ProjectReference&gt;</code> transitively</li>
<li>Loads all referenced projects</li>
<li>Avoids duplicates</li>
<li>Stays within workspace root</li>
<li>Deterministic ordering (sorted by path)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code>MyApp.csproj
  → MyLib.csproj
    → MyCore.csproj

Result: [MyApp, MyLib, MyCore]
</code></pre>
<h3 id="implementation-5"><a class="header" href="#implementation-5">Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn follow_project_references(root: &amp;Path, projects: &amp;mut Vec&lt;Project&gt;) {
    let mut seen = HashSet::new();
    let mut queue = VecDeque::new();
    
    // Add initial projects
    for proj in projects.iter() {
        seen.insert(proj.path.clone());
        queue.push_back(proj.path.clone());
    }
    
    // BFS traversal
    while let Some(proj_path) = queue.pop_front() {
        let proj = match CsprojReader::read(&amp;proj_path) {
            Ok(p) =&gt; p,
            Err(_) =&gt; continue,
        };
        
        for ref_path in proj.references.iter().map(|r| &amp;r.path) {
            // Resolve relative to project directory
            let abs_path = proj_path.parent().unwrap().join(ref_path);
            
            // Skip if outside root
            if !abs_path.starts_with(root) {
                continue;
            }
            
            // Skip if already seen
            if seen.insert(abs_path.clone()) {
                queue.push_back(abs_path.clone());
                
                // Load and add project
                if let Ok(referenced_proj) = CsprojReader::read(&amp;abs_path) {
                    projects.push(referenced_proj);
                }
            }
        }
    }
    
    // Sort for determinism
    projects.sort_by(|a, b| a.path.cmp(&amp;b.path));
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="source-map"><a class="header" href="#source-map">Source Map</a></h2>
<h3 id="purpose"><a class="header" href="#purpose">Purpose</a></h3>
<p>The <code>SourceMap</code> provides fast lookup of source files:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SourceMap {
    files: HashMap&lt;PathBuf, SourceFileInfo&gt;,
}

impl SourceMap {
    pub fn get(&amp;self, path: &amp;Path) -&gt; Option&lt;&amp;SourceFileInfo&gt;;
    pub fn all_files(&amp;self) -&gt; Vec&lt;&amp;Path&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="usage-6"><a class="header" href="#usage-6">Usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let workspace = WorkspaceLoader::from_path(path)?;

// Look up file
if let Some(info) = workspace.source_map.get(Path::new("Program.cs")) {
    println!("Found in project: {}", info.project_name);
}

// Iterate all files
for file_path in workspace.source_map.all_files() {
    println!("File: {}", file_path.display());
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="error-handling-7"><a class="header" href="#error-handling-7">Error Handling</a></h2>
<h3 id="resilient-loading"><a class="header" href="#resilient-loading">Resilient Loading</a></h3>
<p><strong>Philosophy:</strong> Continue loading even if individual projects fail</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Failed projects recorded as stubs with errors
let workspace = WorkspaceLoader::from_path(sln_path)?;

for project in &amp;workspace.projects {
    if !project.errors.is_empty() {
        eprintln!("Errors in {}: {:?}", project.name, project.errors);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-types-1"><a class="header" href="#error-types-1">Error Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum WorkspaceError {
    IoError(io::Error),
    ParseError(String),
    InvalidPath(String),
    Unsupported(String),
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="cli-integration-1"><a class="header" href="#cli-integration-1">CLI Integration</a></h2>
<h3 id="analyze-command-1"><a class="header" href="#analyze-command-1">Analyze Command</a></h3>
<pre><code class="language-bash"># Analyze solution
bsharp analyze MySolution.sln

# Analyze project
bsharp analyze MyProject.csproj

# Follow references (default: true)
bsharp analyze MyProject.csproj --follow-refs true

# Don't follow references
bsharp analyze MyProject.csproj --follow-refs false
</code></pre>
<h3 id="filtering-1"><a class="header" href="#filtering-1">Filtering</a></h3>
<pre><code class="language-bash"># Include only specific files
bsharp analyze MySolution.sln --include "**/*Service.cs"

# Exclude test files
bsharp analyze MySolution.sln --exclude "**/Tests/**"

# Multiple patterns
bsharp analyze MySolution.sln \
    --include "src/**/*.cs" \
    --exclude "**/obj/**" "**/bin/**"
</code></pre>
<hr />
<h2 id="deterministic-behavior"><a class="header" href="#deterministic-behavior">Deterministic Behavior</a></h2>
<h3 id="guarantees"><a class="header" href="#guarantees">Guarantees</a></h3>
<ol>
<li><strong>Project Order:</strong> Always sorted by absolute path</li>
<li><strong>File Order:</strong> Always sorted within each project</li>
<li><strong>Deduplication:</strong> No duplicate projects or files</li>
<li><strong>Reproducible:</strong> Same input always produces same output</li>
</ol>
<h3 id="implementation-6"><a class="header" href="#implementation-6">Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sort projects
projects.sort_by(|a, b| a.path.cmp(&amp;b.path));

// Deduplicate by path
let mut seen = HashSet::new();
projects.retain(|p| seen.insert(p.path.clone()));

// Sort files within each project
for project in &amp;mut projects {
    project.files.sort_by(|a, b| a.path.cmp(&amp;b.path));
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="performance-3"><a class="header" href="#performance-3">Performance</a></h2>
<h3 id="loading-speed"><a class="header" href="#loading-speed">Loading Speed</a></h3>
<ul>
<li><strong>Small solution</strong> (1-5 projects): &lt; 100ms</li>
<li><strong>Medium solution</strong> (5-20 projects): 100-500ms</li>
<li><strong>Large solution</strong> (20-100 projects): 500ms-2s</li>
</ul>
<h3 id="memory-usage-3"><a class="header" href="#memory-usage-3">Memory Usage</a></h3>
<ul>
<li>Minimal: Only metadata loaded, not source content</li>
<li>Typical: 1-5 MB per solution</li>
</ul>
<h3 id="optimization"><a class="header" href="#optimization">Optimization</a></h3>
<ul>
<li>Parallel project loading (with <code>parallel_analysis</code> feature)</li>
<li>Lazy source file reading</li>
<li>Efficient path canonicalization</li>
</ul>
<hr />
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<h3 id="example-1-load-and-analyze"><a class="header" href="#example-1-load-and-analyze">Example 1: Load and Analyze</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::workspace::WorkspaceLoader;
use bsharp_parser::facade::Parser;

let workspace = WorkspaceLoader::from_path(Path::new("MySolution.sln"))?;

let parser = Parser::new();
for project in &amp;workspace.projects {
    for file in &amp;project.files {
        let source = fs::read_to_string(&amp;file.path)?;
        match parser.parse(&amp;source) {
            Ok(cu) =&gt; println!("Parsed: {}", file.path.display()),
            Err(e) =&gt; eprintln!("Error in {}: {}", file.path.display(), e),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-2-project-statistics"><a class="header" href="#example-2-project-statistics">Example 2: Project Statistics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let workspace = WorkspaceLoader::from_path(path)?;

println!("Solution: {}", workspace.solution.as_ref().unwrap().name);
println!("Projects: {}", workspace.projects.len());

let total_files: usize = workspace.projects.iter()
    .map(|p| p.files.len())
    .sum();
println!("Total files: {}", total_files);

for project in &amp;workspace.projects {
    println!("  {}: {} files", project.name, project.files.len());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-3-dependency-graph"><a class="header" href="#example-3-dependency-graph">Example 3: Dependency Graph</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let workspace = WorkspaceLoader::from_path(path)?;

println!("Project Dependencies:");
for project in &amp;workspace.projects {
    if !project.references.is_empty() {
        println!("{}:", project.name);
        for ref_ in &amp;project.references {
            println!("  → {}", ref_.name);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<h3 id="test-fixtures-1"><a class="header" href="#test-fixtures-1">Test Fixtures</a></h3>
<p><strong>Location:</strong> <code>tests/fixtures/</code></p>
<pre><code>tests/fixtures/
├── happy_path/
│   ├── test.sln
│   ├── testApplication/
│   │   ├── testApplication.csproj
│   │   └── Program.cs
│   └── testDependency/
│       ├── testDependency.csproj
│       └── Library.cs
└── complex/
    └── ...
</code></pre>
<h3 id="test-examples"><a class="header" href="#test-examples">Test Examples</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_load_solution() {
    let sln_path = PathBuf::from("tests/fixtures/happy_path/test.sln");
    let workspace = WorkspaceLoader::from_path(&amp;sln_path).unwrap();
    
    assert_eq!(workspace.projects.len(), 2);
    assert!(workspace.solution.is_some());
}

#[test]
fn test_follow_references() {
    let proj_path = PathBuf::from("tests/fixtures/happy_path/testApplication/testApplication.csproj");
    let workspace = WorkspaceLoader::from_path(&amp;proj_path).unwrap();
    
    // Should load both testApplication and testDependency
    assert_eq!(workspace.projects.len(), 2);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="future-enhancements-5"><a class="header" href="#future-enhancements-5">Future Enhancements</a></h2>
<h3 id="planned-features-4"><a class="header" href="#planned-features-4">Planned Features</a></h3>
<ol>
<li>
<p><strong>NuGet Package Resolution</strong></p>
<ul>
<li>Resolve package references</li>
<li>Download packages if needed</li>
<li>Parse package assemblies</li>
</ul>
</li>
<li>
<p><strong>MSBuild Integration</strong></p>
<ul>
<li>Full MSBuild evaluation</li>
<li>Property expansion</li>
<li>Target execution</li>
</ul>
</li>
<li>
<p><strong>Multi-targeting Support</strong></p>
<ul>
<li>Handle multiple target frameworks</li>
<li>Conditional compilation</li>
</ul>
</li>
<li>
<p><strong>Incremental Loading</strong></p>
<ul>
<li>Cache workspace metadata</li>
<li>Reload only changed projects</li>
</ul>
</li>
</ol>
<hr />
<h2 id="related-documentation-10"><a class="header" href="#related-documentation-10">Related Documentation</a></h2>
<ul>
<li><a href="workspace/../cli/overview.html">CLI Overview</a> - CLI integration</li>
<li><a href="workspace/../analysis/pipeline.html">Analysis Pipeline</a> - Using workspace in analysis</li>
<li><a href="workspace/../development/architecture.html">Architecture</a> - Design decisions</li>
</ul>
<hr />
<h2 id="references-12"><a class="header" href="#references-12">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/bsharp_analysis/src/workspace/</code></li>
<li><strong>Loader:</strong> <code>src/bsharp_analysis/src/workspace/loader.rs</code></li>
<li><strong>Solution Reader:</strong> <code>src/bsharp_analysis/src/workspace/sln/reader.rs</code></li>
<li><strong>Project Reader:</strong> <code>src/bsharp_analysis/src/workspace/csproj/reader.rs</code></li>
<li><strong>Model:</strong> <code>src/bsharp_analysis/src/workspace/model.rs</code></li>
<li><strong>Source Map:</strong> <code>src/bsharp_analysis/src/workspace/source_map.rs</code></li>
<li><strong>Tests:</strong> <code>src/bsharp_tests/src/workspace/</code> and <code>src/bsharp_tests/src/integration/</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-overview"><a class="header" href="#configuration-overview">Configuration Overview</a></h1>
<p>BSharp analysis can be configured via TOML or JSON files and by CLI flags that map to config fields.</p>
<hr />
<h2 id="locations"><a class="header" href="#locations">Locations</a></h2>
<ul>
<li>Project root: <code>.bsharp.toml</code> or <code>.bsharp.json</code></li>
<li>Custom path via <code>bsharp analyze &lt;INPUT&gt; --config &lt;FILE&gt;</code></li>
</ul>
<hr />
<h2 id="analysisconfig-fields"><a class="header" href="#analysisconfig-fields">AnalysisConfig (fields)</a></h2>
<p>Source: <code>src/bsharp_analysis/src/context.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AnalysisConfig {
    // Control flow thresholds
    pub cf_high_complexity_threshold: usize, // default: 10
    pub cf_deep_nesting_threshold: usize,    // default: 4

    // Toggles and severities
    pub enable_rulesets: HashMap&lt;String, bool&gt;,
    pub enable_passes: HashMap&lt;String, bool&gt;,
    pub rule_severities: HashMap&lt;String, DiagnosticSeverity&gt;,

    // Workspace filters
    pub workspace: WorkspaceConfig,

    // Optional churn/PE settings (reserved/future)
    pub churn_enable: bool,
    pub churn_period_days: u32,
    pub churn_include_merges: bool,
    pub churn_max_commits: Option&lt;u32&gt;,
    pub pe_reference_paths: Vec&lt;String&gt;,
    pub pe_references: Vec&lt;String&gt;,
}

pub struct WorkspaceConfig {
    pub follow_refs: bool,
    pub include: Vec&lt;String&gt;,
    pub exclude: Vec&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="toml-example"><a class="header" href="#toml-example">TOML Example</a></h2>
<pre><code class="language-toml">[analysis]
cf_high_complexity_threshold = 10
cf_deep_nesting_threshold = 4

[enable_rulesets]
naming = true
semantic = true
control_flow_smells = true

[enable_passes]
passes.metrics = true
passes.control_flow = true
passes.dependencies = true

[rule_severities]
CF002 = "warning"
CF003 = "warning"

[workspace]
follow_refs = true
include = ["src/**/*.cs"]
exclude = ["**/obj/**", "**/bin/**"]
</code></pre>
<h2 id="json-example"><a class="header" href="#json-example">JSON Example</a></h2>
<pre><code class="language-json">{
  "cf_high_complexity_threshold": 10,
  "cf_deep_nesting_threshold": 4,
  "enable_rulesets": {
    "naming": true,
    "semantic": true,
    "control_flow_smells": true
  },
  "enable_passes": {
    "passes.metrics": true,
    "passes.control_flow": true,
    "passes.dependencies": true
  },
  "rule_severities": {
    "CF002": "warning",
    "CF003": "warning"
  },
  "workspace": {
    "follow_refs": true,
    "include": ["src/**/*.cs"],
    "exclude": ["**/obj/**", "**/bin/**"]
  }
}
</code></pre>
<hr />
<h2 id="cli-mapping"><a class="header" href="#cli-mapping">CLI Mapping</a></h2>
<ul>
<li><code>--enable-ruleset &lt;ID&gt;</code> / <code>--disable-ruleset &lt;ID&gt;</code> → <code>enable_rulesets[ID] = true|false</code></li>
<li><code>--enable-pass &lt;ID&gt;</code> / <code>--disable-pass &lt;ID&gt;</code> → <code>enable_passes[ID] = true|false</code></li>
<li><code>--severity CODE=level</code> → <code>rule_severities[CODE] = level</code> (<code>error|warning|info|hint</code>)</li>
<li><code>--follow-refs &lt;BOOL&gt;</code> → <code>workspace.follow_refs</code></li>
<li><code>--include &lt;GLOB&gt;...</code> → <code>workspace.include</code></li>
<li><code>--exclude &lt;GLOB&gt;...</code> → <code>workspace.exclude</code></li>
</ul>
<hr />
<h2 id="tips-3"><a class="header" href="#tips-3">Tips</a></h2>
<ul>
<li>Prefer TOML for readability; JSON is supported for tool integration.</li>
<li>Thresholds influence <code>CfgSummary</code> counts in the final report.</li>
<li>Use unique IDs for passes/rulesets consistent with registry (see Passes &amp; Rules).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-bsharp"><a class="header" href="#contributing-to-bsharp">Contributing to BSharp</a></h1>
<p>Thank you for your interest in contributing to BSharp! This document provides guidelines for contributing to the project.</p>
<h2 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h2>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ul>
<li>Rust 1.70 or later</li>
<li>Git</li>
<li>A text editor or IDE with Rust support</li>
</ul>
<h3 id="building-the-project"><a class="header" href="#building-the-project">Building the Project</a></h3>
<ol>
<li>Clone the repository:</li>
</ol>
<pre><code class="language-bash">git clone https://github.com/mikserek/bsharp.git
cd bsharp
</code></pre>
<h4 id="parser-testing-best-practices"><a class="header" href="#parser-testing-best-practices">Parser Testing Best Practices</a></h4>
<ul>
<li>Prefer <code>expect_ok(input, parse(input.into()))</code> from <code>syntax::test_helpers</code> when asserting successful parses. It prints readable, rustc-like diagnostics on failure via <code>format_error_tree</code>.</li>
<li>Keep tests focused and minimal; add a separate negative test when ambiguity is possible (e.g., ternary vs <code>?.</code> vs <code>??</code>, range vs dot vs float).</li>
<li>For lookahead/disambiguation boundaries, add cases to <code>tests/parser/expressions/lookahead_boundaries2_tests.rs</code>.</li>
<li>For complex constructs (e.g., <code>new</code> with object/collection initializers), add positive and negative cases near <code>tests/parser/expressions/new_expression_tests.rs</code> and <code>target_typed_new_tests.rs</code>.</li>
<li>Invalid-input diagnostics: place small snapshot-style assertions in <code>tests/parser/expressions/invalid_diagnostics_tests.rs</code> that check for line/column and caret presence. Avoid overfitting on exact wording.</li>
<li>When adding delimited constructs (parentheses, brackets, braces), guard the closing delimiter with <code>cut(...)</code> once committed to that branch to prevent misleading backtracking.</li>
<li>Always wrap sub-parsers with <code>bws(...)</code> to ensure whitespace/comments are handled consistently.</li>
</ul>
<h4 id="adding-new-parser-test-files"><a class="header" href="#adding-new-parser-test-files">Adding New Parser Test Files</a></h4>
<ul>
<li>In <code>tests/parser/expressions/</code>, simply add a new <code>*_tests.rs</code> file; it will be discovered by the existing integration test harness.</li>
<li>For declarations/statements/types, follow the existing directory structure under <code>tests/parser/</code> and mimic module organization.</li>
<li>Keep tests deterministic and avoid relying on environment-specific paths or random data.</li>
</ul>
<ol start="2">
<li>Build the project:</li>
</ol>
<pre><code class="language-bash">cargo build
</code></pre>
<ol start="3">
<li>Run tests:</li>
</ol>
<pre><code class="language-bash">cargo test
</code></pre>
<ol start="4">
<li>Run the CLI tool:</li>
</ol>
<pre><code class="language-bash">cargo run -- --help
</code></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>Understanding the codebase organization:</p>
<pre><code>src/
├── parser/           # Parser implementations (expressions, statements, etc.)
├── syntax/           # Parser infrastructure (AST nodes, helpers, errors)
├── analysis/         # Code analysis framework
├── workspace/        # Solution and project file loading
├── cli/              # Command-line interface
└── lib.rs           # Library entry point
</code></pre>
<h3 id="code-style"><a class="header" href="#code-style">Code Style</a></h3>
<p>Follow Rust conventions:</p>
<ul>
<li>Use <code>cargo fmt</code> to format code</li>
<li>Use <code>cargo clippy</code> to check for common issues</li>
<li>Follow naming conventions (<code>snake_case</code> for functions, <code>PascalCase</code> for types)</li>
<li>Add documentation comments for public APIs</li>
</ul>
<h3 id="testing-1"><a class="header" href="#testing-1">Testing</a></h3>
<p>All contributions should include appropriate tests:</p>
<h4 id="parser-tests"><a class="header" href="#parser-tests">Parser Tests</a></h4>
<p><strong>IMPORTANT:</strong> Parser tests must live in an external test crate under <code>src/bsharp_tests/src/</code>, NOT inline <code>#[cfg(test)]</code> modules.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ CORRECT: External test file
// tests/parser/declarations/class_declaration_tests.rs

use bsharp::syntax::test_helpers::expect_ok;
use bsharp::parser::expressions::declarations::parse_class_declaration;

#[test]
fn test_parse_simple_class() {
    let input = "public class MyClass { }";
    let class = expect_ok(input, parse_class_declaration(input.into()));
    assert_eq!(class.identifier.name, "MyClass");
}
<span class="boring">}</span></code></pre></pre>
<h4 id="analysis-tests"><a class="header" href="#analysis-tests">Analysis Tests</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/analysis/complexity_tests.rs

use bsharp::syntax::Parser;
use bsharp::analysis::metrics::cyclomatic_complexity;

#[test]
fn test_complexity_analysis() {
    let source = r#"
        public class Test {
            public void Method() {
                if (true) {
                    for (int i = 0; i &lt; 10; i++) {
                        // complexity += 2
                    }
                }
            }
        }
    "#;
    
    let parser = Parser::new();
    let cu = parser.parse(source).unwrap();
    
    // Find the method and calculate complexity
    // (implementation details depend on analysis API)
    
    assert_eq!(complexity, 3);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<ul>
<li>Add rustdoc comments for public functions and types</li>
<li>Update this documentation when adding new features</li>
<li>Include examples in documentation</li>
</ul>
<h3 id="adding-new-language-features"><a class="header" href="#adding-new-language-features">Adding New Language Features</a></h3>
<p>When adding support for new C# language features:</p>
<ol>
<li><strong>Define AST Nodes</strong>: Add node definitions in <code>src/syntax/nodes/</code></li>
<li><strong>Implement Parser</strong>: Add parser in appropriate <code>src/parser/</code> subdirectory</li>
<li><strong>Add Tests</strong>: Include comprehensive tests in <code>tests/parser/</code> directory</li>
<li><strong>Update Traversal</strong>: Prefer the <code>bsharp_analysis::framework::Query</code> API for AST enumeration; for statement/expression-heavy logic, use shared helpers or a focused walker.</li>
<li><strong>Document</strong>: Add documentation for the new feature</li>
</ol>
<p>Example process for adding a new expression type:</p>
<ol>
<li>Define the AST node:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/syntax/nodes/expressions/new_expression.rs
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct NewExpression {
    pub keyword: String,  // "new"
    pub arguments: Vec&lt;Expression&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Add to Expression enum:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/syntax/nodes/expressions/expression.rs
pub enum Expression {
    // ... existing variants
    New(NewExpression),
}
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li>Implement parser:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/parser/expressions/new_expression_parser.rs
pub fn parse_new_expression(input: &amp;str) -&gt; BResult&lt;&amp;str, NewExpression&gt; {
    // Parser implementation
}
<span class="boring">}</span></code></pre></pre>
<ol start="4">
<li>Add tests:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/parser/expressions/new_expression_tests.rs
#[test]
fn test_parse_new_expression() {
    // Test implementation
}
<span class="boring">}</span></code></pre></pre>
<h2 id="submitting-changes"><a class="header" href="#submitting-changes">Submitting Changes</a></h2>
<h3 id="pull-request-process"><a class="header" href="#pull-request-process">Pull Request Process</a></h3>
<ol>
<li>Fork the repository</li>
<li>Create a feature branch: <code>git checkout -b feature/new-feature</code></li>
<li>Make your changes</li>
<li>Run tests: <code>cargo test</code></li>
<li>Run formatting: <code>cargo fmt</code></li>
<li>Run clippy: <code>cargo clippy</code></li>
<li>Commit changes with clear messages</li>
<li>Push to your fork</li>
<li>Create a pull request</li>
</ol>
<h3 id="commit-messages"><a class="header" href="#commit-messages">Commit Messages</a></h3>
<p>Use clear, descriptive commit messages:</p>
<pre><code>feat: add support for C# 11 file-scoped types

- Add parser for file-scoped type declarations
- Update AST to handle new syntax
- Add comprehensive tests
- Update documentation

Fixes #123
</code></pre>
<h3 id="pull-request-requirements"><a class="header" href="#pull-request-requirements">Pull Request Requirements</a></h3>
<ul>
<li>All tests must pass</li>
<li>Code must be formatted with <code>cargo fmt</code></li>
<li>No clippy warnings</li>
<li>Include tests for new functionality</li>
<li>Update documentation if needed</li>
</ul>
<h2 id="common-development-tasks"><a class="header" href="#common-development-tasks">Common Development Tasks</a></h2>
<h3 id="adding-a-new-parser"><a class="header" href="#adding-a-new-parser">Adding a New Parser</a></h3>
<ol>
<li>Define the AST node structure</li>
<li>Implement the parser function</li>
<li>Add the parser to the appropriate module</li>
<li>Write comprehensive tests</li>
<li>Update integration points</li>
</ol>
<h3 id="extending-analysis"><a class="header" href="#extending-analysis">Extending Analysis</a></h3>
<ol>
<li>Define analysis traits if needed</li>
<li>Implement analyzer struct</li>
<li>Add configuration options</li>
<li>Write tests with various scenarios</li>
<li>Update CLI integration</li>
</ol>
<h3 id="debugging-parser-issues"><a class="header" href="#debugging-parser-issues">Debugging Parser Issues</a></h3>
<p>Use these tools for debugging:</p>
<pre><code class="language-bash"># Test specific parser with debug output
RUST_LOG=debug cargo test test_name -- --nocapture

# Run parser on test file (prints textual AST tree)
cargo run -- parse debug_cases/test.cs

# Check AST visualization
cargo run -- tree debug_cases/test.cs --output debug.svg
</code></pre>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li>Check existing issues and documentation</li>
<li>Ask questions in GitHub issues</li>
<li>Join community discussions</li>
</ul>
<h2 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h2>
<ul>
<li>Be respectful and inclusive</li>
<li>Focus on constructive feedback</li>
<li>Help others learn and grow</li>
<li>Maintain a positive environment</li>
</ul>
<p>Thank you for contributing to BSharp!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-guide"><a class="header" href="#testing-guide">Testing Guide</a></h1>
<p>This document provides comprehensive guidance on testing in the BSharp project, covering test organization, best practices, and debugging strategies.</p>
<hr />
<h2 id="test-organization-philosophy"><a class="header" href="#test-organization-philosophy">Test Organization Philosophy</a></h2>
<h3 id="external-test-structure"><a class="header" href="#external-test-structure">External Test Structure</a></h3>
<p><strong>Critical Principle:</strong> Parser tests are external to implementation modules and live in a dedicated test crate.</p>
<pre><code>src/bsharp_tests/
├── cargo.toml               # Test crate manifest
└── src/
    ├── parser/
    │   ├── expressions/
    │   │   ├── expression_tests.rs
    │   │   ├── lambda_expression_tests.rs
    │   │   ├── pattern_matching_tests.rs
    │   │   ├── ambiguity_tests.rs
    │   │   ├── lookahead_boundaries2_tests.rs
    │   │   └── ...
    │   ├── statements/
    │   │   ├── if_statement_tests.rs
    │   │   ├── for_statement_tests.rs
    │   │   ├── expression_statement_tests.rs
    │   │   └── ...
    │   ├── declarations/
    │   │   ├── class_declaration_tests.rs
    │   │   ├── interface_declaration_parser_tests.rs
    │   │   ├── recovery_tests.rs
    │   │   └── ...
    │   ├── types/
    │   │   ├── type_tests.rs
    │   │   ├── advanced_type_tests.rs
    │   │   └── ...
    │   ├── preprocessor/
    │   │   └── ...
    │   └── keyword_parsers_tests.rs
    └── fixtures/
        ├── happy_path/
        └── complex/
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Separation of Concerns</strong>: Test code separate from implementation</li>
<li><strong>Compilation Efficiency</strong>: Tests don't bloat production binary</li>
<li><strong>Organization</strong>: Clear structure mirrors parser organization</li>
<li><strong>Maintainability</strong>: Easy to find and update tests</li>
</ul>
<p><strong>What NOT to Do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ NEVER do this in src/parser/ files
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_something() {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>What to Do Instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Create tests/parser/expressions/my_feature_tests.rs
use bsharp::syntax::test_helpers::expect_ok;
use bsharp::parser::expressions::parse_my_feature;

#[test]
fn test_my_feature() {
    let input = "my feature syntax";
    let result = parse_my_feature(input.into());
    let ast = expect_ok(input, result);
    // assertions...
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="test-helpers"><a class="header" href="#test-helpers">Test Helpers</a></h2>
<h3 id="expect_ok---readable-test-failures"><a class="header" href="#expect_ok---readable-test-failures"><code>expect_ok()</code> - Readable Test Failures</a></h3>
<p><strong>Location:</strong> <code>src/syntax/test_helpers.rs</code></p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::syntax::test_helpers::expect_ok;

#[test]
fn test_parse_class() {
    let input = "public class MyClass { }";
    let result = parse_class_declaration(input.into());
    let class = expect_ok(input, result);
    
    assert_eq!(class.identifier.name, "MyClass");
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li><strong>Automatic Error Formatting</strong>: Pretty-prints <code>ErrorTree</code> on failure</li>
<li><strong>Readable Diagnostics</strong>: Shows parse failure context with caret</li>
<li><strong>Panic on Failure</strong>: Test fails with clear error message</li>
</ul>
<p><strong>Error Output Example:</strong></p>
<pre><code>0: at line 1, in keyword "class":
public clas MyClass { }
       ^--- expected keyword "class"

1: in context "class declaration"
</code></pre>
<h3 id="other-test-helpers"><a class="header" href="#other-test-helpers">Other Test Helpers</a></h3>
<p><strong><code>parse_input_unwrap()</code></strong> - Unwrap parse result:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (remaining, ast) = parse_input_unwrap(parse_expression(input.into()));
assert_eq!(remaining, "");  // Verify full consumption
<span class="boring">}</span></code></pre></pre>
<p><strong><code>assert_parse_error()</code></strong> - Verify parse failures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_parse_error(parse_expression("invalid syntax"));
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="parser-testing-best-practices-1"><a class="header" href="#parser-testing-best-practices-1">Parser Testing Best Practices</a></h2>
<h3 id="1-prefer-expect_ok-for-successful-parses"><a class="header" href="#1-prefer-expect_ok-for-successful-parses">1. Prefer <code>expect_ok()</code> for Successful Parses</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_if_statement() {
    let input = "if (x &gt; 0) { return x; }";
    let stmt = expect_ok(input, parse_if_statement(input.into()));
    
    // Now assert on the AST structure
    match stmt {
        Statement::If(if_stmt) =&gt; {
            // Verify condition, consequence, etc.
        }
        _ =&gt; panic!("Expected IfStatement"),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-keep-tests-focused-and-minimal"><a class="header" href="#2-keep-tests-focused-and-minimal">2. Keep Tests Focused and Minimal</a></h3>
<p><strong>Good:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_simple_lambda() {
    let input = "x =&gt; x * 2";
    let expr = expect_ok(input, parse_lambda_expression(input.into()));
    // Test one thing
}

#[test]
fn test_lambda_with_multiple_params() {
    let input = "(x, y) =&gt; x + y";
    let expr = expect_ok(input, parse_lambda_expression(input.into()));
    // Test another thing
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Bad:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_all_lambda_forms() {
    // Testing too many things in one test
    // Hard to debug when it fails
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-add-negative-tests-for-ambiguity"><a class="header" href="#3-add-negative-tests-for-ambiguity">3. Add Negative Tests for Ambiguity</a></h3>
<p>When disambiguation is possible, add tests for both valid and invalid cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_ternary_vs_nullable() {
    // Valid ternary
    let input = "x ? y : z";
    expect_ok(input, parse_conditional_expression(input.into()));
    
    // Valid null-conditional (different test)
}

#[test]
fn test_null_conditional_operator() {
    let input = "obj?.Property";
    expect_ok(input, parse_postfix_expression(input.into()));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-test-lookaheaddisambiguation-boundaries"><a class="header" href="#4-test-lookaheaddisambiguation-boundaries">4. Test Lookahead/Disambiguation Boundaries</a></h3>
<p><strong>Location:</strong> <code>tests/parser/expressions/lookahead_boundaries2_tests.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_range_vs_dot_vs_float() {
    // Range operator
    expect_ok("1..10", parse_range_expression("1..10"));
    
    // Member access
    expect_ok("obj.Method", parse_postfix_expression("obj.Method"));
    
    // Float literal
    expect_ok("3.14", parse_literal("3.14"));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-test-complex-constructs"><a class="header" href="#5-test-complex-constructs">5. Test Complex Constructs</a></h3>
<p>For complex constructs like <code>new</code> expressions with initializers:</p>
<p><strong>Location:</strong> <code>tests/parser/expressions/new_expression_tests.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_new_with_object_initializer() {
    let input = "new Person { Name = \"John\", Age = 30 }";
    let expr = expect_ok(input, parse_new_expression(input.into()));
    // Verify structure
}

#[test]
fn test_new_with_collection_initializer() {
    let input = "new List&lt;int&gt; { 1, 2, 3 }";
    let expr = expect_ok(input, parse_new_expression(input.into()));
    // Verify structure
}

#[test]
fn test_target_typed_new() {
    let input = "new(42, \"test\")";
    let expr = expect_ok(input, parse_new_expression(input.into()));
    // Verify structure
}
<span class="boring">}</span></code></pre></pre>
<h3 id="6-test-invalid-input-diagnostics"><a class="header" href="#6-test-invalid-input-diagnostics">6. Test Invalid Input Diagnostics</a></h3>
<p><strong>Location:</strong> <code>tests/parser/expressions/invalid_diagnostics_tests.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_unclosed_paren_diagnostic() {
    let input = "(x + y";
    let result = parse_expression(input.into());
    
    assert!(result.is_err());
    // Optionally check error contains expected message
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Guidelines:</strong></p>
<ul>
<li>Keep small snapshot-style assertions</li>
<li>Check for line/column and caret presence</li>
<li>Avoid overfitting on exact wording (may change)</li>
</ul>
<h3 id="7-guard-closing-delimiters-with-cut"><a class="header" href="#7-guard-closing-delimiters-with-cut">7. Guard Closing Delimiters with <code>cut()</code></a></h3>
<p>When adding delimited constructs, ensure closing delimiters use <code>cut()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nom::combinator::cut;
use crate::syntax::parser_helpers::{bdelimited, bchar};

fn parse_parenthesized(input: &amp;str) -&gt; BResult&lt;&amp;str, Expression&gt; {
    bdelimited(
        bchar('('),
        parse_expression,
        cut(bchar(')'))  // ✅ Prevents misleading backtracking
    )(input.into())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="8-wrap-sub-parsers-with-bws"><a class="header" href="#8-wrap-sub-parsers-with-bws">8. Wrap Sub-Parsers with <code>bws()</code></a></h3>
<p>Ensure whitespace/comments are handled consistently:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::syntax::parser_helpers::bws;

fn parse_if_statement(input: &amp;str) -&gt; BResult&lt;&amp;str, Statement&gt; {
    let (input, _) = bws(keyword("if"))(input.into())?;
    let (input, _) = bws(bchar('('))(input.into())?;
    let (input, condition) = bws(parse_expression)(input.into())?;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="test-discovery-and-execution"><a class="header" href="#test-discovery-and-execution">Test Discovery and Execution</a></h2>
<h3 id="running-all-tests"><a class="header" href="#running-all-tests">Running All Tests</a></h3>
<pre><code class="language-bash">cargo test
</code></pre>
<h3 id="running-specific-test-suites"><a class="header" href="#running-specific-test-suites">Running Specific Test Suites</a></h3>
<pre><code class="language-bash"># All parser tests
cargo test --test parser

# Specific module
cargo test --test parser expression_tests

# Specific test
cargo test --test parser test_lambda_expression
</code></pre>
<h3 id="running-with-output"><a class="header" href="#running-with-output">Running with Output</a></h3>
<pre><code class="language-bash"># Show println! output
cargo test -- --nocapture

# Show test names as they run
cargo test -- --nocapture --test-threads=1
</code></pre>
<h3 id="running-with-debug-logging"><a class="header" href="#running-with-debug-logging">Running with Debug Logging</a></h3>
<pre><code class="language-bash">RUST_LOG=debug cargo test test_name -- --nocapture
</code></pre>
<hr />
<h2 id="test-fixtures-2"><a class="header" href="#test-fixtures-2">Test Fixtures</a></h2>
<h3 id="fixture-organization"><a class="header" href="#fixture-organization">Fixture Organization</a></h3>
<pre><code>tests/fixtures/
├── happy_path/           # Valid, well-formed C# projects
│   ├── testApplication/
│   │   ├── Program.cs
│   │   ├── testApplication.csproj
│   │   └── ...
│   └── testDependency/
│       └── ...
└── complex/              # Complex, real-world scenarios
    ├── testApplication/
    └── testDependency/
</code></pre>
<h3 id="using-fixtures-in-tests"><a class="header" href="#using-fixtures-in-tests">Using Fixtures in Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::path::PathBuf;

#[test]
fn test_parse_fixture() {
    let fixture_path = PathBuf::from("tests/fixtures/happy_path/testApplication/Program.cs");
    let source = fs::read_to_string(&amp;fixture_path).unwrap();
    
    let parser = Parser::new();
    let result = parser.parse(&amp;source);
    
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="fixture-guidelines"><a class="header" href="#fixture-guidelines">Fixture Guidelines</a></h3>
<ul>
<li><strong>Valid Code</strong>: Fixtures should be valid C# that compiles</li>
<li><strong>Realistic</strong>: Use real-world patterns, not contrived examples</li>
<li><strong>Documented</strong>: Add README.md explaining fixture purpose</li>
<li><strong>Minimal</strong>: Keep fixtures as small as possible while testing feature</li>
</ul>
<hr />
<h2 id="snapshot-testing"><a class="header" href="#snapshot-testing">Snapshot Testing</a></h2>
<h3 id="using-insta-for-snapshot-tests"><a class="header" href="#using-insta-for-snapshot-tests">Using <code>insta</code> for Snapshot Tests</a></h3>
<p><strong>Installation:</strong> Already included in <code>Cargo.toml</code> dev-dependencies</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use insta::assert_json_snapshot;

#[test]
fn test_class_ast_structure() {
    let input = "public class MyClass { public int Field; }";
    let result = parse_class_declaration(input.into());
    let class = expect_ok(input, result);
    
    // Creates snapshot file on first run
    assert_json_snapshot!(class);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="reviewing-snapshots"><a class="header" href="#reviewing-snapshots">Reviewing Snapshots</a></h3>
<pre><code class="language-bash"># Review snapshot changes
cargo insta review

# Accept all changes
cargo insta accept

# Reject all changes
cargo insta reject
</code></pre>
<h3 id="snapshot-guidelines"><a class="header" href="#snapshot-guidelines">Snapshot Guidelines</a></h3>
<ul>
<li><strong>Complex Structures</strong>: Use for complex AST structures</li>
<li><strong>Regression Prevention</strong>: Catch unintended changes</li>
<li><strong>Review Carefully</strong>: Always review snapshot diffs</li>
<li><strong>Commit Snapshots</strong>: Include snapshot files in git</li>
</ul>
<hr />
<h2 id="debugging-test-failures"><a class="header" href="#debugging-test-failures">Debugging Test Failures</a></h2>
<h3 id="strategy-1-use-expect_ok-error-output"><a class="header" href="#strategy-1-use-expect_ok-error-output">Strategy 1: Use <code>expect_ok()</code> Error Output</a></h3>
<p>When a test fails, <code>expect_ok()</code> shows the parse error:</p>
<pre><code>0: at line 1, in keyword "class":
public clas MyClass { }
       ^--- expected keyword "class"
</code></pre>
<h3 id="strategy-2-add-debug-logging"><a class="header" href="#strategy-2-add-debug-logging">Strategy 2: Add Debug Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_with_logging() {
    env_logger::init();  // Initialize logger
    
    let input = "complex syntax";
    log::debug!("Parsing: {}", input);
    
    let result = parse_expression(input.into());
    log::debug!("Result: {:?}", result);
    
    expect_ok(input, result);
}
<span class="boring">}</span></code></pre></pre>
<p>Run with:</p>
<pre><code class="language-bash">RUST_LOG=debug cargo test test_with_logging -- --nocapture
</code></pre>
<h3 id="strategy-3-test-smaller-components"><a class="header" href="#strategy-3-test-smaller-components">Strategy 3: Test Smaller Components</a></h3>
<p>If a complex parser fails, test its sub-parsers individually:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_method_declaration() {
    // Fails - too complex
    let input = "public async Task&lt;int&gt; Method(int x) { return x; }";
    expect_ok(input, parse_method_declaration(input.into()));
}

// Break it down:

#[test]
fn test_method_modifiers() {
    let input = "public async";
    expect_ok(input, parse_modifiers(input.into()));
}

#[test]
fn test_method_return_type() {
    let input = "Task&lt;int&gt;";
    expect_ok(input, parse_type(input.into()));
}

#[test]
fn test_method_parameters() {
    let input = "(int x)";
    expect_ok(input, parse_parameter_list(input.into()));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="strategy-4-use-parser-debugging-tools"><a class="header" href="#strategy-4-use-parser-debugging-tools">Strategy 4: Use Parser Debugging Tools</a></h3>
<pre><code class="language-bash"># Parse file and output JSON
cargo run -- parse debug_cases/test.cs --output debug.json

# Generate AST visualization
cargo run -- tree debug_cases/test.cs --output debug.svg
</code></pre>
<h3 id="strategy-5-check-error-recovery"><a class="header" href="#strategy-5-check-error-recovery">Strategy 5: Check Error Recovery</a></h3>
<p>For declaration error recovery tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_recovery_from_malformed_member() {
    let input = r#"
    public class MyClass {
        public int ValidField;
        public invalid syntax here;  // Malformed
        public int AnotherValidField;  // Should recover
    }
    "#;
    
    let result = parse_class_declaration(input.into());
    // Should parse despite error
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h2>
<h3 id="workspace-loading-tests"><a class="header" href="#workspace-loading-tests">Workspace Loading Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::workspace::WorkspaceLoader;

#[test]
fn test_load_solution() {
    let sln_path = PathBuf::from("tests/fixtures/happy_path/test.sln");
    let workspace = WorkspaceLoader::from_path(&amp;sln_path).unwrap();
    
    assert_eq!(workspace.projects.len(), 2);
    assert!(workspace.solution.is_some());
}

#[test]
fn test_load_csproj() {
    let csproj_path = PathBuf::from("tests/fixtures/happy_path/testApplication/testApplication.csproj");
    let workspace = WorkspaceLoader::from_path(&amp;csproj_path).unwrap();
    
    assert_eq!(workspace.projects.len(), 1);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="analysis-pipeline-tests"><a class="header" href="#analysis-pipeline-tests">Analysis Pipeline Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::framework::pipeline::AnalyzerPipeline;
use bsharp::analysis::framework::session::AnalysisSession;

#[test]
fn test_analysis_pipeline() {
    let source = "public class Test { public void Method() { } }";
    let parser = Parser::new();
    let cu = parser.parse(source).unwrap();
    
    let mut session = AnalysisSession::new();
    AnalyzerPipeline::run_with_defaults(&amp;cu, &amp;mut session);
    
    let report = session.into_report();
    assert!(report.diagnostics.is_empty());  // No errors
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<h3 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[ignore]  // Run with --ignored flag
fn bench_parse_large_file() {
    use std::time::Instant;
    
    let source = fs::read_to_string("tests/fixtures/large_file.cs").unwrap();
    let parser = Parser::new();
    
    let start = Instant::now();
    let result = parser.parse(&amp;source);
    let duration = start.elapsed();
    
    assert!(result.is_ok());
    println!("Parse time: {:?}", duration);
    
    // Assert reasonable performance
    assert!(duration.as_millis() &lt; 1000, "Parse took too long");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="running-performance-tests"><a class="header" href="#running-performance-tests">Running Performance Tests</a></h3>
<pre><code class="language-bash">cargo test --ignored -- bench_
</code></pre>
<hr />
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h2>
<h3 id="ci-test-strategy"><a class="header" href="#ci-test-strategy">CI Test Strategy</a></h3>
<pre><code class="language-yaml"># .github/workflows/test.yml (example)
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: Run tests
        run: cargo test --all-features
      - name: Run clippy
        run: cargo clippy -- -D warnings
      - name: Check formatting
        run: cargo fmt -- --check
</code></pre>
<hr />
<h2 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h2>
<h3 id="measuring-coverage"><a class="header" href="#measuring-coverage">Measuring Coverage</a></h3>
<pre><code class="language-bash"># Install tarpaulin
cargo install cargo-tarpaulin

# Run coverage
cargo tarpaulin --out Html --output-dir coverage
</code></pre>
<h3 id="coverage-goals"><a class="header" href="#coverage-goals">Coverage Goals</a></h3>
<ul>
<li><strong>Parser Core</strong>: 90%+ coverage</li>
<li><strong>Analysis Framework</strong>: 80%+ coverage</li>
<li><strong>CLI Commands</strong>: 70%+ coverage</li>
<li><strong>Workspace Loading</strong>: 80%+ coverage</li>
</ul>
<hr />
<h2 id="common-testing-patterns"><a class="header" href="#common-testing-patterns">Common Testing Patterns</a></h2>
<h3 id="pattern-1-positive-and-negative-tests"><a class="header" href="#pattern-1-positive-and-negative-tests">Pattern 1: Positive and Negative Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_valid_syntax() {
    let input = "valid syntax";
    expect_ok(input, parse_feature(input.into()));
}

#[test]
fn test_invalid_syntax() {
    let input = "invalid syntax";
    assert!(parse_feature(input.into()).is_err());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-2-boundary-testing"><a class="header" href="#pattern-2-boundary-testing">Pattern 2: Boundary Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_empty_input() {
    assert!(parse_feature("").is_err());
}

#[test]
fn test_minimal_input() {
    expect_ok("x", parse_feature("x"));
}

#[test]
fn test_maximal_input() {
    let input = "very complex nested structure...";
    expect_ok(input, parse_feature(input.into()));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-3-equivalence-testing"><a class="header" href="#pattern-3-equivalence-testing">Pattern 3: Equivalence Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_whitespace_insensitive() {
    let compact = "if(x){y;}";
    let spaced = "if (x) { y; }";
    
    let ast1 = expect_ok(compact, parse_if_statement(compact));
    let ast2 = expect_ok(spaced, parse_if_statement(spaced));
    
    assert_eq!(ast1, ast2);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="test-maintenance"><a class="header" href="#test-maintenance">Test Maintenance</a></h2>
<h3 id="when-to-update-tests"><a class="header" href="#when-to-update-tests">When to Update Tests</a></h3>
<ol>
<li><strong>API Changes</strong>: Update tests when parser API changes</li>
<li><strong>Bug Fixes</strong>: Add regression tests for fixed bugs</li>
<li><strong>New Features</strong>: Add tests for new language features</li>
<li><strong>Refactoring</strong>: Ensure tests still pass after refactoring</li>
</ol>
<h3 id="test-cleanup"><a class="header" href="#test-cleanup">Test Cleanup</a></h3>
<ul>
<li><strong>Remove Duplicate Tests</strong>: Consolidate similar tests</li>
<li><strong>Update Outdated Tests</strong>: Fix tests using deprecated APIs</li>
<li><strong>Remove Dead Tests</strong>: Delete tests for removed features</li>
<li><strong>Improve Names</strong>: Use descriptive test names</li>
</ul>
<h3 id="test-documentation"><a class="header" href="#test-documentation">Test Documentation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Tests that lambda expressions with multiple parameters are parsed correctly.
/// 
/// This test verifies:
/// - Parameter list parsing
/// - Arrow token recognition
/// - Expression body parsing
#[test]
fn test_lambda_with_multiple_params() {
    let input = "(x, y) =&gt; x + y";
    let expr = expect_ok(input, parse_lambda_expression(input.into()));
    // ...
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<h3 id="testing-checklist"><a class="header" href="#testing-checklist">Testing Checklist</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Tests in <code>tests/</code> directory, not inline</li>
<li><input disabled="" type="checkbox"/>
Use <code>expect_ok()</code> for readable failures</li>
<li><input disabled="" type="checkbox"/>
Keep tests focused and minimal</li>
<li><input disabled="" type="checkbox"/>
Add negative tests for ambiguity</li>
<li><input disabled="" type="checkbox"/>
Test lookahead/disambiguation boundaries</li>
<li><input disabled="" type="checkbox"/>
Test complex constructs thoroughly</li>
<li><input disabled="" type="checkbox"/>
Use <code>cut()</code> for closing delimiters</li>
<li><input disabled="" type="checkbox"/>
Wrap sub-parsers with <code>bws()</code></li>
<li><input disabled="" type="checkbox"/>
Add fixtures for integration tests</li>
<li><input disabled="" type="checkbox"/>
Use snapshot tests for complex structures</li>
<li><input disabled="" type="checkbox"/>
Document test purpose and coverage</li>
</ul>
<h3 id="resources"><a class="header" href="#resources">Resources</a></h3>
<ul>
<li><strong>Test Helpers</strong>: <code>src/syntax/test_helpers.rs</code></li>
<li><strong>Example Tests</strong>: <code>tests/parser/expressions/</code></li>
<li><strong>Fixtures</strong>: <code>tests/fixtures/</code></li>
<li><strong>Contributing Guide</strong>: <code>docs/development/contributing.md</code></li>
<li><strong>Architecture</strong>: <code>docs/development/architecture.md</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-decisions"><a class="header" href="#architecture-decisions">Architecture Decisions</a></h1>
<p>This document explains the key architectural decisions made in the BSharp project, their rationale, and their implications for contributors.</p>
<hr />
<h2 id="core-design-philosophy"><a class="header" href="#core-design-philosophy">Core Design Philosophy</a></h2>
<p>BSharp is designed as a <strong>modular, extensible C# parser and analysis toolkit</strong> written in Rust. The architecture prioritizes:</p>
<ol>
<li><strong>Correctness</strong> - Accurate parsing of C# syntax</li>
<li><strong>Performance</strong> - Efficient parsing and analysis of large codebases</li>
<li><strong>Maintainability</strong> - Clear module boundaries and minimal coupling</li>
<li><strong>Extensibility</strong> - Easy addition of new language features and analyzers</li>
</ol>
<hr />
<h2 id="parser-architecture"><a class="header" href="#parser-architecture">Parser Architecture</a></h2>
<h3 id="why-nom-parser-combinators"><a class="header" href="#why-nom-parser-combinators">Why nom Parser Combinators?</a></h3>
<p><strong>Decision:</strong> Use the <code>nom</code> parser combinator library as the foundation for parsing.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Composability</strong>: Small, focused parsers combine to handle complex syntax</li>
<li><strong>Type Safety</strong>: Rust's type system catches parser errors at compile time</li>
<li><strong>Performance</strong>: Zero-copy parsing with minimal allocations</li>
<li><strong>Testability</strong>: Individual parser functions are easily unit tested</li>
<li><strong>Maintainability</strong>: Declarative style is easier to understand than hand-written parsers</li>
</ul>
<p><strong>Trade-offs:</strong></p>
<ul>
<li>Learning curve for contributors unfamiliar with parser combinators</li>
<li>Error messages require additional work (addressed with nom-supreme)</li>
</ul>
<p><strong>Implementation:</strong></p>
<ul>
<li>Core parsing infrastructure: <code>src/bsharp_parser/src/helpers/</code></li>
<li>Parser implementations: <code>src/bsharp_parser/src/</code></li>
<li>All parsers return <code>BResult&lt;I, O&gt;</code> type alias</li>
</ul>
<h3 id="error-handling-strategy-1"><a class="header" href="#error-handling-strategy-1">Error Handling Strategy</a></h3>
<p><strong>Decision:</strong> Use <code>nom-supreme::ErrorTree</code> for all parser errors.</p>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Rich Context</strong>: Tree structure preserves full parse failure path</li>
<li><strong>Better Diagnostics</strong>: Context annotations via <code>.context()</code> method</li>
<li><strong>Integration</strong>: Seamless integration with nom combinators</li>
<li><strong>Debugging</strong>: Pretty-printing via <code>format_error_tree()</code></li>
</ul>
<p><strong>Evolution:</strong></p>
<ul>
<li>Initially used custom <code>BSharpParseError</code> type</li>
<li>Migrated to <code>ErrorTree</code> for better diagnostics</li>
<li>Custom error type deprecated and removed</li>
</ul>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type BResult&lt;I, O&gt; = IResult&lt;I, O, ErrorTree&lt;I&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<p><strong>Helper Functions (in <code>src/bsharp_parser/src/helpers/</code>)</strong></p>
<ul>
<li><code>context()</code> - Adds contextual information</li>
<li><code>cut()</code> - Commits to parse branch (prevents misleading backtracking)</li>
<li><code>bws()</code> - Whitespace-aware wrapper with error context</li>
<li><code>bdelimited()</code> - Delimited parsing with cut on closing delimiter</li>
</ul>
<h3 id="module-organization"><a class="header" href="#module-organization">Module Organization</a></h3>
<p><strong>Decision:</strong> Separate the parser crate from the syntax (AST) crate, and keep analysis in its own crate.</p>
<p><strong>Structure:</strong></p>
<pre><code>src/
├── bsharp_parser/          # Parser implementations and public facade
│   ├── src/
│   │   ├── expressions/    # Expression parsers
│   │   ├── keywords/       # Keyword parsing (modularized)
│   │   ├── helpers/        # Parsing utilities (bws, cut, context, directives, ...)
│   │   ├── facade.rs       # Public Parser facade
│   │   └── ...
├── bsharp_syntax/          # AST node definitions and shared syntax types
│   └── src/                # (re-exported by bsharp_parser as `syntax`)
├── bsharp_analysis/        # Analysis framework and workspace
│   └── src/
└── bsharp_cli/             # CLI entry and subcommands
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Separation of Concerns</strong>: Infrastructure vs implementation</li>
<li><strong>Reusability</strong>: Helpers used across all parsers</li>
<li><strong>API Clarity</strong>: <code>syntax</code> module is the public API</li>
<li><strong>Testing</strong>: Infrastructure can be tested independently</li>
</ul>
<h3 id="keyword-modularization"><a class="header" href="#keyword-modularization">Keyword Modularization</a></h3>
<p><strong>Decision:</strong> Organize keywords by category in dedicated modules.</p>
<p><strong>Structure:</strong></p>
<pre><code>src/parser/keywords/
├── mod.rs                      # Keyword infrastructure
├── access_keywords.rs          # public, private, protected, internal
├── accessor_keywords.rs        # get, set, init, add, remove
├── type_keywords.rs            # class, struct, interface, enum, record
├── modifier_keywords.rs        # static, abstract, virtual, sealed
├── flow_control_keywords.rs    # if, else, switch, case, default
├── iteration_keywords.rs       # for, foreach, while, do
├── expression_keywords.rs      # new, this, base, typeof, sizeof
├── linq_query_keywords.rs      # from, where, select, orderby
└── ...
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Maintainability</strong>: Easy to find and update keyword parsers</li>
<li><strong>Consistency</strong>: Uniform keyword parsing strategy</li>
<li><strong>Word Boundaries</strong>: All keywords use <code>keyword()</code> helper for boundary checking</li>
<li><strong>Prevents Bugs</strong>: Avoids partial matches (e.g., "int" vs "int32")</li>
</ul>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>keyword()</code> function enforces <code>[A-Za-z0-9_]</code> word boundaries</li>
<li>Parsers grouped under <code>src/bsharp_parser/src/keywords/</code></li>
</ul>
<hr />
<h2 id="ast-design"><a class="header" href="#ast-design">AST Design</a></h2>
<h3 id="naming-convention"><a class="header" href="#naming-convention">Naming Convention</a></h3>
<p><strong>Decision:</strong> Use PascalCase names without 'Syntax' suffix for all AST nodes.</p>
<p><strong>Examples:</strong></p>
<ul>
<li><code>ClassDeclaration</code> (not <code>ClassDeclarationSyntax</code>)</li>
<li><code>MethodDeclaration</code> (not <code>MethodDeclarationSyntax</code>)</li>
<li><code>ExpressionStatement</code> (not <code>ExpressionStatementSyntax</code>)</li>
<li><code>IfStatement</code> (not <code>IfStatementSyntax</code>)</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Clarity</strong>: Shorter, clearer names</li>
<li><strong>Roslyn Inspiration</strong>: Mirrors Roslyn's structure where appropriate</li>
<li><strong>Consistency</strong>: Uniform naming across entire codebase</li>
<li><strong>User Preference</strong>: Explicit design decision (documented in memories)</li>
</ul>
<p><strong>Implications:</strong></p>
<ul>
<li>All AST node types follow this convention</li>
<li>Test code uses these names</li>
<li>Documentation uses these names</li>
<li>Breaking change from earlier versions with 'Syntax' suffix</li>
</ul>
<h3 id="ast-ownership-model"><a class="header" href="#ast-ownership-model">AST Ownership Model</a></h3>
<p><strong>Decision:</strong> Parent nodes own their children; no circular references.</p>
<p><strong>Structure:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ClassDeclaration {
    pub attributes: Vec&lt;AttributeList&gt;,
    pub modifiers: Vec&lt;Modifier&gt;,
    pub name: Identifier,
    pub type_parameters: Option&lt;Vec&lt;TypeParameter&gt;&gt;,
    pub primary_constructor_parameters: Option&lt;Vec&lt;Parameter&gt;&gt;,
    pub base_types: Vec&lt;Type&gt;,
    pub body_declarations: Vec&lt;ClassBodyDeclaration&gt;,  // Owned
    pub documentation: Option&lt;XmlDocumentationComment&gt;,
    pub constraints: Option&lt;Vec&lt;TypeParameterConstraintClause&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Rust Ownership</strong>: Leverages Rust's ownership system</li>
<li><strong>Memory Safety</strong>: No reference cycles or lifetime complexity</li>
<li><strong>Simplicity</strong>: Clear ownership semantics</li>
<li><strong>Traversal</strong>: Navigation traits provide search without ownership issues</li>
</ul>
<p><strong>Trade-offs:</strong></p>
<ul>
<li>Cannot directly reference parent from child</li>
<li>Navigation requires traversal from root</li>
<li>Mitigated by <code>AstNavigate</code> and <code>FindDeclarations</code> traits</li>
</ul>
<h3 id="zero-copy-parsing-1"><a class="header" href="#zero-copy-parsing-1">Zero-Copy Parsing</a></h3>
<p><strong>Decision:</strong> Minimize string allocations during parsing where possible.</p>
<p><strong>Implementation:</strong></p>
<ul>
<li>String slices reference original input</li>
<li>Identifiers store <code>String</code> (owned) for convenience</li>
<li>Literals preserve original format as <code>String</code></li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Performance</strong>: Reduces allocation overhead</li>
<li><strong>Memory Efficiency</strong>: Lower memory footprint</li>
<li><strong>Trade-off</strong>: Some allocations necessary for AST lifetime</li>
</ul>
<h3 id="spans-and-location-tracking"><a class="header" href="#spans-and-location-tracking">Spans and Location Tracking</a></h3>
<p><strong>Decision:</strong> Track source locations via spans for precise diagnostics and tooling.</p>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>Span</code> type based on <code>nom_locate::LocatedSpan</code> lives in <code>src/bsharp_parser/src/syntax/span.rs</code> and is re-exported through the public parser API.</li>
<li>The parser facade supports <code>parse_with_spans()</code> which returns both the AST and span table for mapping nodes back to source locations.</li>
<li>Error reporting uses spans to include line/column, highlighting ranges via <code>format_error_tree()</code>.</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Diagnostics:</strong> Accurate error locations and ranges.</li>
<li><strong>Tooling:</strong> Enables IDE features, navigation, and source mapping.</li>
<li><strong>Testing:</strong> Stable, comparable locations for snapshot tests.</li>
</ul>
<p><strong>See also:</strong> <code>docs/syntax/spans.md</code>.</p>
<hr />
<h2 id="analysis-framework"><a class="header" href="#analysis-framework">Analysis Framework</a></h2>
<h3 id="framework-driven-architecture"><a class="header" href="#framework-driven-architecture">Framework-Driven Architecture</a></h3>
<p><strong>Decision:</strong> Implement a pipeline-based analysis framework with passes, rules, and visitors.</p>
<p><strong>Structure:</strong></p>
<pre><code>src/analysis/
├── framework/        # Core analysis infrastructure
│   ├── pipeline.rs   # Analysis pipeline orchestration
│   ├── passes.rs     # Analysis pass trait and phases
│   ├── rules.rs      # Rule trait and rulesets
│   ├── walker.rs     # AST walker and visitor pattern
│   ├── registry.rs   # Analyzer registry
│   └── session.rs    # Analysis session and state
├── passes/           # Concrete analysis passes
├── rules/            # Concrete analysis rules
├── artifacts/        # Analysis artifacts (symbols, metrics, CFG)
└── ...
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Extensibility</strong>: Easy to add new analyzers</li>
<li><strong>Composability</strong>: Passes and rules compose via registry</li>
<li><strong>Performance</strong>: Single-pass traversal for local rules</li>
<li><strong>Configurability</strong>: Enable/disable passes and rules via config</li>
</ul>
<p><strong>Phases:</strong></p>
<ol>
<li><strong>Index</strong> - Symbol indexing and scope building</li>
<li><strong>Local</strong> - Single-pass local rules and metrics collection</li>
<li><strong>Global</strong> - Cross-file analysis (dependencies, etc.)</li>
<li><strong>Semantic</strong> - Type checking and semantic rules</li>
<li><strong>Reporting</strong> - Report generation and formatting</li>
</ol>
<h3 id="visitor-pattern"><a class="header" href="#visitor-pattern">Visitor Pattern</a></h3>
<p><strong>Decision:</strong> Use visitor pattern for AST traversal.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Visit {
    fn enter(&amp;mut self, node: &amp;NodeRef, session: &amp;mut AnalysisSession);
    fn exit(&amp;mut self, node: &amp;NodeRef, session: &amp;mut AnalysisSession) {}
}

pub struct AstWalker {
    visitors: Vec&lt;Box&lt;dyn Visit&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Separation of Concerns</strong>: Traversal logic separate from analysis logic</li>
<li><strong>Composability</strong>: Multiple visitors in single traversal</li>
<li><strong>Performance</strong>: Single pass for multiple analyses</li>
<li><strong>Extensibility</strong>: Easy to add new visitors</li>
</ul>
<h3 id="query-api"><a class="header" href="#query-api">Query API</a></h3>
<p><strong>Decision:</strong> Use a typed Query API over a minimal <code>NodeRef</code> to traverse the AST. This is the current traversal API; the term “legacy” only refers to older navigation traits that the Query API replaced.</p>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>NodeRef</code> enumerates coarse node categories (compilation unit, namespaces, declarations, methods, statements, expressions), and now includes top-level items like file-scoped namespaces, using directives, global using directives, and global attributes.</li>
<li><code>Children</code> provides child enumeration for <code>NodeRef</code>.</li>
<li><code>Extract&lt;T&gt;</code> enables <code>Query::of&lt;T&gt;()</code> to yield typed nodes without extending <code>NodeRef</code> for every concrete type.</li>
<li>Macro helpers <code>impl_extract_expr!</code> and <code>impl_extract_stmt!</code> simplify adding <code>Extract</code> impls for expression/statement variants.</li>
<li>Location: <code>src/bsharp_syntax/src/query/</code> (re-exported as <code>bsharp_analysis::framework::Query</code>)</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Composability</strong>: Typed filters via <code>Query::filter_typed</code>.</li>
<li><strong>Maintainability</strong>: Avoids wide trait surfaces and duplicated traversal.</li>
<li><strong>Performance</strong>: Focused walkers remain available for hot paths.</li>
<li><strong>Determinism</strong>: Traversal order and artifact hashing remain stable.</li>
</ul>
<p><strong>See also:</strong></p>
<ul>
<li><code>docs/parser/navigation.md</code> (Query API overview)</li>
<li><code>docs/analysis/traversal-guide.md</code> (using Query in passes)</li>
<li><code>docs/development/query-cookbook.md</code> (recipes)</li>
</ul>
<hr />
<h2 id="formatting-and-emitters"><a class="header" href="#formatting-and-emitters">Formatting and Emitters</a></h2>
<p><strong>Decision:</strong> Implement formatting via an <code>Emit</code> trait with per-node emitters in <code>bsharp_syntax</code>.</p>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>Emit</code> trait and emitters live under <code>src/bsharp_syntax/src/emitters/</code> (e.g., <code>emitters/declarations/*</code>, <code>emitters/expressions/*</code>, <code>emitters/statements/*</code>).</li>
<li>Formatting is separated from parsing; emitters reconstruct code from AST with consistent whitespace and trivia handling.</li>
<li>Trivia and XML doc emitters are under <code>emitters/trivia/</code>.</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Separation of Concerns:</strong> Parsing and formatting evolve independently.</li>
<li><strong>Consistency:</strong> Centralized formatting rules for all nodes.</li>
<li><strong>Extensibility:</strong> Adding a new node implies an <code>Emit</code> impl in a known location.</li>
</ul>
<p><strong>See also:</strong> <code>docs/syntax/formatter.md</code>.</p>
<hr />
<h2 id="workspace-loading-1"><a class="header" href="#workspace-loading-1">Workspace Loading</a></h2>
<h3 id="multi-format-support"><a class="header" href="#multi-format-support">Multi-Format Support</a></h3>
<p><strong>Decision:</strong> Support loading from .sln, .csproj, or directory.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WorkspaceLoader;

impl WorkspaceLoader {
    pub fn from_path(path: &amp;Path) -&gt; Result&lt;Workspace&gt;;
    pub fn from_path_with_options(path: &amp;Path, opts: WorkspaceLoadOptions) -&gt; Result&lt;Workspace&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Flexibility</strong>: Support different entry points</li>
<li><strong>IDE Integration</strong>: Match IDE project loading behavior</li>
<li><strong>Incremental Analysis</strong>: Load only what's needed</li>
</ul>
<p><strong>Features:</strong></p>
<ul>
<li>Solution file (.sln) parsing</li>
<li>Project file (.csproj) parsing with XML</li>
<li>Transitive ProjectReference following</li>
<li>Source file discovery with glob patterns</li>
<li>Deterministic project ordering</li>
</ul>
<h3 id="error-resilience"><a class="header" href="#error-resilience">Error Resilience</a></h3>
<p><strong>Decision:</strong> Continue loading workspace even if individual projects fail.</p>
<p><strong>Implementation:</strong></p>
<ul>
<li>Failed projects recorded as stubs with error messages</li>
<li>Workspace loading succeeds with partial results</li>
<li>Errors accessible via <code>Project::errors</code> field</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Robustness</strong>: Don't fail entire workspace for one bad project</li>
<li><strong>User Experience</strong>: Show what can be analyzed</li>
<li><strong>Debugging</strong>: Error messages preserved for investigation</li>
</ul>
<hr />
<h2 id="testing-strategy"><a class="header" href="#testing-strategy">Testing Strategy</a></h2>
<h3 id="external-test-organization"><a class="header" href="#external-test-organization">External Test Organization</a></h3>
<p><strong>Decision:</strong> Externalize tests; in the current workspace they live under <code>src/bsharp_tests/</code> rather than inline <code>#[cfg(test)]</code> modules.</p>
<p><strong>Structure:</strong></p>
<pre><code>src/bsharp_tests/src/
├── parser/
│   ├── expressions/
│   ├── statements/
│   ├── declarations/
│   └── types/
├── cli/
└── integration/
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Separation</strong>: Test code separate from implementation</li>
<li><strong>Organization</strong>: Clear structure mirrors crates</li>
<li><strong>Compilation</strong>: Tests don't bloat production binaries</li>
</ul>
<p><strong>Note:</strong> A future migration to top-level <code>tests/</code> may be considered.</p>
<h3 id="test-helpers-1"><a class="header" href="#test-helpers-1">Test Helpers</a></h3>
<p><strong>Decision:</strong> Provide <code>expect_ok()</code> helper for readable test failures.</p>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn expect_ok&lt;T&gt;(input: &amp;str, result: BResult&lt;&amp;str, T&gt;) -&gt; T {
    match result {
        Ok((_, value)) =&gt; value,
        Err(e) =&gt; {
            eprintln!("{}", format_error_tree(&amp;input, &amp;e));
            panic!("Parse failed");
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Diagnostics</strong>: Pretty-printed errors on failure</li>
<li><strong>Debugging</strong>: Shows parse failure context</li>
<li><strong>Consistency</strong>: Uniform test error reporting</li>
</ul>
<h3 id="snapshot-testing-1"><a class="header" href="#snapshot-testing-1">Snapshot Testing</a></h3>
<p><strong>Decision:</strong> Use <code>insta</code> crate for snapshot testing.</p>
<p><strong>Implementation:</strong></p>
<ul>
<li><code>Cargo.toml</code> includes <code>insta</code> in dev-dependencies</li>
<li>Snapshot tests for complex AST structures</li>
<li>JSON serialization for comparison</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Regression Prevention</strong>: Catch unintended AST changes</li>
<li><strong>Review</strong>: Visual diff of AST changes</li>
<li><strong>Maintenance</strong>: Update snapshots when intentional</li>
</ul>
<hr />
<h2 id="performance-considerations-3"><a class="header" href="#performance-considerations-3">Performance Considerations</a></h2>
<h3 id="parallel-analysis-1"><a class="header" href="#parallel-analysis-1">Parallel Analysis</a></h3>
<p><strong>Decision:</strong> Optional parallel analysis via <code>rayon</code> feature.</p>
<p><strong>Implementation:</strong></p>
<pre><code class="language-toml">[features]
parallel_analysis = ["rayon"]
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Scalability</strong>: Faster analysis for large workspaces</li>
<li><strong>Optional</strong>: Not required for single-file use cases</li>
<li><strong>Trade-off</strong>: Adds dependency and complexity</li>
</ul>
<h3 id="incremental-parsing"><a class="header" href="#incremental-parsing">Incremental Parsing</a></h3>
<p><strong>Decision:</strong> Not implemented yet; designed for future addition.</p>
<p><strong>Future Design:</strong></p>
<ul>
<li>Cache parsed ASTs by file hash</li>
<li>Reparse only changed files</li>
<li>Incremental analysis based on change scope</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Performance</strong>: Critical for IDE integration</li>
<li><strong>Complexity</strong>: Requires careful cache invalidation</li>
<li><strong>Priority</strong>: Deferred until core features stable</li>
</ul>
<hr />
<!-- Compiler backend and code generation are intentionally out of scope for now. -->
<hr />
<h2 id="cli-design"><a class="header" href="#cli-design">CLI Design</a></h2>
<h3 id="subcommand-structure"><a class="header" href="#subcommand-structure">Subcommand Structure</a></h3>
<p><strong>Decision:</strong> Use <code>clap</code> with subcommands for different operations.</p>
<p><strong>Commands:</strong></p>
<ul>
<li><code>parse</code> - Parse C# file to JSON</li>
<li><code>tree</code> - Generate AST visualization (Mermaid/DOT)</li>
<li><code>analyze</code> - Run analysis and generate report</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Clarity</strong>: Each command has clear purpose</li>
<li><strong>Extensibility</strong>: Easy to add new commands</li>
<li><strong>Discoverability</strong>: <code>--help</code> shows all options</li>
<li><strong>Consistency</strong>: Follows common CLI patterns</li>
</ul>
<h3 id="output-formats-2"><a class="header" href="#output-formats-2">Output Formats</a></h3>
<p><strong>Decision:</strong> Support multiple output formats (JSON, pretty-JSON, SVG).</p>
<p><strong>Implementation:</strong></p>
<ul>
<li>JSON for machine consumption</li>
<li>Pretty-JSON for human readability</li>
<li>SVG for visualization</li>
</ul>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Integration</strong>: JSON for tool integration</li>
<li><strong>Debugging</strong>: Pretty-JSON for manual inspection</li>
<li><strong>Visualization</strong>: SVG for understanding AST structure</li>
</ul>
<hr />
<h2 id="future-extensibility"><a class="header" href="#future-extensibility">Future Extensibility</a></h2>
<h3 id="planned-enhancements"><a class="header" href="#planned-enhancements">Planned Enhancements</a></h3>
<ol>
<li>
<p><strong>Incremental Parsing</strong></p>
<ul>
<li>Cache parsed ASTs</li>
<li>Reparse only changed regions</li>
<li>Critical for IDE integration</li>
</ul>
</li>
<li>
<p><strong>Language Server Protocol (LSP)</strong></p>
<ul>
<li>IDE integration</li>
<li>Real-time diagnostics</li>
<li>Code completion</li>
</ul>
</li>
<li>
<p><strong>More Analysis Passes</strong></p>
<ul>
<li>Nullability analysis</li>
<li>Lifetime analysis</li>
<li>Security analysis</li>
</ul>
</li>
<li>
<p><strong>Code Transformation</strong></p>
<ul>
<li>AST modification API</li>
<li>Code generation from AST</li>
<li>Refactoring support</li>
</ul>
</li>
</ol>
<h3 id="design-for-extension"><a class="header" href="#design-for-extension">Design for Extension</a></h3>
<p><strong>Principles:</strong></p>
<ul>
<li><strong>Trait-Based</strong>: Use traits for extensibility points</li>
<li><strong>Registry Pattern</strong>: Dynamic registration of analyzers</li>
<li><strong>Configuration</strong>: Enable/disable features via config</li>
<li><strong>Versioning</strong>: Stable API with clear versioning</li>
</ul>
<hr />
<h2 id="lessons-learned"><a class="header" href="#lessons-learned">Lessons Learned</a></h2>
<h3 id="what-worked-well"><a class="header" href="#what-worked-well">What Worked Well</a></h3>
<ol>
<li><strong>Parser Combinators</strong>: Excellent for composability and testing</li>
<li><strong>Module Organization</strong>: Clear boundaries reduce coupling</li>
<li><strong>Error Context</strong>: <code>ErrorTree</code> provides excellent diagnostics</li>
<li><strong>External Tests</strong>: Clean separation improves maintainability</li>
</ol>
<h3 id="what-wed-do-differently"><a class="header" href="#what-wed-do-differently">What We'd Do Differently</a></h3>
<ol>
<li><strong>Earlier Keyword Modularization</strong>: Should have organized keywords from start</li>
<li><strong>Error Type Migration</strong>: Earlier adoption of <code>ErrorTree</code> would have saved refactoring</li>
<li><strong>Documentation</strong>: More inline documentation from the beginning</li>
</ol>
<h3 id="recent-refactoring"><a class="header" href="#recent-refactoring">Recent Refactoring</a></h3>
<p>Major refactoring improvements completed:</p>
<ul>
<li>Expression precedence chain builder implemented</li>
<li>Statement group deduplication completed</li>
<li>Consistent error recovery with <code>skip_to_member_boundary_top_level()</code></li>
<li>Whitespace handling standardization via <code>bws()</code> combinator</li>
<li>Keyword modularization by category</li>
</ul>
<hr />
<h2 id="contributing-guidelines"><a class="header" href="#contributing-guidelines">Contributing Guidelines</a></h2>
<p>When adding new features, follow these architectural principles:</p>
<ol>
<li><strong>Use Existing Patterns</strong>: Follow established parser patterns</li>
<li><strong>Add Tests</strong>: External tests in <code>tests/</code> directory</li>
<li><strong>Document Decisions</strong>: Update this file for significant changes</li>
<li><strong>Error Context</strong>: Add <code>.context()</code> calls for debugging</li>
<li><strong>Naming Convention</strong>: PascalCase without 'Syntax' suffix</li>
<li><strong>Keyword Boundaries</strong>: Use <code>keyword()</code> helper for all keywords</li>
</ol>
<p>See <code>docs/development/contributing.md</code> for detailed contribution guidelines.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cookbooks"><a class="header" href="#cookbooks">Cookbooks</a></h1>
<p>Short, task-focused examples and patterns.</p>
<hr />
<h2 id="available-cookbooks"><a class="header" href="#available-cookbooks">Available Cookbooks</a></h2>
<ul>
<li><a href="development/./query-cookbook.html">Query Cookbook</a>
<ul>
<li>Practical <code>Query</code> API patterns for traversing the AST.</li>
</ul>
</li>
<li><a href="development/./parser-cookbook.html">Parser Cookbook</a>
<ul>
<li>Nom recipes: identifiers, lists, delimited blocks with <code>cut</code>, tokens with <code>complete</code>, and <code>all_consuming</code> file parsers.</li>
</ul>
</li>
</ul>
<hr />
<h2 id="when-to-use"><a class="header" href="#when-to-use">When to use</a></h2>
<ul>
<li>You know the outcome you want and need a concise example.</li>
<li>You want to copy/paste a small starting point and adapt.</li>
</ul>
<p>For deeper explanations, see:</p>
<ul>
<li><code>docs/development/writing-parsers.md</code></li>
<li><code>docs/analysis/traversal-guide.md</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-cookbook"><a class="header" href="#query-cookbook">Query Cookbook</a></h1>
<p>Practical examples for using the <code>Query</code> API to traverse the AST.</p>
<hr />
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Option A (canonical): import directly from bsharp_syntax
use bsharp_syntax::node::ast_node::NodeRef;
use bsharp_syntax::query::Query;
use bsharp_syntax::{CompilationUnit, ClassDeclaration, MethodDeclaration};

// Option B (ergonomic in analysis code): re-exports via bsharp_analysis
// use bsharp_analysis::framework::{NodeRef, Query};
<span class="boring">}</span></code></pre></pre>
<h2 id="all-classes-in-a-file"><a class="header" href="#all-classes-in-a-file">All classes in a file</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn all_classes(cu: &amp;CompilationUnit) -&gt; Vec&lt;&amp;ClassDeclaration&gt; {
    Query::from(NodeRef::CompilationUnit(cu))
        .of::&lt;ClassDeclaration&gt;()
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="all-methods-in-a-class"><a class="header" href="#all-methods-in-a-class">All methods in a class</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn all_methods_in_class(c: &amp;ClassDeclaration) -&gt; Vec&lt;&amp;MethodDeclaration&gt; {
    Query::from(NodeRef::from(c))
        .of::&lt;MethodDeclaration&gt;()
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="public-methods-only"><a class="header" href="#public-methods-only">Public methods only</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_syntax::modifiers::Modifier;

fn public_methods(cu: &amp;CompilationUnit) -&gt; Vec&lt;&amp;MethodDeclaration&gt; {
    Query::from(NodeRef::CompilationUnit(cu))
        .filter_typed::&lt;MethodDeclaration&gt;(|m| m.modifiers.iter().any(|mm| *mm == Modifier::Public))
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="count-await-expressions"><a class="header" href="#count-await-expressions">Count await expressions</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_syntax::expressions::AwaitExpression;

fn await_count(cu: &amp;CompilationUnit) -&gt; usize {
    Query::from(NodeRef::CompilationUnit(cu))
        .of::&lt;AwaitExpression&gt;()
        .count()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="find-invocations-of-a-method-name"><a class="header" href="#find-invocations-of-a-method-name">Find invocations of a method name</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_syntax::expressions::{InvocationExpression, Expression};

fn invocations_of(cu: &amp;CompilationUnit, name: &amp;str) -&gt; Vec&lt;&amp;InvocationExpression&gt; {
    Query::from(NodeRef::CompilationUnit(cu))
        .filter_typed::&lt;InvocationExpression&gt;(|inv| {
            // Match simple Variable(...) calls; extend for MemberAccess as needed
            match &amp;*inv.expression {
                Expression::Variable(id) =&gt; id.name == name,
                _ =&gt; false,
            }
        })
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="methods-with-deep-nesting"><a class="header" href="#methods-with-deep-nesting">Methods with deep nesting</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_syntax::statements::statement::Statement;

fn deeply_nested_methods(cu: &amp;CompilationUnit, threshold: usize) -&gt; Vec&lt;&amp;MethodDeclaration&gt; {
    Query::from(NodeRef::CompilationUnit(cu))
        .filter_typed::&lt;MethodDeclaration&gt;(|m| {
            if let Some(body) = &amp;m.body {
                max_nesting(body, 0) &gt; threshold
            } else {
                false
            }
        })
        .collect()
}

fn max_nesting(s: &amp;Statement, cur: usize) -&gt; usize {
    match s {
        Statement::If(i) =&gt; {
            let then_d = max_nesting(&amp;i.consequence, cur + 1);
            let else_d = i.alternative.as_ref().map(|a| max_nesting(a, cur + 1)).unwrap_or(cur);
            then_d.max(else_d)
        }
        Statement::Block(stmts) =&gt; stmts.iter().map(|st| max_nesting(st, cur)).max().unwrap_or(cur),
        Statement::For(f) =&gt; max_nesting(&amp;f.body, cur + 1),
        Statement::ForEach(f) =&gt; max_nesting(&amp;f.body, cur + 1),
        Statement::While(w) =&gt; max_nesting(&amp;w.body, cur + 1),
        Statement::DoWhile(d) =&gt; max_nesting(&amp;d.body, cur + 1),
        _ =&gt; cur,
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="tips-4"><a class="header" href="#tips-4">Tips</a></h2>
<ul>
<li><strong>Chain filters sparingly</strong>: Prefer a single <code>filter_typed</code> with a clear predicate.</li>
<li><strong>Use <code>NodeRef::from(x)</code></strong>: Start from any AST node to scope queries.</li>
<li><strong>Profile</strong>: For hot paths, consider a custom walker when you need full control.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parser-cookbook"><a class="header" href="#parser-cookbook">Parser Cookbook</a></h1>
<p>Practical recipes for nom-based parsers in <code>bsharp_parser</code>.</p>
<hr />
<h2 id="conventions"><a class="header" href="#conventions">Conventions</a></h2>
<ul>
<li>Use <code>Span&lt;'a&gt;</code> and <code>BResult&lt;'a, T&gt;</code> from <code>bsharp_parser::syntax</code> modules.</li>
<li>Prefer small, composable parsers and add <code>context()</code> labels.</li>
<li>Use <code>cut()</code> to avoid misleading backtracking after committing to a branch.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_parser::syntax::span::Span;
use bsharp_parser::syntax::errors::BResult;
use nom::{IResult, branch::alt, bytes::complete::tag, character::complete as cc, combinator::{all_consuming, complete, map}, sequence::{delimited, preceded, terminated, tuple}};
use nom_supreme::ParserExt; // for .context(), .cut()
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="identifier"><a class="header" href="#identifier">Identifier</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn identifier(input: Span) -&gt; BResult&lt;String&gt; {
    // very simplified: letter (letter|digit|_)*
    map(
        tuple((cc::alpha1, cc::alphanumeric0)),
        |(h, t): (&amp;str, &amp;str)| format!("{}{}", h, t)
    ).context("identifier").parse(input)
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="comma-separated-list"><a class="header" href="#comma-separated-list">Comma-Separated List</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nom::multi::separated_list0;

fn comma_sep&lt;T, F&gt;(item: F) -&gt; impl FnMut(Span) -&gt; BResult&lt;Vec&lt;T&gt;&gt;
where F: Fn(Span) -&gt; BResult&lt;T&gt; {
    separated_list0(cc::multispace0.and(tag(",")).and(cc::multispace0), item)
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="delimited-braces-block"><a class="header" href="#delimited-braces-block">Delimited Braces Block</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lbrace(i: Span) -&gt; BResult&lt;()&gt; { map(tag("{"), |_| ()).context("'{'").parse(i) }
fn rbrace(i: Span) -&gt; BResult&lt;()&gt; { map(tag("}"), |_| ()).context("'}'").parse(i) }

fn block&lt;T, F&gt;(mut inner: F) -&gt; impl FnMut(Span) -&gt; BResult&lt;Vec&lt;T&gt;&gt;
where F: FnMut(Span) -&gt; BResult&lt;Vec&lt;T&gt;&gt; {
    move |input| {
        delimited(
            lbrace.context("block start"),
            // prevent backtracking past '}' so the missing brace is reported
            inner.cut(),
            rbrace.cut().context("block end")
        ).parse(input)
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="using-complete-for-tokens"><a class="header" href="#using-complete-for-tokens">Using complete() for Tokens</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nom::bytes::streaming::take;
use nom::combinator::complete;

fn exactly_n(n: u8) -&gt; impl FnMut(Span) -&gt; BResult&lt;Span&lt;'_&gt;&gt; {
    move |input| complete(take(n)).context("exactly_n").parse(input)
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="all_consuming-at-file-level"><a class="header" href="#all_consuming-at-file-level">all_consuming at File Level</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nom::combinator::all_consuming;

fn parse_file(input: Span) -&gt; BResult&lt;File&gt; {
    all_consuming(file_parser).parse(input)
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="precedence-chain-skeleton"><a class="header" href="#precedence-chain-skeleton">Precedence Chain Skeleton</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn primary(i: Span) -&gt; BResult&lt;Expr&gt; { /* literals, names, parenthesized */ }
fn postfix(i: Span) -&gt; BResult&lt;Expr&gt; { /* member access, invocation */ }
fn unary(i: Span) -&gt; BResult&lt;Expr&gt; { /* + - ! ~ */ }
fn multiplicative(i: Span) -&gt; BResult&lt;Expr&gt; { /* * / % */ }
fn additive(i: Span) -&gt; BResult&lt;Expr&gt; { /* + - */ }
fn relational(i: Span) -&gt; BResult&lt;Expr&gt; { /* &lt; &gt; &lt;= &gt;= */ }
fn equality(i: Span) -&gt; BResult&lt;Expr&gt; { /* == != */ }
fn assignment(i: Span) -&gt; BResult&lt;Expr&gt; { /* = += -= */ }

// Entry point used by statement parsers
fn expression(i: Span) -&gt; BResult&lt;Expr&gt; { assignment(i) }
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="context-labels-and-cuts"><a class="header" href="#context-labels-and-cuts">Context Labels and Cuts</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn class_declaration(i: Span) -&gt; BResult&lt;ClassDecl&gt; {
    preceded(
        tag("class").context("keyword 'class'"),
        tuple((
            identifier.cut().context("class name"),
            // ... type params, base list
        ))
    ).context("class declaration").map(|(name, ..)| ClassDecl { name }).parse(i)
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="tips-5"><a class="header" href="#tips-5">Tips</a></h2>
<ul>
<li><strong>Whitespace</strong>: Prefer explicit <code>multispace0</code>/<code>multispace1</code> at boundaries to avoid accidental greedy matches.</li>
<li><strong>Error messages</strong>: Keep <code>context()</code> labels concise and domain-specific (e.g., "parameter list").</li>
<li><strong>Backtracking</strong>: Insert <code>cut()</code> after committing to a branch to stop alt from swallowing errors.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h1>
<p>How to write and organize tests for BSharp.</p>
<hr />
<h2 id="test-locations"><a class="header" href="#test-locations">Test Locations</a></h2>
<ul>
<li>Parser and analysis tests live under <code>src/bsharp_tests/src/</code>.</li>
<li>Prefer dedicated files per area, e.g.:
<ul>
<li><code>src/bsharp_tests/src/parser/expressions/...</code></li>
<li><code>src/bsharp_tests/src/parser/statements/...</code></li>
<li><code>src/bsharp_tests/src/analysis/...</code></li>
</ul>
</li>
</ul>
<hr />
<h2 id="parser-tests-1"><a class="header" href="#parser-tests-1">Parser Tests</a></h2>
<ul>
<li>Use realistic C# snippets and assert AST shapes.</li>
<li>Prefer external test helpers (avoid inline <code>#[cfg(test)]</code> in parser modules).</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example skeleton
#[test]
fn parses_simple_invocation() {
    let source = "class C { void M() { Foo(1); } }";
    let (cu, _spans) = bsharp_parser::facade::Parser::new().parse_with_spans(source).unwrap();
    // Use Query or pattern matching to verify nodes
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="analysis-tests-1"><a class="header" href="#analysis-tests-1">Analysis Tests</a></h2>
<ul>
<li>Run <code>AnalyzerPipeline::run_with_defaults</code> and inspect artifacts:
<ul>
<li><code>AstAnalysis</code> metrics</li>
<li>CFG summary</li>
<li>Dependency summary</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn counts_methods() {
    let src = "class C { void A(){} void B(){} }";
    let (cu, spans) = bsharp_parser::facade::Parser::new().parse_with_spans(src).unwrap();
    let mut session = bsharp_analysis::framework::AnalysisSession::new(
        bsharp_analysis::context::AnalysisContext::new("file.cs", src), spans);
    bsharp_analysis::framework::AnalyzerPipeline::run_with_defaults(&amp;cu, &amp;mut session);
    let metrics = session.artifacts.get::&lt;bsharp_analysis::metrics::AstAnalysis&gt;().unwrap();
    assert!(metrics.total_methods &gt;= 2);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="tips-6"><a class="header" href="#tips-6">Tips</a></h2>
<ul>
<li><strong>Names</strong>: Use descriptive test names; each file should focus on one area.</li>
<li><strong>Fixtures</strong>: Keep sources small and focused; add comments for intent.</li>
<li><strong>Determinism</strong>: Avoid relying on traversal order; query by type or match by name.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bsharp_tests-overview"><a class="header" href="#bsharp_tests-overview">bsharp_tests Overview</a></h1>
<p>Structure and conventions for the test crate.</p>
<hr />
<h2 id="location"><a class="header" href="#location">Location</a></h2>
<ul>
<li>All tests live under <code>src/bsharp_tests/src/</code>.</li>
<li>Organize by domain:
<ul>
<li><code>parser/</code> for parsing-related tests</li>
<li><code>analysis/</code> for analysis pipeline tests</li>
</ul>
</li>
</ul>
<hr />
<h2 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h2>
<pre><code class="language-bash">cargo test -p bsharp_tests
</code></pre>
<hr />
<h2 id="conventions-1"><a class="header" href="#conventions-1">Conventions</a></h2>
<ul>
<li>Prefer descriptive file names and test names.</li>
<li>Keep fixtures small and focused.</li>
<li>Use <code>Parser::parse_with_spans</code> and <code>AnalyzerPipeline::run_with_defaults</code> in integration-style tests.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extending-syntax-new-nodes"><a class="header" href="#extending-syntax-new-nodes">Extending Syntax (New Nodes)</a></h1>
<p>How to add new AST node types to <code>bsharp_syntax</code>.</p>
<hr />
<h2 id="1-define-the-node"><a class="header" href="#1-define-the-node">1. Define the Node</a></h2>
<ul>
<li>Add a struct or enum in the relevant module under <code>src/bsharp_syntax/src/</code>.</li>
<li>Derive <code>bsharp_syntax_derive::AstNode</code> so it participates in traversal and rendering.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(bsharp_syntax_derive::AstNode, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct InterpolatedString {
    pub parts: Vec&lt;InterpolatedPart&gt;,
}

#[derive(bsharp_syntax_derive::AstNode, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum InterpolatedPart {
    Text(String),
    Expr(Expression),
}
<span class="boring">}</span></code></pre></pre>
<p>The derive implements <code>AstNode</code> and auto-generates <code>children()</code> that pushes nested nodes.</p>
<hr />
<h2 id="2-implement-emit-optional"><a class="header" href="#2-implement-emit-optional">2. Implement Emit (Optional)</a></h2>
<p>If the node needs to be formatted back to C#, implement <code>Emit</code> in <code>bsharp_syntax</code> emitters.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl crate::emitters::emit_trait::Emit for InterpolatedString {
    fn emit&lt;W: std::fmt::Write&gt;(&amp;self, w: &amp;mut W, cx: &amp;mut EmitCtx) -&gt; Result&lt;(), EmitError&gt; {
        cx.token(w, "$")?;
        cx.bracketed(w, '"', '"', || {
            for p in &amp;self.parts { p.emit(w, cx)?; }
            Ok(())
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Add per-part emitters in the same or nearby module (e.g., <code>emitters/expressions/...</code>).</p>
<hr />
<h2 id="3-wire-up-parser-in-bsharp_parser"><a class="header" href="#3-wire-up-parser-in-bsharp_parser">3. Wire Up Parser (in <code>bsharp_parser</code>)</a></h2>
<ul>
<li>Add a parser in <code>src/bsharp_parser/src/expressions/...</code> that constructs the new node.</li>
<li>Use <code>Span</code>-based parsers (<code>bsharp_parser::syntax::span::Span</code>).</li>
<li>On errors, rely on helpers and contexts so <code>format_error_tree()</code> is informative.</li>
</ul>
<hr />
<h2 id="3a-add-keywords--tokens"><a class="header" href="#3a-add-keywords--tokens">3a. Add Keywords &amp; Tokens</a></h2>
<ul>
<li>Define keyword helpers using <code>define_keyword_pair!</code> in <code>src/bsharp_parser/src/keywords/</code>.</li>
<li>If a new reserved word, add it to <code>KEYWORDS</code> (identifier filtering).</li>
<li>Use <code>kw_*()</code>/<code>peek_*()</code> in parsers, wrapped with <code>ws()</code> at boundaries, and insert <code>.cut()</code> after commitment.</li>
</ul>
<p>See: <code>docs/parser/keywords-and-tokens.md</code> for the macro and examples.</p>
<hr />
<h2 id="3b-use-syntax-parsers-whitespacelists"><a class="header" href="#3b-use-syntax-parsers-whitespacelists">3b. Use Syntax Parsers (Whitespace/Lists)</a></h2>
<ul>
<li>Whitespace/comments: <code>syntax/comment_parser.rs</code> (<code>ws()</code>, <code>parse_whitespace_or_comments()</code>)</li>
<li>Lists: <code>syntax/list_parser.rs</code> for delimited/separated lists</li>
<li>Tokens: prefer <code>nom_supreme::tag::complete::tag()</code> and compose with <code>preceded/terminated/delimited</code> and <code>ws()</code></li>
</ul>
<p>Example token with trivia:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nom::{combinator::map, sequence::delimited};
use nom_supreme::tag::complete::tag;
use crate::syntax::comment_parser::ws;

map(delimited(ws, tag(","), ws), |_| ())
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="4-tests-bsharp_tests"><a class="header" href="#4-tests-bsharp_tests">4. Tests (<code>bsharp_tests</code>)</a></h2>
<ul>
<li>Create tests under <code>src/bsharp_tests/src/parser/...</code> verifying the node appears in the AST.</li>
<li>Add formatter round-trip tests if <code>Emit</code> is implemented.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn interpolated_string_ast() {
    let src = r#"class C { void M(){ var s = $"x={x}"; } }"#;
    let (cu, _spans) = bsharp_parser::facade::Parser::new().parse_with_spans(src).unwrap();
    // Use Query to find InterpolatedString once parser supports it
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="5-visualization-optional"><a class="header" href="#5-visualization-optional">5. Visualization (Optional)</a></h2>
<p>Graph views require no changes: <code>to_text</code>, <code>to_mermaid</code>, and <code>to_dot</code> use <code>AstNode</code> traversal.</p>
<hr />
<h2 id="tips-7"><a class="header" href="#tips-7">Tips</a></h2>
<ul>
<li><strong>Box recursion</strong>: Use <code>Box&lt;T&gt;</code> for recursive enum variants.</li>
<li><strong>Keep primitives out</strong>: Store <code>String</code>, <code>bool</code>, numbers as payload only; derive will skip them.</li>
<li><strong>Naming</strong>: Use PascalCase node names; no <code>Syntax</code> suffix.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-parsers"><a class="header" href="#writing-parsers">Writing Parsers</a></h1>
<p>Guidelines for implementing parsers in <code>bsharp_parser</code> using nom and spans.</p>
<hr />
<h2 id="spans--result-type"><a class="header" href="#spans--result-type">Spans &amp; Result Type</a></h2>
<ul>
<li><strong>Span:</strong> <code>bsharp_parser::syntax::span::Span&lt;'a&gt;</code> (alias of <code>nom_locate::LocatedSpan&lt;&amp;'a str&gt;</code>)</li>
<li><strong>Error type:</strong> <code>nom_supreme::error::ErrorTree&lt;Span&lt;'a&gt;&gt;</code></li>
<li><strong>Result alias:</strong> <code>type BResult&lt;'a, O&gt; = IResult&lt;Span&lt;'a&gt;, O, ErrorTree&lt;Span&lt;'a&gt;&gt;&gt;</code> in <code>bsharp_parser::syntax::errors</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_parser::syntax::errors::BResult;
use bsharp_parser::syntax::span::Span;
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="streaming-vs-complete"><a class="header" href="#streaming-vs-complete">Streaming vs Complete</a></h2>
<p>nom supports streaming parsers by default. Use <code>nom::combinator::complete(parser)</code> to transform <code>Incomplete</code> into <code>Error</code> when you want a "complete input" behavior for a sub-parser (e.g., tokens, literals).</p>
<p>Example (from nom docs):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nom::bytes::streaming::take;
use nom::combinator::complete;

let mut parser = complete(take(5u8));
assert_eq!(parser.parse("abcdefg"), Ok(("fg", "abcde")));
assert!(parser.parse("abcd").is_err());
<span class="boring">}</span></code></pre></pre>
<p>At the top level, wrap file parsers with <code>nom::combinator::all_consuming</code> to ensure the entire input is consumed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nom::combinator::all_consuming;
let mut parser = all_consuming(file_parser);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="error-contexts-and-cuts"><a class="header" href="#error-contexts-and-cuts">Error Contexts and Cuts</a></h2>
<p>Use <code>nom_supreme</code> for structured errors and better messages:</p>
<ul>
<li><code>context("label", p)</code> to push human-readable frames.</li>
<li><code>cut(p)</code> to prevent backtracking across critical boundaries and surface the right error.</li>
<li>Our pretty-printer <code>format_error_tree(&amp;source, &amp;error_tree)</code> renders the tree with line/column and context stack.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nom::{branch::alt, sequence::{preceded, terminated}};
use nom_supreme::context::ContextError;
use nom_supreme::ParserExt; // for .context(), .cut()

fn identifier(input: Span) -&gt; BResult&lt;String&gt; { /* ... */ }
fn lbrace(input: Span) -&gt; BResult&lt;()&gt; { /* ... */ }
fn rbrace(input: Span) -&gt; BResult&lt;()&gt; { /* ... */ }

fn block(input: Span) -&gt; BResult&lt;Vec&lt;Stmt&gt;&gt; {
    preceded(
        lbrace.context("block: '{'"),
        terminated(statements, rbrace.cut().context("block: '}'"))
    ).parse(input)
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="common-combinators"><a class="header" href="#common-combinators">Common Combinators</a></h2>
<ul>
<li><code>preceded(a, b)</code>, <code>terminated(a, b)</code>, <code>delimited(a, b, c)</code></li>
<li><code>alt((p1, p2, ...))</code> for alternatives</li>
<li><code>tuple((p1, p2, ...))</code> to sequence</li>
<li><code>separated_list0(sep, item)</code> to parse comma-separated lists</li>
<li><code>map(p, f)</code> to build AST nodes</li>
</ul>
<p>Prefer small, focused parsers composed with these combinators.</p>
<hr />
<h2 id="top-level-entry-points"><a class="header" href="#top-level-entry-points">Top-Level Entry Points</a></h2>
<ul>
<li>Keep clear entry points for precedence chains (e.g., primary → postfix → binary → assignment).</li>
<li>Use wrapper nodes for constructs like <code>New</code>, <code>Invocation</code>, <code>MemberAccess</code>, etc., to keep variants orthogonal in the AST (see <code>bsharp_syntax::expressions::expression.rs</code>).</li>
</ul>
<hr />
<h2 id="testing-parsers"><a class="header" href="#testing-parsers">Testing Parsers</a></h2>
<ul>
<li>Place tests in <code>src/bsharp_tests/src/parser/...</code>.</li>
<li>Parse using <code>Parser::new().parse_with_spans(&amp;source)</code> and assert expected AST shapes.</li>
<li>On failure, pretty-print errors with <code>format_error_tree</code> to diagnose.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn parses_expression_statement() {
    let src = "class C { void M(){ Foo(1); } }";
    let (cu, _spans) = bsharp_parser::facade::Parser::new().parse_with_spans(src).unwrap();
    // Verify expected nodes using Query or pattern matching
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="tips-8"><a class="header" href="#tips-8">Tips</a></h2>
<ul>
<li><strong>Return early with cut</strong> after consuming a keyword to avoid misleading alternatives.</li>
<li><strong>Use complete</strong> for tokens/literals that must not be partial.</li>
<li><strong>all_consuming</strong> at file/compilation-unit to ban trailing garbage.</li>
<li><strong>Context labels</strong>: Be concise and specific; they surface in error messages and docs.</li>
</ul>
<hr />
<h2 id="references-13"><a class="header" href="#references-13">References</a></h2>
<ul>
<li>nom combinator <code>complete</code>: https://docs.rs/nom/8.0.0/nom/combinator/fn.complete.html</li>
<li>nom combinator <code>all_consuming</code>: https://docs.rs/nom/8.0.0/nom/combinator/fn.all_consuming.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compliance"><a class="header" href="#compliance">Compliance</a></h1>
<pre><code class="language-admonish warning">This Compliance section is a work in progress. Content, mappings, and assertions may evolve and change between versions.
</code></pre>
<p>This section documents the Roslyn compliance pipeline and how we validate our <code>bsharp_parser</code> and <code>bsharp_syntax</code> against Roslyn’s structure tests.</p>
<ul>
<li>Start with the high-level <a href="development/compliance/./overview.html">Overview</a></li>
<li>Learn how to write <a href="development/compliance/./compliance_guide.html">Custom Asserts</a></li>
<li>Understand the <a href="development/compliance/./Generator.html">Generator</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compliance-overview"><a class="header" href="#compliance-overview">Compliance Overview</a></h1>
<pre><code class="language-admonish warning">This Compliance section is a work in progress. Content, mappings, and assertions may evolve and change between versions.
</code></pre>
<p>This section describes the Roslyn compliance effort for the C# parser, using our Rust-based <code>bsharp_parser</code> and the <code>bsharp_syntax</code> AST. The goal is to automatically extract structural assertions from Roslyn tests and validate that our AST shape and key payloads match Roslyn’s expectations (normalized to our naming conventions: PascalCase, no "Syntax" suffix).</p>
<h2 id="high-level-flow"><a class="header" href="#high-level-flow">High-Level Flow</a></h2>
<ul>
<li>Source: Roslyn test files in <code>roslyn_testing/roslyn_repo/src/Compilers/CSharp/Test/Syntax/Parsing/</code>.</li>
<li>Extraction: A generator scans for <code>UsingTree(...)</code> blocks and parses the following DSL of <code>N(SyntaxKind.X)</code> nodes.</li>
<li>Translation: The extracted Roslyn tree is translated and normalized to our canonical kinds and structure.</li>
<li>Running: Tests are emitted into <code>bsharp_compliance_testing</code>, parsing provided C# snippets with <code>bsharp_parser</code> and comparing the actual AST with the expected structure.</li>
</ul>
<h2 id="core-components-1"><a class="header" href="#core-components-1">Core Components</a></h2>
<ul>
<li>
<p><code>bsharp_compliance</code> (generator)</p>
<ul>
<li>Reads Roslyn files and extracts structural expected trees.</li>
<li>Parses the Roslyn DSL (<code>N(SyntaxKind.X)</code>, <code>M(...)</code>, <code>EOF()</code>).</li>
<li>Normalizes kinds via <code>kind_map.rs</code> (e.g., <code>RecordStructDeclaration</code> → <code>RecordDeclaration</code>).</li>
<li>Emits Rust tests into <code>bsharp_compliance_testing/src/generated/</code>.</li>
</ul>
</li>
<li>
<p><code>bsharp_compliance_testing</code> (tests &amp; asserts)</p>
<ul>
<li>Contains custom structural assertions in <code>custom_asserts/structure_assert.rs</code>.</li>
<li>Walks real <code>bsharp_syntax</code> nodes to build a comparable <code>ExpectedTree</code>.</li>
<li>Compares node kind shapes and selected token payloads (e.g., identifier text).</li>
</ul>
</li>
</ul>
<h2 id="normalization-principles"><a class="header" href="#normalization-principles">Normalization Principles</a></h2>
<ul>
<li>Node names are PascalCase and omit Roslyn’s <code>...Syntax</code> suffix.</li>
<li>Tokens/keywords are filtered from structure; identifier text is lifted where relevant.</li>
<li>Harness differences (Roslyn’s class-with-method wrappers vs. our top-level statements) are normalized at assert time when needed.</li>
</ul>
<h2 id="what-this-validates"><a class="header" href="#what-this-validates">What This Validates</a></h2>
<ul>
<li>Structural presence and order of major nodes (CompilationUnit, declarations, using directives, type parameters, constraint clauses, etc.).</li>
<li>Selected payloads (e.g., <code>IdentifierName.token_value</code>).</li>
<li>Deeper constructs incrementally (e.g., <code>TypeParameterConstraintClause</code>, “allows ref struct” constraints, record primary parameter lists).</li>
</ul>
<h2 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h2>
<ul>
<li>Expand kind mapping and walker coverage across more Roslyn suites.</li>
<li>Tighten token payload checks where meaningful.</li>
<li>Add targeted hand-authored structure tests for corner cases.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compliance-guide"><a class="header" href="#compliance-guide">Compliance Guide</a></h1>
<pre><code class="language-admonish warning">This Compliance section is a work in progress. Content, mappings, and assertions may evolve and change between versions.
</code></pre>
<p>This guide explains how to write custom asserts for Roslyn compliance tests using our <code>bsharp_compliance_testing</code> helpers. It focuses on structural checks and optional diagnostics checks.</p>
<h2 id="where-custom-asserts-live"><a class="header" href="#where-custom-asserts-live">Where custom asserts live</a></h2>
<ul>
<li>File: <code>roslyn_testing/bsharp_compliance_testing/src/custom_asserts/after_parse.rs</code></li>
<li>Entry points:
<ul>
<li><code>after_parse(...)</code>: lightweight per-case hook for structural or source-based assertions.</li>
<li><code>after_parse_with_expected(...)</code>: adds an optional diagnostics expectation integration.</li>
</ul>
</li>
<li>Helper macro:
<ul>
<li><code>assert_when! { ... }</code> — enables concise, per-case matching on module/file/method/index.</li>
</ul>
</li>
</ul>
<h2 id="using-assert_when"><a class="header" href="#using-assert_when">Using <code>assert_when!</code></a></h2>
<p>The macro lets you target a specific Roslyn case by module name, Roslyn filename, Roslyn test method name, and case index (0-based within the method).</p>
<p>Example for a Statement case:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::custom_asserts::after_parse::{after_parse, CaseData};

pub fn after_parse(
    module: &amp;str,
    roslyn_file: &amp;str,
    roslyn_method: &amp;str,
    idx: usize,
    case: CaseData&lt;'_&gt;,
) {
    assert_when!(
        module = "statement_parsing_tests",
        roslyn_file = "StatementParsingTests",
        roslyn_method = "TestSwitchStatementWithNullableTypeInPattern3",
        idx = 2,
        Statement(ast, src) {
            // Add your targeted assertions here
            assert!(src.contains("switch"));
            // Optional: pattern-match on `ast` when you need structure checks
            // match ast { /* ... */ }
        }
    );
}
<span class="boring">}</span></code></pre></pre>
<p>Example for a File case (full <code>CompilationUnit</code> available):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::custom_asserts::after_parse::{after_parse, CaseData};

pub fn after_parse(
    module: &amp;str,
    roslyn_file: &amp;str,
    roslyn_method: &amp;str,
    idx: usize,
    case: CaseData&lt;'_&gt;,
) {
    assert_when!(
        module = "using_directive_parsing_tests",
        roslyn_file = "UsingDirectiveParsingTests",
        roslyn_method = "SimpleUsingDirectiveNamePointer",
        idx = 0,
        File(unit, src, original) {
            assert!(src.starts_with("using "));
            // `unit` is a &amp;bsharp_syntax::ast::CompilationUnit
            // You can inspect its using directives or declarations if needed.
            assert!(unit.using_directives.len() &gt;= 1);
            let _ = original; // original Roslyn text when provided
        }
    );
}
<span class="boring">}</span></code></pre></pre>
<h2 id="diagnostics-integration"><a class="header" href="#diagnostics-integration">Diagnostics integration</a></h2>
<p>If the generator attaches expected diagnostics, use <code>after_parse_with_expected(...)</code> to compare counts when diagnostics are supported by the build:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::custom_asserts::after_parse::{after_parse_with_expected, CaseData};

pub fn my_integration(
    module: &amp;str,
    roslyn_file: &amp;str,
    roslyn_method: &amp;str,
    idx: usize,
    expected: Option&lt;crate::custom_asserts::roslyn_asserts::ExpectedDiagnostics&gt;,
    case: CaseData&lt;'_&gt;,
) {
    // Runs custom case asserts and then asserts diagnostics count when available
    after_parse_with_expected(module, roslyn_file, roslyn_method, idx, expected, case);
}
<span class="boring">}</span></code></pre></pre>
<p>Notes:</p>
<ul>
<li>When diagnostics support is disabled, the helper asserts with an explicit "unimplemented" fallback to avoid silent failures.</li>
<li>Keep asserts precise and self-contained; prefer checking concrete substrings or specific AST facts.</li>
</ul>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best practices</a></h2>
<ul>
<li>Keep assertions small and focused. Use <code>assert_when!</code> blocks per case.</li>
<li>Avoid brittle assumptions: prefer checking presence/shape over exact token trivia.</li>
<li>Match our naming convention in any structure references (PascalCase, no <code>Syntax</code> suffix).</li>
<li>Fail fast with clear messages; do not silently swallow errors.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generator"><a class="header" href="#generator">Generator</a></h1>
<pre><code class="language-admonish warning">This Compliance section is a work in progress. Content, mappings, and assertions may evolve and change between versions.
</code></pre>
<p>This document describes how the Roslyn structure test generator works in <code>bsharp_compliance</code> and how it produces executable tests for <code>bsharp_compliance_testing</code>.</p>
<h2 id="inputs"><a class="header" href="#inputs">Inputs</a></h2>
<ul>
<li>Roslyn source files under <code>roslyn_testing/roslyn_repo/src/Compilers/CSharp/Test/Syntax/Parsing/</code>.</li>
<li>The generator scans for <code>UsingTree(...)</code> calls and parses the immediately following Roslyn structure DSL composed of <code>N(SyntaxKind.X)</code> and <code>EOF()</code> entries (with <code>M(...)</code> ignored as "missing").</li>
</ul>
<h2 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h2>
<ol>
<li>
<p>Scan and collect test methods</p>
<ul>
<li>Locates Roslyn <code>[Fact]</code> methods and all <code>UsingTree(...)</code> call sites.</li>
<li>Captures the closest preceding <code>var text = "...";</code> snippet as input source, when present.</li>
</ul>
</li>
<li>
<p>Parse structure DSL</p>
<ul>
<li>Reads the DSL block following <code>UsingTree(...)</code> and constructs a nested <code>ExpectedTree</code> (<code>ExpectedNode</code> graph) mirroring the Roslyn node hierarchy.</li>
<li>Tolerates whitespace, comments, and missing markers (<code>M(...)</code>).</li>
</ul>
</li>
<li>
<p>Kind translation and normalization</p>
<ul>
<li><code>generator/kind_map.rs</code> maps Roslyn kinds to our canonical naming (PascalCase, no <code>Syntax</code> suffix).</li>
<li>Filters token/keyword nodes, lifting identifier text (<code>IdentifierToken</code> → parent <code>IdentifierName.token_value</code>).</li>
<li>Applies targeted renames (e.g., <code>RecordStructDeclaration</code> → <code>RecordDeclaration</code>).</li>
</ul>
</li>
<li>
<p>Emit tests</p>
<ul>
<li>Writes Rust tests into <code>bsharp_compliance_testing/src/generated/&lt;module&gt;.rs</code>.</li>
<li>Each test parses the captured <code>src</code> with <code>bsharp_parser</code> and asserts structure via <code>custom_asserts/structure_assert.rs</code>.</li>
</ul>
</li>
</ol>
<h2 id="assertions"><a class="header" href="#assertions">Assertions</a></h2>
<ul>
<li>Structure assertions build a comparable expected tree from our actual AST (<code>bsharp_syntax</code>) and compare:
<ul>
<li>Node kinds and order</li>
<li>Selected token payloads (e.g., <code>IdentifierName.token_value</code>)</li>
</ul>
</li>
<li>Normalization in the assert layer adapts Roslyn’s harness (class + method) to our top-level statements when applicable.</li>
</ul>
<h2 id="extending-the-generator"><a class="header" href="#extending-the-generator">Extending the Generator</a></h2>
<ul>
<li>Update <code>generator/kind_map.rs</code> to add or refine kind mappings.</li>
<li>Expand <code>custom_asserts/structure_assert.rs</code> to walk deeper AST areas (e.g., records, types, constraints).</li>
<li>Improve the DSL parser (<code>generator/structure_dsl.rs</code>) as new Roslyn DSL shapes appear.</li>
</ul>
<h2 id="output-location"><a class="header" href="#output-location">Output Location</a></h2>
<ul>
<li>Generated files live under <code>roslyn_testing/bsharp_compliance_testing/src/generated/</code>.</li>
<li>Modules track Roslyn file groups, e.g. <code>record_parsing.rs</code>, <code>using_directive_parsing_tests.rs</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cil-runtime"><a class="header" href="#cil-runtime">CIL Runtime</a></h1>
<p>This section covers the CIL-based code execution feature, including VM design, dotscope-based IL read/emit, and the AST→IL emitter.</p>
<ul>
<li>See the high-level <a href="cil-runtime/./overview.html">Overview</a> and <a href="cil-runtime/./architecture.html">Architecture</a>.</li>
<li>The implementation plan is broken into <a href="cil-runtime/./phases/README.html">Phases</a>.</li>
<li>For practical IL usage, read the <a href="cil-runtime/../cil-runtime/dotscope-guide.html">dotscope Guide</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cil-runtime--code-execution-overview"><a class="header" href="#cil-runtime--code-execution-overview">CIL Runtime &amp; Code Execution: Overview</a></h1>
<p>This section documents the design and plan for adding whole-code execution to the project using a custom CIL (ECMA-335) virtual machine and the dotscope crate for IL/PE read/write.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<ul>
<li><strong>Back-compat with .NET assemblies</strong>: Load and execute existing IL where feasible.</li>
<li><strong>AST-driven emission</strong>: Emit IL from our parsed AST for a supported C# subset.</li>
<li><strong>Deterministic, testable</strong>: Deterministic interpreter, rich golden tests, reproducible outputs.</li>
<li><strong>Modular</strong>: Clear crates for IL emission, VM, and host runtime.</li>
</ul>
<h2 id="scope-mvp"><a class="header" href="#scope-mvp">Scope (MVP)</a></h2>
<ul>
<li>Primitives: bool, i32/i64, f32/f64.</li>
<li>Control flow: if/else, while/for, switch, return.</li>
<li>Locals/args, arithmetic, comparisons, simple static calls.</li>
<li>Load existing DLLs (limited surface) via dotscope.</li>
</ul>
<h2 id="non-goals-initially"><a class="header" href="#non-goals-initially">Non-goals (initially)</a></h2>
<ul>
<li>Full BCL coverage, GC, reflection, async/await, generics, full verification.</li>
<li>Optimizing JIT (planned later via Cranelift).</li>
</ul>
<h2 id="building-blocks"><a class="header" href="#building-blocks">Building blocks</a></h2>
<ul>
<li><strong>dotscope</strong>: Read/emit IL and metadata (MethodBodyBuilder, <em>Builder</em> APIs, write DLLs).</li>
<li><strong>bsharp_vm</strong>: CIL interpreter (eval stack, frames, basic heap abstractions, host shims).</li>
<li><strong>bsharp_il</strong>: AST→IL emitter leveraging analysis CFG to structure branches.</li>
<li><strong>bsharp_runtime</strong>: Host intrinsics and minimal library surface.</li>
</ul>
<h2 id="integration-with-existing-crates"><a class="header" href="#integration-with-existing-crates">Integration with existing crates</a></h2>
<ul>
<li>Reuse parser/AST and analysis pipeline. Use analysis control flow graph (CFG) to drive structured emission (labels/branches) instead of serial AST-only lowering.</li>
</ul>
<h2 id="long-term-direction"><a class="header" href="#long-term-direction">Long-term direction</a></h2>
<ul>
<li>Expand IL/VM feature coverage (objects, exceptions, arrays, virtual dispatch).</li>
<li>Optional native backend via Cranelift using the same loader/type system.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h1>
<p>This document describes the architecture for CIL-based code execution using dotscope.</p>
<h2 id="crates-and-modules"><a class="header" href="#crates-and-modules">Crates and modules</a></h2>
<ul>
<li><strong>bsharp_il/</strong>: AST→IL emitter using dotscope builders.</li>
<li><strong>bsharp_vm/</strong>: CIL interpreter (eval stack, frames, loader, binder).</li>
<li><strong>bsharp_runtime/</strong>: Host intrinsics and minimal library.</li>
<li><strong>bsharp_cli/</strong>: Commands to run/inspect assemblies.</li>
</ul>
<h2 id="data-flow"><a class="header" href="#data-flow">Data flow</a></h2>
<pre><code class="language-mermaid">flowchart LR
  Parser[Parser -&gt; AST] --&gt; CFG[Analysis CFG]
  CFG --&gt; Emitter[AST-&gt;IL Emitter]
  AST --&gt; Emitter
  Emitter --&gt; Assembly[CilAssembly + BuilderContext]
  Assembly --&gt; DLL[Write DLL]
  DLL --&gt; Loader[dotscope Loader]
  ExtDLL[Existing .NET DLL] --&gt; Loader
  Loader --&gt; VM[CIL VM]
  VM --&gt; Host[bsharp_runtime]
</code></pre>
<h2 id="integration-points-1"><a class="header" href="#integration-points-1">Integration points</a></h2>
<ul>
<li><code>bsharp_analysis/src/artifacts/control_flow_graph/</code>: provide structured blocks and edges to guide IL labels/branches.</li>
<li>dotscope: <code>MethodBodyBuilder</code>, metadata table builders, <code>CilAssembly</code> write.</li>
<li>VM loader: <code>CilAssemblyView</code> to parse and resolve tokens.</li>
</ul>
<h2 id="error-handling-8"><a class="header" href="#error-handling-8">Error handling</a></h2>
<ul>
<li>Deterministic interpreter errors with rich diagnostics (opcode, offset, stack types).</li>
<li>Validation gates in emitter (e.g., unsupported constructs) produce actionable errors.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="phases-2"><a class="header" href="#phases-2">Phases</a></h1>
<!-- This file mirrors docs/cil-runtime/phases.md to make "Phases" a directory chapter for mdBook. -->
<h2 id="phase-0-dotscope-spike"><a class="header" href="#phase-0-dotscope-spike">Phase 0: Dotscope spike</a></h2>
<ul>
<li><strong>Goals</strong>
<ul>
<li>Validate dotscope API surface for PE/metadata/IL read &amp; emit.</li>
<li>Establish patterns for builder context and method body assembly.</li>
</ul>
</li>
<li><strong>Tasks</strong>
<ul>
<li>Load an assembly with <code>CilAssemblyView::from_file()</code>; enumerate types/methods and obtain method bodies.</li>
<li>Disassemble a method using <code>assembly</code> module facilities (instruction stream + operands) for inspection.</li>
<li>Create a mutable assembly: <code>let mut asm = CilAssembly::new(view); let mut ctx = BuilderContext::new(asm);</code>.</li>
<li>Build a method body with <code>MethodBodyBuilder::implementation(|asm: &amp;mut InstructionAssembler| { ... })</code> and <code>build(&amp;mut ctx)</code>.</li>
<li>Persist using <code>ctx.finish().write_to_file("out.dll")</code> or <code>CilAssembly::write_to_file</code>.</li>
</ul>
</li>
<li><strong>Deliverables</strong>
<ul>
<li>Example program that prints disassembly for a sample method.</li>
<li>Example that emits a simple <code>add(i32,i32)</code> method and writes a valid DLL.</li>
</ul>
</li>
<li><strong>Acceptance</strong>
<ul>
<li>Emitted DLL round-trips: reload with dotscope and method body bytes decode with expected instructions.</li>
</ul>
</li>
</ul>
<h2 id="phase-1-vm-mvp"><a class="header" href="#phase-1-vm-mvp">Phase 1: VM MVP</a></h2>
<ul>
<li><strong>Goals</strong>
<ul>
<li>Execute simple static methods with primitives and basic control flow.</li>
</ul>
</li>
<li><strong>Tasks</strong> (see per-phase doc for details)</li>
</ul>
<h2 id="phase-2-control-flow--eh"><a class="header" href="#phase-2-control-flow--eh">Phase 2: Control flow + EH</a></h2>
<ul>
<li><strong>Goals</strong>
<ul>
<li>Support richer branching and basic exception handling semantics.</li>
</ul>
</li>
</ul>
<h2 id="phase-3-object-model-subset"><a class="header" href="#phase-3-object-model-subset">Phase 3: Object model (subset)</a></h2>
<ul>
<li><strong>Goals</strong>
<ul>
<li>Introduce instances, fields, instance calls, and arrays.</li>
</ul>
</li>
</ul>
<h2 id="phase-4-back-compat-polish"><a class="header" href="#phase-4-back-compat-polish">Phase 4: Back-compat polish</a></h2>
<ul>
<li><strong>Goals</strong>
<ul>
<li>Improve compatibility with existing assemblies and interop.</li>
</ul>
</li>
</ul>
<h2 id="phase-5-astil-emitter"><a class="header" href="#phase-5-astil-emitter">Phase 5: AST→IL emitter</a></h2>
<ul>
<li><strong>Goals</strong>
<ul>
<li>Emit IL/DLLs from our AST using dotscope; ensure parity with the VM and .NET runtime.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="phase-0-dotscope-spike-reademit"><a class="header" href="#phase-0-dotscope-spike-reademit">Phase 0: Dotscope Spike (Read/Emit)</a></h1>
<h2 id="goals-1"><a class="header" href="#goals-1">Goals</a></h2>
<ul>
<li><strong>Validate</strong> dotscope API surface for PE/metadata/IL read &amp; emit.</li>
<li><strong>Establish</strong> patterns for builder context and method body assembly.</li>
</ul>
<h2 id="detailed-tasks"><a class="header" href="#detailed-tasks">Detailed tasks</a></h2>
<ul>
<li><strong>load-assembly</strong> Load an assembly and enumerate content
<ul>
<li>Use <code>CilAssemblyView::from_file(path)</code> to open an input DLL.</li>
<li>Enumerate types/methods via metadata tables; for each managed method fetch body bytes if present.</li>
<li>Disassemble one method using dotscope's <code>assembly</code> module instruction processing to inspect opcodes and operands.</li>
</ul>
</li>
<li><strong>mutable-assembly</strong> Create a mutable assembly for editing and writing
<ul>
<li>Wrap the view with <code>CilAssembly::new(view)</code> and <code>BuilderContext::new(assembly)</code>.</li>
<li>Confirm <code>BuilderContext::finish()</code> returns <code>CilAssembly</code> and supports <code>write_to_file()</code>.</li>
</ul>
</li>
<li><strong>emit-method</strong> Build a simple method body
<ul>
<li>Use <code>MethodBodyBuilder::new().implementation(|asm| { asm.ldarg_0()?.ldarg_1()?.add()?.ret()?; Ok(()) })</code>.</li>
<li>Call <code>.build(&amp;mut context)</code> to produce <code>(bytes, local_sig_token)</code>.</li>
<li>Create necessary metadata (assembly, type, method) using table builders; attach method body.</li>
<li>Persist to <code>output.dll</code> using <code>write_to_file</code>.</li>
</ul>
</li>
<li><strong>roundtrip</strong> Reload and verify
<ul>
<li>Load <code>output.dll</code> with <code>CilAssemblyView</code>.</li>
<li>Disassemble the emitted method and verify expected instruction sequence.</li>
</ul>
</li>
</ul>
<h2 id="deliverables"><a class="header" href="#deliverables">Deliverables</a></h2>
<ul>
<li><strong>disasm example</strong>: CLI or test that prints IL for a chosen method.</li>
<li><strong>emit example</strong>: CLI or test that writes <code>add(i32,i32)</code> method into a DLL and round-trips via disassembly.</li>
</ul>
<h2 id="acceptance-criteria"><a class="header" href="#acceptance-criteria">Acceptance criteria</a></h2>
<ul>
<li>Emitted DLL round-trips: reload and decode bytes into expected instructions.</li>
<li>Examples run deterministically and are added to CI.</li>
</ul>
<h2 id="references-14"><a class="header" href="#references-14">References</a></h2>
<ul>
<li>dotscope assembly module (disassembly/assembly): docs.rs/dotscope/latest/dotscope/assembly/index.html</li>
<li><code>CilAssembly</code>, <code>BuilderContext</code>: docs.rs/dotscope/latest/dotscope/struct.CilAssembly.html, docs.rs/dotscope/latest/dotscope/struct.BuilderContext.html</li>
<li><code>MethodBodyBuilder</code>, <code>InstructionAssembler</code>: docs.rs/dotscope/latest/dotscope/struct.MethodBodyBuilder.html, docs.rs/dotscope/latest/dotscope/assembly/struct.InstructionAssembler.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="phase-1-vm-mvp-1"><a class="header" href="#phase-1-vm-mvp-1">Phase 1: VM MVP</a></h1>
<h2 id="goals-2"><a class="header" href="#goals-2">Goals</a></h2>
<ul>
<li>Execute simple static methods with primitives and basic control flow.</li>
<li>Deterministic interpreter with clear errors for unsupported opcodes.</li>
</ul>
<h2 id="detailed-tasks-1"><a class="header" href="#detailed-tasks-1">Detailed tasks</a></h2>
<ul>
<li><strong>runtime-values</strong> Define runtime types
<ul>
<li><code>Value</code>: bool, i32/i64, f32/f64, (opaque) object ref, (opaque) string handle (planned), Null.</li>
<li>Numeric conversions (implicit in MVP avoided; explicit <code>conv.*</code> deferred to Phase 4).</li>
</ul>
</li>
<li><strong>frames</strong> Implement frames and call stack
<ul>
<li>Frame: args, locals, evaluation stack (Vec<Value>), instruction pointer (u32 offset), method handle.</li>
<li>Stack discipline: push/pop per opcode; underflow/overflow checks with good diagnostics (offset, opcode).</li>
</ul>
</li>
<li><strong>loader</strong> Load IL and metadata with dotscope
<ul>
<li>Use <code>CilAssemblyView::from_file(path)</code> to load DLLs.</li>
<li>For a <code>MethodDef</code>, obtain method body bytes + header; optionally disassemble via <code>assembly</code> module for debugging.</li>
</ul>
</li>
<li><strong>decoder</strong> Instruction decoding
<ul>
<li>Implement a minimal decoder (or iterate via dotscope disassembly) for:
<ul>
<li><code>ldc.i4</code>, <code>ldc.i8</code>, <code>ldc.r4</code>, <code>ldc.r8</code>, short forms where convenient.</li>
<li><code>ldloc.*</code>/<code>stloc.*</code>, <code>ldarg.*</code>/<code>starg.*</code> (including short forms <code>_0</code>..<code>_3</code>).</li>
<li><code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>rem</code> for ints/floats (MVP: matching operand types only).</li>
<li><code>ceq</code>, <code>clt</code>, <code>cgt</code> → bool.</li>
<li>Branching: <code>br</code>/<code>br.s</code>, <code>brtrue</code>/<code>brfalse</code> with signed relative offsets.</li>
<li><code>ret</code>.</li>
<li><code>call</code> (static) within same module.</li>
</ul>
</li>
</ul>
</li>
<li><strong>calls</strong> Static calls
<ul>
<li>Resolve <code>MethodDef</code>/<code>MemberRef</code> to a method body within the same <code>CilAssemblyView</code>.</li>
<li>Create new frame with provided args; return pushes result if any.</li>
</ul>
</li>
<li><strong>host-intrinsics</strong> Minimal IO
<ul>
<li>Register a small set of host intrinsics (e.g., <code>Console.WriteLine(int)</code> equivalent) mapped by token to Rust closures.</li>
<li>MVP: avoid strings; provide <code>print_i32</code> style helper.</li>
</ul>
</li>
</ul>
<h2 id="deliverables-1"><a class="header" href="#deliverables-1">Deliverables</a></h2>
<ul>
<li><code>bsharp_vm</code> crate with:
<ul>
<li>Value model, frame/stack, interpreter loop, loader.</li>
<li>Unit tests covering arithmetic, comparisons, branches, locals/args, static calls, <code>ret</code>.</li>
</ul>
</li>
</ul>
<h2 id="acceptance-criteria-1"><a class="header" href="#acceptance-criteria-1">Acceptance criteria</a></h2>
<ul>
<li>Deterministic execution of hand-authored IL methods created via dotscope’s <code>MethodBodyBuilder</code>.</li>
<li>Clear error on unknown opcode with IL offset and mnemonic (if available).</li>
</ul>
<h2 id="references-15"><a class="header" href="#references-15">References</a></h2>
<ul>
<li>dotscope <code>CilAssemblyView</code>, <code>assembly</code> module, method body access.</li>
<li>ECMA-335 Partition III (CIL Instruction Set).</li>
<li>Microsoft Learn: <code>System.Reflection.Emit.OpCodes</code> for per-opcode semantics and short forms.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="phase-2-control-flow--exception-handling-eh"><a class="header" href="#phase-2-control-flow--exception-handling-eh">Phase 2: Control Flow + Exception Handling (EH)</a></h1>
<h2 id="goals-3"><a class="header" href="#goals-3">Goals</a></h2>
<ul>
<li>Add richer branching (<code>switch</code>, <code>leave</code>) and structured EH (try/catch/finally) to the VM and validate emission paths.</li>
</ul>
<h2 id="detailed-tasks-2"><a class="header" href="#detailed-tasks-2">Detailed tasks</a></h2>
<ul>
<li><strong>switch</strong> Implement <code>switch</code>
<ul>
<li>Decode switch table (N targets + base) and compute absolute branch targets from relative offsets.</li>
<li>Update IP by index lookup; validate index bounds; fall-through to next instruction on no match (per IL semantics, <code>switch</code> jumps or falls through?).</li>
</ul>
</li>
<li><strong>leave</strong> Implement <code>leave</code>/<code>leave.s</code>
<ul>
<li>Transfer control out of current protected region to target; ensure pending <code>finally</code> handlers execute.</li>
</ul>
</li>
<li><strong>eh-parse</strong> Parse EH clauses from dotscope
<ul>
<li>For each method body, use dotscope to obtain EH sections (try start/len, handler start/len, flags: catch/filter/finally/fault, catch type token).</li>
<li>Store clauses in runtime metadata for fast lookup by offset.</li>
</ul>
</li>
<li><strong>eh-runtime</strong> Unwinding and handlers
<ul>
<li>On <code>throw</code> and on <code>leave</code>, search current method’s EH table for matching handler: order per ECMA-335.</li>
<li>Implement catch (typed and any), finally (always run on exit of protected region), fault (run on exceptional exit only).</li>
<li>Implement filter (phase 2.5 optional): evaluate filter method body region and branch accordingly.</li>
</ul>
</li>
<li><strong>emission-demo</strong> Emission with <code>MethodBodyBuilder</code>
<ul>
<li>Author sample try/catch/finally using label-based helpers (<code>catch_handler</code>, <code>finally_handler</code>, <code>*_with_labels</code>).</li>
<li>Validate VM executes handlers in correct order (finally runs on both normal and exceptional paths).</li>
</ul>
</li>
<li><strong>diagnostics</strong> Error reporting
<ul>
<li>On unhandled exception, produce a stack trace of frames with IL offsets; include method tokens and optionally sequence points (future).</li>
</ul>
</li>
</ul>
<h2 id="deliverables-2"><a class="header" href="#deliverables-2">Deliverables</a></h2>
<ul>
<li>VM support for <code>switch</code>, <code>leave</code>, <code>throw</code>, catch/finally EH.</li>
<li>Sample emitted methods with EH and a test suite for normal and exceptional flows.</li>
</ul>
<h2 id="acceptance-criteria-2"><a class="header" href="#acceptance-criteria-2">Acceptance criteria</a></h2>
<ul>
<li>Unit tests cover: multi-branch switch; nested try/catch; try/finally; <code>leave</code> jumping out through finally; rethrow behavior.</li>
<li>Emitted EH via dotscope decodes and runs identically in the VM.</li>
</ul>
<h2 id="references-16"><a class="header" href="#references-16">References</a></h2>
<ul>
<li>dotscope method body + EH helpers: <code>MethodBodyBuilder</code>.</li>
<li>ECMA-335 Partition III: <code>switch</code>, <code>leave</code>, EH table semantics.</li>
<li>Microsoft Learn: Exception handling clauses (<code>ExceptionHandlingClauseOptions</code>), <code>OpCodes.Throw</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="phase-3-object-model-subset-and-arrays"><a class="header" href="#phase-3-object-model-subset-and-arrays">Phase 3: Object Model (Subset) and Arrays</a></h1>
<h2 id="goals-4"><a class="header" href="#goals-4">Goals</a></h2>
<ul>
<li>Introduce instances, fields, instance calls, basic virtual dispatch, and arrays.</li>
<li>Support <code>newobj</code>, <code>ldfld</code>/<code>stfld</code>, <code>ldsfld</code>/<code>stsfld</code>, <code>call</code> (instance), first-pass <code>callvirt</code>, <code>newarr</code>, <code>ldlen</code>, <code>ldelem.*</code>, <code>stelem.*</code>, <code>ldelema</code>.</li>
</ul>
<h2 id="detailed-tasks-3"><a class="header" href="#detailed-tasks-3">Detailed tasks</a></h2>
<ul>
<li><strong>rt-types</strong> Runtime type info (RTTI)
<ul>
<li>Build runtime descriptors from metadata tables (TypeDef, Field, MethodDef) loaded via dotscope.</li>
<li>Represent:
<ul>
<li>Type identity handle (assembly-qualified), field layout (offsets), method table (slots) for non-interface classes.</li>
<li>Method signatures for call/callvirt resolution.</li>
</ul>
</li>
</ul>
</li>
<li><strong>object-layout</strong> Object representation
<ul>
<li>Define an opaque <code>Object</code> struct with:
<ul>
<li>Header (type handle, flags), field storage (contiguous, primitive only in MVP), optional sync block placeholder.</li>
</ul>
</li>
<li>Static fields: per-type storage map keyed by FieldDef token.</li>
</ul>
</li>
<li><strong>newobj</strong> Allocation and constructors
<ul>
<li>Implement <code>newobj</code>:
<ul>
<li>Allocate <code>Object</code> using the target type’s layout.</li>
<li>Immediately invoke the referenced constructor (MethodDef/MemberRef), passing <code>this</code> and args.</li>
</ul>
</li>
</ul>
</li>
<li><strong>field-access</strong> Field opcodes
<ul>
<li>Implement <code>ldfld</code>/<code>stfld</code> and <code>ldsfld</code>/<code>stsfld</code>:
<ul>
<li>Resolve field token to (type, offset, typeSig).</li>
<li>Null-check for instance field access.</li>
<li>Copy between eval stack and storage with type checks.</li>
</ul>
</li>
</ul>
</li>
<li><strong>instance-calls</strong> Instance invocation
<ul>
<li><code>call</code> on instance methods: no virtual dispatch, but pass <code>this</code> (null-check in caller or callee per spec of call vs callvirt).</li>
<li><code>callvirt</code> (first pass):
<ul>
<li>Null-check on <code>this</code>.</li>
<li>Resolve slot by method signature in the receiver’s method table (no interfaces in MVP).</li>
<li>Devirtualize if exact type known.</li>
</ul>
</li>
</ul>
</li>
<li><strong>strings</strong> Literal strings
<ul>
<li>Implement <code>ldstr</code>:
<ul>
<li>Intern pool mapping tokens to runtime string handles.</li>
<li>Treat strings as opaque references (printable via host intrinsic), defer full <code>System.String</code> semantics.</li>
</ul>
</li>
</ul>
</li>
<li><strong>arrays</strong> Single-dimensional, zero-based (SZARRAY)
<ul>
<li><code>newarr</code> allocates array object with element type and length; store contiguous elements.</li>
<li><code>ldlen</code> loads length as <code>native int</code> (map to i32/i64 depending on target; MVP: i32).</li>
<li><code>ldelem.*</code>/<code>stelem.*</code> for primitive element types with bounds checks.</li>
<li><code>ldelema</code> returns managed pointer; MVP: return an opaque reference usable only by paired indirection opcodes (defer unsafe ops).</li>
</ul>
</li>
<li><strong>interop-surface</strong> Minimal <code>System.Object</code>
<ul>
<li>Provide basic <code>Object</code> semantics (Equals reference, GetHashCode placeholder), optional <code>ToString</code> via host shim.</li>
</ul>
</li>
<li><strong>diagnostics</strong>
<ul>
<li>Error on mismatched field types, null <code>this</code> for instance access, out-of-bounds array indices.</li>
</ul>
</li>
</ul>
<h2 id="deliverables-3"><a class="header" href="#deliverables-3">Deliverables</a></h2>
<ul>
<li>VM implements object/field/instance-calls and array instructions for primitives.</li>
<li>Tests covering constructors, instance fields, instance methods, callvirt dispatch on a small hierarchy, arrays creation/indexing, <code>ldstr</code>.</li>
</ul>
<h2 id="acceptance-criteria-3"><a class="header" href="#acceptance-criteria-3">Acceptance criteria</a></h2>
<ul>
<li>All new opcodes are executed with correct stack behavior and type checks.</li>
<li><code>callvirt</code> null-check enforced; dispatch correct for overridden methods (non-interface).</li>
<li>Arrays enforce bounds; <code>ldlen</code> returns expected values.</li>
</ul>
<h2 id="references-17"><a class="header" href="#references-17">References</a></h2>
<ul>
<li>ECMA-335 Partition II (metadata) and III (object/field/array opcodes and semantics).</li>
<li>Microsoft Learn: <code>OpCodes.Stfld</code>, <code>OpCodes.Ldloca</code>, <code>OpCodes.Throw</code> (for error paths), <code>OpCodes.Box</code> (later phases).</li>
<li>dotscope metadata: building/resolving TypeDef/Field/MethodDef and <code>ldstr</code> heap entries.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="phase-4-back-compat-polish-1"><a class="header" href="#phase-4-back-compat-polish-1">Phase 4: Back-Compat Polish</a></h1>
<h2 id="goals-5"><a class="header" href="#goals-5">Goals</a></h2>
<ul>
<li>Improve compatibility with existing .NET assemblies and platform interop.</li>
<li>Add conversions, cross-module resolution, P/Invoke, and basic verification/guards.</li>
</ul>
<h2 id="detailed-tasks-4"><a class="header" href="#detailed-tasks-4">Detailed tasks</a></h2>
<ul>
<li><strong>multimodule</strong> Cross-module resolution
<ul>
<li>Load referenced modules/assemblies using <code>AssemblyRef</code>/<code>ModuleRef</code> from metadata (dotscope view per file).</li>
<li>Build a resolver that maps tokens across modules to runtime handles (types, fields, methods).</li>
<li>Cache resolution results to avoid repeated metadata traversals.</li>
</ul>
</li>
<li><strong>pinvoke</strong> P/Invoke via ImplMap
<ul>
<li>Parse <code>ImplMap</code> table entries; bind to host-native call surface under a feature gate.</li>
<li>Respect <code>PInvokeAttributes</code> (calling convention, char set, SetLastError) as possible in MVP; document limitations.</li>
<li>Provide safe wrappers and a config switch to disable native interop by default.</li>
</ul>
</li>
<li><strong>conversions</strong> Numeric conversions
<ul>
<li>Implement <code>conv.*</code> opcodes for supported primitives (<code>conv.i1/i2/i4/i8</code>, <code>conv.u1/u2/u4/u8</code>, <code>conv.r4/r8</code>, <code>conv.ovf.*</code> deferred or limited).</li>
<li>Define truncation/overflow semantics; for <code>ovf</code> forms, return error or panic per configuration if overflow occurs.</li>
</ul>
</li>
<li><strong>verification</strong> Minimal verification/guards
<ul>
<li>Runtime checks: stack underflow/overflow, type compatibility on arithmetic and stores, null checks on <code>callvirt</code>.</li>
<li>Optional pre-execution pass: quick stack-effect scan for obvious inconsistencies; configurable strict mode.</li>
</ul>
</li>
<li><strong>strings</strong> String interop improvements
<ul>
<li>Expand <code>ldstr</code> handling: intern pool + provide host shims for basic concatenation/compare/print if needed.</li>
<li>Consider mapping a minimal subset of <code>System.String</code> methods to host intrinsics.</li>
</ul>
</li>
<li><strong>profiling</strong> Performance scaffolding
<ul>
<li>Add simple counters/timers around interpreter dispatch, calls, allocations.</li>
<li>Prepare seam for alternate backend (Cranelift) behind a trait.</li>
</ul>
</li>
</ul>
<h2 id="deliverables-4"><a class="header" href="#deliverables-4">Deliverables</a></h2>
<ul>
<li>Multi-assembly loader + resolver.</li>
<li>P/Invoke demo guarded by a flag.</li>
<li>Conversion opcodes implemented with tests.</li>
<li>Basic verification errors with actionable diagnostics.</li>
</ul>
<h2 id="acceptance-criteria-4"><a class="header" href="#acceptance-criteria-4">Acceptance criteria</a></h2>
<ul>
<li>Successfully load and execute sample assemblies with cross-module calls.</li>
<li>P/Invoke sample works when enabled and is safely disabled by default.</li>
<li>Conversions tested across boundary values; verification catches common issues in tests.</li>
</ul>
<h2 id="references-18"><a class="header" href="#references-18">References</a></h2>
<ul>
<li>dotscope metadata: <code>AssemblyRef</code>, <code>ModuleRef</code>, <code>ImplMapBuilder</code>/<code>NativeImportsBuilder</code> (for emission tests).</li>
<li>ECMA-335 Partition II (metadata resolution) and III (<code>conv.*</code>, <code>calli</code> deferred).</li>
<li>Microsoft Learn: <code>PInvokeAttributes</code>, conversion opcode semantics.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="phase-5-astil-emitter-dotscope"><a class="header" href="#phase-5-astil-emitter-dotscope">Phase 5: AST→IL Emitter (dotscope)</a></h1>
<h2 id="goals-6"><a class="header" href="#goals-6">Goals</a></h2>
<ul>
<li>Emit IL/DLLs from our AST using dotscope, structured by the analysis CFG, and validate by dual execution (our VM and .NET).</li>
<li>Provide a deterministic, well-instrumented lowering pipeline with actionable diagnostics when constructs are unsupported.</li>
</ul>
<h2 id="detailed-tasks-5"><a class="header" href="#detailed-tasks-5">Detailed tasks</a></h2>
<ul>
<li><strong>inputs</strong> Inputs and prerequisites
<ul>
<li>AST from <code>bsharp_parser</code> nodes and expressions.</li>
<li><code>control_flow_graph</code> from <code>bsharp_analysis/src/artifacts/control_flow_graph/</code> to create labeled blocks and branches.</li>
<li>Symbol/binding information for locals/params/method references (extend current indexing pass to a binder map).</li>
</ul>
</li>
<li><strong>setup</strong> Emitter scaffolding
<ul>
<li>Create crate <code>bsharp_il</code> with modules: <code>lowering</code>, <code>metadata</code>, <code>types</code>, <code>errors</code>.</li>
<li>Initialize <code>CilAssembly</code> and <code>BuilderContext</code> for the target assembly; map namespaces/types from AST to metadata table entries.</li>
</ul>
</li>
<li><strong>types</strong> Type mapping
<ul>
<li>Map AST types to ECMA-335 signatures: bool → <code>TypeSignature::Boolean</code>, int → <code>I4</code>, long → <code>I8</code>, float/double → <code>R4/R8</code>, void → <code>Void</code>.</li>
<li>For method signatures, build param and return type signatures; store calling convention (default).</li>
</ul>
</li>
<li><strong>locals</strong> Locals and arguments
<ul>
<li>Pre-scan method bodies to declare locals: use <code>MethodBodyBuilder.local(name, TypeSignature)</code>; preserve stable local index order.</li>
<li>Provide a mapping LocalId → index for use during lowering.</li>
</ul>
</li>
<li><strong>expr</strong> Expression lowering to stack IL
<ul>
<li>Literals: <code>ldc.i4/i8/r4/r8</code>, <code>ldnull</code>.</li>
<li>Identifiers: <code>ldarg.*</code>, <code>ldloc.*</code>/<code>stloc.*</code> based on binding.</li>
<li>Unary/binary: map to arithmetic/comparison opcodes; ensure operand type cohesion (insert <code>conv.*</code> only if explicit cast in AST; implicit conversions deferred).</li>
<li>Calls: static method calls use token resolution (MethodDef/MemberRef) with <code>call</code>.</li>
<li>Object/array constructs (post Phase 3): <code>newobj</code>, <code>newarr</code>, element access via <code>ldelem.*</code>/<code>stelem.*</code>.</li>
</ul>
</li>
<li><strong>stmt</strong> Statement/control-flow lowering with CFG
<ul>
<li>Build <code>MethodBodyBuilder::implementation(|asm| { ... })</code> using labels:
<ul>
<li>Create labels for CFG basic blocks, emit code for each block’s statements, end with a branch/ret per terminator.</li>
<li><code>if/else</code>: evaluate condition, <code>brtrue</code>/<code>brfalse</code> to labeled blocks, join at merge label.</li>
<li>Loops (while/for): loop head label, body label, back-edge <code>br</code> to head; <code>break</code>/<code>continue</code> map to appropriate labels.</li>
<li><code>switch</code>: emit evaluation and <code>switch</code> with case label table; fall-through blocks join at a common label.</li>
</ul>
</li>
<li>Returns: <code>ret</code> with value if any.</li>
</ul>
</li>
<li><strong>eh</strong> Exception handling lowering
<ul>
<li>Use <code>MethodBodyBuilder</code> EH helpers (ranges via labels) to encode try/catch/finally; ensure try/handler label ranges match emitted code.</li>
<li>Typed catch: resolve exception type token; finally regions always run on exit paths.</li>
</ul>
</li>
<li><strong>metadata</strong> Metadata emission
<ul>
<li>Use <code>AssemblyBuilder</code> to define assembly identity (name, version, culture).</li>
<li>Define <code>TypeDef</code> entries for emitted types; <code>MethodDef</code> entries with body RVA and local sig token returned by <code>build()</code>.</li>
<li>For external references, emit <code>TypeRef</code>/<code>MemberRef</code> entries; record <code>AssemblyRef</code> for external assemblies.</li>
</ul>
</li>
<li><strong>validation</strong> Validation and diagnostics
<ul>
<li>Validate stack discipline during lowering (track expected stack depth per CFG block) and report mismatches early with AST locations.</li>
<li>Emit clear errors for unsupported AST constructs at this phase, suggesting later phase coverage.</li>
</ul>
</li>
<li><strong>persist</strong> Persistence and round-trip
<ul>
<li>Finalize via <code>context.finish()</code> and <code>write_to_file("out.dll")</code>.</li>
<li>Reload with <code>CilAssemblyView</code> and disassemble selected methods for snapshot testing.</li>
</ul>
</li>
<li><strong>dual-run</strong> Dual execution
<ul>
<li>Execute emitted methods on <code>bsharp_vm</code> and, optionally, on .NET via hosting or a test harness; compare outputs for conformance.</li>
</ul>
</li>
</ul>
<h2 id="deliverables-5"><a class="header" href="#deliverables-5">Deliverables</a></h2>
<ul>
<li><code>bsharp_il</code> crate capable of emitting a subset of C# methods to IL/PE using dotscope.</li>
<li>E2E tests: parse → emit → reload/disassemble → run in VM → assert results; optional .NET run for parity.</li>
</ul>
<h2 id="acceptance-criteria-5"><a class="header" href="#acceptance-criteria-5">Acceptance criteria</a></h2>
<ul>
<li>Emitted DLLs are valid and loadable by dotscope; method bodies decode to expected instruction sequences.</li>
<li>For the supported subset, VM and .NET produce identical observable results.</li>
</ul>
<h2 id="references-19"><a class="header" href="#references-19">References</a></h2>
<ul>
<li>dotscope: <code>MethodBodyBuilder</code>, <code>InstructionAssembler</code>, <code>CilAssembly</code>, <code>BuilderContext</code>, metadata table builders.</li>
<li>ECMA-335 Partitions II (metadata) and III (CIL instruction set) for signatures/opcodes and EH encoding.</li>
<li>Microsoft Learn: <code>System.Reflection.Emit.OpCodes</code> pages for per-opcode semantics and short forms.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dotscope-guide-reademit"><a class="header" href="#dotscope-guide-reademit">dotscope Guide (Read/Emit)</a></h1>
<h2 id="reading-assemblies"><a class="header" href="#reading-assemblies">Reading assemblies</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dotscope::CilAssemblyView;
let view = CilAssemblyView::from_file("input.dll")?;
// enumerate types/methods, read method bodies
<span class="boring">}</span></code></pre></pre>
<h2 id="emitting-assemblies"><a class="header" href="#emitting-assemblies">Emitting assemblies</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dotscope::{CilAssembly, MethodBodyBuilder, BuilderContext};
let view = dotscope::CilAssemblyView::from_file("base.dll")?;
let mut assembly = CilAssembly::new(view);
let mut ctx = BuilderContext::new(assembly);

let (body, locals_sig) = MethodBodyBuilder::new()
    .max_stack(2)
    .implementation(|asm| {
        asm.ldarg_0()?.ldarg_1()?.add()?.ret()?; Ok(())
    })
    .build(&amp;mut ctx)?;

// Create/modify metadata tables (Assembly, TypeDef, MethodDef, etc.)
// Then write file:
ctx.assembly.write_to_file("output.dll")?;
<span class="boring">}</span></code></pre></pre>
<h2 id="metadata-builders"><a class="header" href="#metadata-builders">Metadata builders</a></h2>
<ul>
<li><code>AssemblyBuilder</code>: create assembly identity.</li>
<li><code>NativeImportsBuilder</code>/<code>NativeExportsBuilder</code>: import/export tables.</li>
<li><code>ImplMapBuilder</code>: P/Invoke mapping.</li>
</ul>
<h2 id="method-bodies-and-eh"><a class="header" href="#method-bodies-and-eh">Method bodies and EH</a></h2>
<ul>
<li>Build tiny or fat bodies automatically.</li>
<li>Use label-based helpers for EH (catch/finally) when lowering structured constructs.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vm-design"><a class="header" href="#vm-design">VM Design</a></h1>
<h2 id="runtime-model"><a class="header" href="#runtime-model">Runtime model</a></h2>
<ul>
<li><strong>Value</strong>: bool, i32/i64, f32/f64, ref(object), array, string handle.</li>
<li><strong>Frame</strong>: args, locals, eval stack, instruction pointer.</li>
<li><strong>Heap</strong>: opaque objects initially; field tables later.</li>
</ul>
<h2 id="interpreter-loop"><a class="header" href="#interpreter-loop">Interpreter loop</a></h2>
<ul>
<li>Decode IL at offset; dispatch on opcode.</li>
<li>Implement subset first: constants, loads/stores, arithmetic, comparisons, branches, returns, static calls.</li>
</ul>
<h2 id="loader-and-binder"><a class="header" href="#loader-and-binder">Loader and binder</a></h2>
<ul>
<li>Load with <code>CilAssemblyView</code>.</li>
<li>Resolve tokens to runtime handles (types, methods, fields).</li>
</ul>
<h2 id="exceptions-phase-2"><a class="header" href="#exceptions-phase-2">Exceptions (phase 2)</a></h2>
<ul>
<li>Parse EH clauses.</li>
<li>Unwinding: scan frames, match try/catch, run finally.</li>
</ul>
<h2 id="host-interop"><a class="header" href="#host-interop">Host interop</a></h2>
<ul>
<li>Registry mapping specific MemberRefs/MethodDefs to Rust functions.</li>
<li>Gradually add P/Invoke support (ImplMap) for native calls.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="emitter-design-astil"><a class="header" href="#emitter-design-astil">Emitter Design (AST→IL)</a></h1>
<h2 id="inputs-1"><a class="header" href="#inputs-1">Inputs</a></h2>
<ul>
<li>AST from <code>bsharp_parser</code>.</li>
<li>Analysis CFG from <code>bsharp_analysis/src/artifacts/control_flow_graph/</code> to structure branches.</li>
</ul>
<h2 id="strategy"><a class="header" href="#strategy">Strategy</a></h2>
<ul>
<li>Expressions lower to evaluation stack IL.</li>
<li>Statements map to labeled blocks and branches; use <code>MethodBodyBuilder</code>.</li>
<li>Locals declared via <code>.local(name, TypeSignature)</code>.</li>
</ul>
<h2 id="control-flow-mapping"><a class="header" href="#control-flow-mapping">Control-flow mapping</a></h2>
<ul>
<li>If/Else → diamond with <code>brtrue/brfalse</code> and join.</li>
<li>While/For → head/test blocks, back-edge with <code>br</code>.</li>
<li>Switch → <code>switch</code> table + join.</li>
<li>Try/Catch/Finally → EH helpers (label-based ranges).</li>
</ul>
<h2 id="metadata"><a class="header" href="#metadata">Metadata</a></h2>
<ul>
<li>Use builders to create <code>Assembly</code>, <code>TypeDef</code>, <code>MethodDef</code> entries.</li>
<li>Link method bodies with local sig tokens returned by <code>MethodBodyBuilder::build</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing--conformance"><a class="header" href="#testing--conformance">Testing &amp; Conformance</a></h1>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit tests</a></h2>
<ul>
<li>Hand-authored IL via <code>MethodBodyBuilder</code> for arithmetic/branching/stack behavior.</li>
<li>VM result assertions; negative tests for stack underflow/type errors.</li>
</ul>
<h2 id="end-to-end-tests"><a class="header" href="#end-to-end-tests">End-to-end tests</a></h2>
<ul>
<li>Parse C# → emit IL → run on VM; assert outputs.</li>
<li>Optional: run emitted DLL on .NET and compare results.</li>
</ul>
<h2 id="cfg-fidelity"><a class="header" href="#cfg-fidelity">CFG fidelity</a></h2>
<ul>
<li>Mirror shapes produced by <code>build_cfg()</code> from <code>control_flow_graph</code> to ensure consistent semantics.</li>
</ul>
<h2 id="golden-tests"><a class="header" href="#golden-tests">Golden tests</a></h2>
<ul>
<li>Snapshot IL bytes and metadata tables for regression protection.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap-1"><a class="header" href="#roadmap-1">Roadmap</a></h1>
<ul>
<li>Phase 0: Dotscope spike (read/emit).</li>
<li>Phase 1: VM MVP (primitives, branches, static calls).</li>
<li>Phase 2: Control flow + EH.</li>
<li>Phase 3: Object model + arrays.</li>
<li>Phase 4: Back-compat polish (tokens across modules, P/Invoke, strings).</li>
<li>Phase 5: AST→IL emitter and dual-run conformance.</li>
</ul>
<h2 id="risks"><a class="header" href="#risks">Risks</a></h2>
<ul>
<li>IL surface area creep; mitigate via tight MVP subset.</li>
<li>Metadata correctness; rely on dotscope builders and validation.</li>
<li>Performance; consider Cranelift backend later.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-questions"><a class="header" href="#open-questions">Open Questions</a></h1>
<ul>
<li>String/runtime model: use host shims vs. implement <code>System.String</code>?</li>
<li>Verification: minimal runtime checks vs. full ECMA-335 verification.</li>
<li>Generics: erasure strategy for MVP?</li>
<li>Exception filters and complex EH features timeline.</li>
<li>Interop boundary for P/Invoke and platform differences.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<ul>
<li><strong>CIL</strong>: Common Intermediate Language, ECMA-335 bytecode for .NET.</li>
<li><strong>PE</strong>: Portable Executable file format used by .NET assemblies.</li>
<li><strong>EH</strong>: Exception Handling structures (try/catch/finally clauses).</li>
<li><strong>dotscope</strong>: Rust crate for reading/writing .NET metadata and IL.</li>
<li><strong>MethodBodyBuilder</strong>: dotscope builder to assemble IL bodies.</li>
<li><strong>BuilderContext</strong>: dotscope context managing heaps and metadata tables.</li>
<li><strong>VM</strong>: Virtual Machine executing IL bytecode.</li>
<li><strong>BCL</strong>: Base Class Library in .NET.</li>
</ul>

                </main>
                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->

                    <div style="clear: both"></div>
                </nav>
            </div>

            <!-- Theme selector removed - forcing dark mode only -->
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
        </nav>
    </div>

    <!-- Livereload script (if served using the mdbook serve command) -->

    <!-- Custom JS scripts -->

    <!-- Force dark mode script -->
    <script>
        // Force dark mode and prevent theme switching
        (function() {
            // Override localStorage before mdBook loads
            var originalSetItem = localStorage.setItem;
            var originalGetItem = localStorage.getItem;
            
            localStorage.setItem = function(key, value) {
                if (key === 'mdbook-theme') {
                    value = 'dark';
                }
                return originalSetItem.call(this, key, value);
            };
            
            localStorage.getItem = function(key) {
                if (key === 'mdbook-theme') {
                    return 'dark';
                }
                return originalGetItem.call(this, key);
            };
            
            // Set dark mode immediately
            localStorage.setItem('mdbook-theme', 'dark');
            
            // Continuously enforce dark mode
            setInterval(function() {
                document.documentElement.classList.remove('light');
                document.documentElement.classList.add('dark');
            }, 10);
            
            // Override any theme switching attempts
            Object.defineProperty(window, 'mdbook', {
                get: function() {
                    return {
                        changeTheme: function() {
                            // Do nothing - prevent theme changes
                        }
                    };
                },
                set: function() {
                    // Do nothing - prevent mdbook override
                }
            });
        })();
        
        // Wait for DOM to be ready and enforce dark mode
        document.addEventListener('DOMContentLoaded', function() {
            setInterval(function() {
                document.documentElement.classList.remove('light');
                document.documentElement.classList.add('dark');
            }, 10);
        });
    </script>
</body>
</html>
