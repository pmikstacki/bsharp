<!DOCTYPE HTML>
<html lang="en" class="dark js">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Testing - BSharp C# Parser Documentation</title>
    <meta name="robots" content="noindex">
    <!-- BSharp mdBook Custom Head -->
    <meta name="theme-color" content="#00C9B9">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <style>
      /* Additional custom styles */
      .header .left a::before {
        content: "B# ";
        color: #00C9B9;
        font-weight: 700;
      }
      
      /* Force dark theme immediately */
      html, html.light, html.dark {
        color-scheme: dark !important;
      }
      
      html body, body, .light body, .dark body {
        background: linear-gradient(66.77deg, #00C9B9 0%, #003824 100%) !important;
        background-color: transparent !important;
        color: #dfe4e3 !important;
      }
      
      .header, .light .header, .dark .header {
        background-color: rgba(15, 20, 20, 0.7) !important;
        backdrop-filter: blur(20px) !important;
        -webkit-backdrop-filter: blur(20px) !important;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1) !important;
      }
      
      .sidebar, .light .sidebar, .dark .sidebar {
        background-color: rgba(15, 20, 20, 0.7) !important;
        backdrop-filter: blur(20px) !important;
        -webkit-backdrop-filter: blur(20px) !important;
        border-right: 1px solid rgba(255, 255, 255, 0.1) !important;
      }
      
      .content, .light .content, .dark .content {
        background-color: rgba(15, 20, 20, 0.6) !important;
        backdrop-filter: blur(10px) !important;
        -webkit-backdrop-filter: blur(10px) !important;
        color: #dfe4e3 !important;
      }
      
      /* Hide theme selector */
      .theme-selector {
        display: none !important;
      }
    </style>
    <script>
      // Force dark mode and prevent theme switching
      (function() {
        // Set dark mode immediately
        document.documentElement.classList.remove('light');
        document.documentElement.classList.add('dark');
        localStorage.setItem('mdbook-theme', 'dark');
        
        // Override localStorage to always return dark
        const originalSetItem = localStorage.setItem;
        const originalGetItem = localStorage.getItem;
        
        localStorage.setItem = function(key, value) {
          if (key === 'mdbook-theme') {
            value = 'dark';
          }
          return originalSetItem.call(this, key, value);
        };
        
        localStorage.getItem = function(key) {
          if (key === 'mdbook-theme') {
            return 'dark';
          }
          return originalGetItem.call(this, key);
        };
        
        // Continuously enforce dark mode
        setInterval(function() {
          document.documentElement.classList.remove('light');
          document.documentElement.classList.add('dark');
        }, 50);
        
        // Hide theme selector if it exists
        setTimeout(function() {
          const themeSelector = document.querySelector('.theme-selector');
          if (themeSelector) {
            themeSelector.style.display = 'none';
          }
        }, 100);
      })();
    </script>
</head>
<body>
    <!-- Provide site root to javascript -->
    <script>
        var path_to_root = "../";
        var default_theme = "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script>
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script>
        var html = document.querySelector('html');
        var sidebar = null;
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
            sidebar = sidebar || 'visible';
        } else {
            sidebar = 'hidden';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scroll">
            <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Parser Architecture</li><li class="chapter-item expanded "><a href="parser/overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="parser/core-components.html"><strong aria-hidden="true">2.</strong> Core Components</a></li><li class="chapter-item expanded "><a href="parser/ast-structure.html"><strong aria-hidden="true">3.</strong> AST Structure</a></li><li class="chapter-item expanded "><a href="parser/error-handling.html"><strong aria-hidden="true">4.</strong> Error Handling</a></li><li class="chapter-item expanded affix "><li class="part-title">Parser Modules</li><li class="chapter-item expanded "><a href="parser/expressions.html"><strong aria-hidden="true">5.</strong> Expression Parsing</a></li><li class="chapter-item expanded "><a href="parser/statements.html"><strong aria-hidden="true">6.</strong> Statement Parsing</a></li><li class="chapter-item expanded "><a href="parser/declarations.html"><strong aria-hidden="true">7.</strong> Declaration Parsing</a></li><li class="chapter-item expanded "><a href="parser/types.html"><strong aria-hidden="true">8.</strong> Type System</a></li><li class="chapter-item expanded "><a href="parser/feature-completeness.html"><strong aria-hidden="true">9.</strong> Feature Completeness</a></li><li class="chapter-item expanded "><a href="parser/keywords-and-tokens.html"><strong aria-hidden="true">10.</strong> Keywords and Tokens</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Features</li><li class="chapter-item expanded "><a href="parser/navigation.html"><strong aria-hidden="true">11.</strong> Query API</a></li><li class="chapter-item expanded "><a href="parser/comments.html"><strong aria-hidden="true">12.</strong> Comment Parsing</a></li><li class="chapter-item expanded "><a href="parser/preprocessor.html"><strong aria-hidden="true">13.</strong> Preprocessor Directives</a></li><li class="chapter-item expanded affix "><li class="part-title">Syntax</li><li class="chapter-item expanded "><a href="syntax/spans.html"><strong aria-hidden="true">14.</strong> Spans</a></li><li class="chapter-item expanded "><a href="syntax/traits.html"><strong aria-hidden="true">15.</strong> Traits</a></li><li class="chapter-item expanded "><a href="syntax/derive-macros.html"><strong aria-hidden="true">16.</strong> Derive Macros</a></li><li class="chapter-item expanded "><a href="syntax/formatter.html"><strong aria-hidden="true">17.</strong> Formatter and Emitters</a></li><li class="chapter-item expanded affix "><li class="part-title">Analysis Framework</li><li class="chapter-item expanded "><a href="analysis/overview.html"><strong aria-hidden="true">18.</strong> Analysis Overview</a></li><li class="chapter-item expanded "><a href="analysis/pipeline.html"><strong aria-hidden="true">19.</strong> Analysis Pipeline</a></li><li class="chapter-item expanded "><a href="analysis/traversal-guide.html"><strong aria-hidden="true">20.</strong> Traversal Guide</a></li><li class="chapter-item expanded "><a href="analysis/control-flow.html"><strong aria-hidden="true">21.</strong> Control Flow Analysis</a></li><li class="chapter-item expanded "><a href="analysis/dependencies.html"><strong aria-hidden="true">22.</strong> Dependency Analysis</a></li><li class="chapter-item expanded "><a href="analysis/metrics.html"><strong aria-hidden="true">23.</strong> Metrics Collection</a></li><li class="chapter-item expanded "><a href="analysis/types.html"><strong aria-hidden="true">24.</strong> Type Analysis</a></li><li class="chapter-item expanded "><a href="analysis/quality.html"><strong aria-hidden="true">25.</strong> Code Quality</a></li><li class="chapter-item expanded "><a href="analysis/passes-and-rules.html"><strong aria-hidden="true">26.</strong> Passes and Rules</a></li><li class="chapter-item expanded "><a href="analysis/report-schema.html"><strong aria-hidden="true">27.</strong> Report Schema</a></li><li class="chapter-item expanded "><a href="analysis/writing-a-pass.html"><strong aria-hidden="true">28.</strong> Writing a Pass</a></li><li class="chapter-item expanded "><a href="analysis/writing-a-ruleset.html"><strong aria-hidden="true">29.</strong> Writing a Ruleset</a></li><li class="chapter-item expanded affix "><li class="part-title">CLI Tools</li><li class="chapter-item expanded "><a href="cli/overview.html"><strong aria-hidden="true">30.</strong> Command Line Interface</a></li><li class="chapter-item expanded "><a href="cli/parse.html"><strong aria-hidden="true">31.</strong> Parse Command</a></li><li class="chapter-item expanded "><a href="cli/tree.html"><strong aria-hidden="true">32.</strong> Tree Visualization</a></li><li class="chapter-item expanded "><a href="cli/analyze.html"><strong aria-hidden="true">33.</strong> Analysis Command</a></li><li class="chapter-item expanded "><a href="cli/format.html"><strong aria-hidden="true">34.</strong> Format Command</a></li><li class="chapter-item expanded "><a href="cli/errors-json.html"><strong aria-hidden="true">35.</strong> Parse Errors JSON</a></li><li class="chapter-item expanded affix "><li class="part-title">Workspace</li><li class="chapter-item expanded "><a href="workspace/overview.html"><strong aria-hidden="true">36.</strong> Workspace Loading</a></li><li class="chapter-item expanded affix "><li class="part-title">Configuration</li><li class="chapter-item expanded "><a href="configuration/overview.html"><strong aria-hidden="true">37.</strong> Configuration Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Development</li><li class="chapter-item expanded "><a href="development/contributing.html"><strong aria-hidden="true">38.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="development/testing.html"><strong aria-hidden="true">39.</strong> Testing</a></li><li class="chapter-item expanded "><a href="development/architecture.html"><strong aria-hidden="true">40.</strong> Architecture Decisions</a></li><li class="chapter-item expanded "><a href="development/cookbooks.html"><strong aria-hidden="true">41.</strong> Cookbooks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/query-cookbook.html"><strong aria-hidden="true">41.1.</strong> Query Cookbook</a></li><li class="chapter-item expanded "><a href="development/parser-cookbook.html"><strong aria-hidden="true">41.2.</strong> Parser Cookbook</a></li></ol></li><li class="chapter-item expanded "><a href="development/writing-tests.html"><strong aria-hidden="true">42.</strong> Writing Tests</a></li><li class="chapter-item expanded "><a href="development/bsharp_tests.html"><strong aria-hidden="true">43.</strong> bsharp_tests Overview</a></li><li class="chapter-item expanded "><a href="development/extending-syntax.html"><strong aria-hidden="true">44.</strong> Extending Syntax (New Nodes)</a></li><li class="chapter-item expanded "><a href="development/writing-parsers.html"><strong aria-hidden="true">45.</strong> Writing Parsers</a></li><li class="chapter-item expanded "><a href="development/compliance/index.html"><strong aria-hidden="true">46.</strong> Compliance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/compliance/overview.html"><strong aria-hidden="true">46.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="development/compliance/compliance_guide.html"><strong aria-hidden="true">46.2.</strong> Compliance Guide</a></li><li class="chapter-item expanded "><a href="development/compliance/Generator.html"><strong aria-hidden="true">46.3.</strong> Generator</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Research &amp; Development</li><li class="chapter-item expanded "><a href="cil-runtime/index.html"><strong aria-hidden="true">47.</strong> CIL Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cil-runtime/overview.html"><strong aria-hidden="true">47.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="cil-runtime/architecture.html"><strong aria-hidden="true">47.2.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/index.html"><strong aria-hidden="true">47.3.</strong> Phases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cil-runtime/phases/00-dotscope-spike.html"><strong aria-hidden="true">47.3.1.</strong> Phase 0: Dotscope Spike</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/01-vm-mvp.html"><strong aria-hidden="true">47.3.2.</strong> Phase 1: VM MVP</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/02-control-flow-and-eh.html"><strong aria-hidden="true">47.3.3.</strong> Phase 2: Control Flow + EH</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/03-object-model-and-arrays.html"><strong aria-hidden="true">47.3.4.</strong> Phase 3: Object Model and Arrays</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/04-back-compat-polish.html"><strong aria-hidden="true">47.3.5.</strong> Phase 4: Back-Compat Polish</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/05-ast-to-il-emitter.html"><strong aria-hidden="true">47.3.6.</strong> Phase 5: AST→IL Emitter</a></li></ol></li><li class="chapter-item expanded "><a href="cil-runtime/dotscope-guide.html"><strong aria-hidden="true">47.4.</strong> dotscope Guide</a></li><li class="chapter-item expanded "><a href="cil-runtime/vm-design.html"><strong aria-hidden="true">47.5.</strong> VM Design</a></li><li class="chapter-item expanded "><a href="cil-runtime/emitter-design.html"><strong aria-hidden="true">47.6.</strong> Emitter Design</a></li><li class="chapter-item expanded "><a href="cil-runtime/testing.html"><strong aria-hidden="true">47.7.</strong> Testing &amp; Conformance</a></li><li class="chapter-item expanded "><a href="cil-runtime/roadmap.html"><strong aria-hidden="true">47.8.</strong> Roadmap</a></li><li class="chapter-item expanded "><a href="cil-runtime/open-questions.html"><strong aria-hidden="true">47.9.</strong> Open Questions</a></li><li class="chapter-item expanded "><a href="cil-runtime/glossary.html"><strong aria-hidden="true">47.10.</strong> Glossary</a></li></ol></li></ol>
        </div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">

            <div id="content" class="content">
                <main>
                    <h1 id="testing-guide"><a class="header" href="#testing-guide">Testing Guide</a></h1>
<p>This document provides comprehensive guidance on testing in the BSharp project, covering test organization, best practices, and debugging strategies.</p>
<hr />
<h2 id="test-organization-philosophy"><a class="header" href="#test-organization-philosophy">Test Organization Philosophy</a></h2>
<h3 id="external-test-structure"><a class="header" href="#external-test-structure">External Test Structure</a></h3>
<p><strong>Critical Principle:</strong> Parser tests are external to implementation modules and live in a dedicated test crate.</p>
<pre><code>src/bsharp_tests/
├── cargo.toml               # Test crate manifest
└── src/
    ├── parser/
    │   ├── expressions/
    │   │   ├── expression_tests.rs
    │   │   ├── lambda_expression_tests.rs
    │   │   ├── pattern_matching_tests.rs
    │   │   ├── ambiguity_tests.rs
    │   │   ├── lookahead_boundaries2_tests.rs
    │   │   └── ...
    │   ├── statements/
    │   │   ├── if_statement_tests.rs
    │   │   ├── for_statement_tests.rs
    │   │   ├── expression_statement_tests.rs
    │   │   └── ...
    │   ├── declarations/
    │   │   ├── class_declaration_tests.rs
    │   │   ├── interface_declaration_parser_tests.rs
    │   │   ├── recovery_tests.rs
    │   │   └── ...
    │   ├── types/
    │   │   ├── type_tests.rs
    │   │   ├── advanced_type_tests.rs
    │   │   └── ...
    │   ├── preprocessor/
    │   │   └── ...
    │   └── keyword_parsers_tests.rs
    └── fixtures/
        ├── happy_path/
        └── complex/
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Separation of Concerns</strong>: Test code separate from implementation</li>
<li><strong>Compilation Efficiency</strong>: Tests don't bloat production binary</li>
<li><strong>Organization</strong>: Clear structure mirrors parser organization</li>
<li><strong>Maintainability</strong>: Easy to find and update tests</li>
</ul>
<p><strong>What NOT to Do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ NEVER do this in src/parser/ files
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_something() {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>What to Do Instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Create tests/parser/expressions/my_feature_tests.rs
use bsharp::syntax::test_helpers::expect_ok;
use bsharp::parser::expressions::parse_my_feature;

#[test]
fn test_my_feature() {
    let input = "my feature syntax";
    let result = parse_my_feature(input.into());
    let ast = expect_ok(input, result);
    // assertions...
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="test-helpers"><a class="header" href="#test-helpers">Test Helpers</a></h2>
<h3 id="expect_ok---readable-test-failures"><a class="header" href="#expect_ok---readable-test-failures"><code>expect_ok()</code> - Readable Test Failures</a></h3>
<p><strong>Location:</strong> <code>src/syntax/test_helpers.rs</code></p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::syntax::test_helpers::expect_ok;

#[test]
fn test_parse_class() {
    let input = "public class MyClass { }";
    let result = parse_class_declaration(input.into());
    let class = expect_ok(input, result);
    
    assert_eq!(class.identifier.name, "MyClass");
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li><strong>Automatic Error Formatting</strong>: Pretty-prints <code>ErrorTree</code> on failure</li>
<li><strong>Readable Diagnostics</strong>: Shows parse failure context with caret</li>
<li><strong>Panic on Failure</strong>: Test fails with clear error message</li>
</ul>
<p><strong>Error Output Example:</strong></p>
<pre><code>0: at line 1, in keyword "class":
public clas MyClass { }
       ^--- expected keyword "class"

1: in context "class declaration"
</code></pre>
<h3 id="other-test-helpers"><a class="header" href="#other-test-helpers">Other Test Helpers</a></h3>
<p><strong><code>parse_input_unwrap()</code></strong> - Unwrap parse result:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (remaining, ast) = parse_input_unwrap(parse_expression(input.into()));
assert_eq!(remaining, "");  // Verify full consumption
<span class="boring">}</span></code></pre></pre>
<p><strong><code>assert_parse_error()</code></strong> - Verify parse failures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_parse_error(parse_expression("invalid syntax"));
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="parser-testing-best-practices"><a class="header" href="#parser-testing-best-practices">Parser Testing Best Practices</a></h2>
<h3 id="1-prefer-expect_ok-for-successful-parses"><a class="header" href="#1-prefer-expect_ok-for-successful-parses">1. Prefer <code>expect_ok()</code> for Successful Parses</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_if_statement() {
    let input = "if (x &gt; 0) { return x; }";
    let stmt = expect_ok(input, parse_if_statement(input.into()));
    
    // Now assert on the AST structure
    match stmt {
        Statement::If(if_stmt) =&gt; {
            // Verify condition, consequence, etc.
        }
        _ =&gt; panic!("Expected IfStatement"),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-keep-tests-focused-and-minimal"><a class="header" href="#2-keep-tests-focused-and-minimal">2. Keep Tests Focused and Minimal</a></h3>
<p><strong>Good:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_simple_lambda() {
    let input = "x =&gt; x * 2";
    let expr = expect_ok(input, parse_lambda_expression(input.into()));
    // Test one thing
}

#[test]
fn test_lambda_with_multiple_params() {
    let input = "(x, y) =&gt; x + y";
    let expr = expect_ok(input, parse_lambda_expression(input.into()));
    // Test another thing
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Bad:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_all_lambda_forms() {
    // Testing too many things in one test
    // Hard to debug when it fails
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-add-negative-tests-for-ambiguity"><a class="header" href="#3-add-negative-tests-for-ambiguity">3. Add Negative Tests for Ambiguity</a></h3>
<p>When disambiguation is possible, add tests for both valid and invalid cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_ternary_vs_nullable() {
    // Valid ternary
    let input = "x ? y : z";
    expect_ok(input, parse_conditional_expression(input.into()));
    
    // Valid null-conditional (different test)
}

#[test]
fn test_null_conditional_operator() {
    let input = "obj?.Property";
    expect_ok(input, parse_postfix_expression(input.into()));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-test-lookaheaddisambiguation-boundaries"><a class="header" href="#4-test-lookaheaddisambiguation-boundaries">4. Test Lookahead/Disambiguation Boundaries</a></h3>
<p><strong>Location:</strong> <code>tests/parser/expressions/lookahead_boundaries2_tests.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_range_vs_dot_vs_float() {
    // Range operator
    expect_ok("1..10", parse_range_expression("1..10"));
    
    // Member access
    expect_ok("obj.Method", parse_postfix_expression("obj.Method"));
    
    // Float literal
    expect_ok("3.14", parse_literal("3.14"));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-test-complex-constructs"><a class="header" href="#5-test-complex-constructs">5. Test Complex Constructs</a></h3>
<p>For complex constructs like <code>new</code> expressions with initializers:</p>
<p><strong>Location:</strong> <code>tests/parser/expressions/new_expression_tests.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_new_with_object_initializer() {
    let input = "new Person { Name = \"John\", Age = 30 }";
    let expr = expect_ok(input, parse_new_expression(input.into()));
    // Verify structure
}

#[test]
fn test_new_with_collection_initializer() {
    let input = "new List&lt;int&gt; { 1, 2, 3 }";
    let expr = expect_ok(input, parse_new_expression(input.into()));
    // Verify structure
}

#[test]
fn test_target_typed_new() {
    let input = "new(42, \"test\")";
    let expr = expect_ok(input, parse_new_expression(input.into()));
    // Verify structure
}
<span class="boring">}</span></code></pre></pre>
<h3 id="6-test-invalid-input-diagnostics"><a class="header" href="#6-test-invalid-input-diagnostics">6. Test Invalid Input Diagnostics</a></h3>
<p><strong>Location:</strong> <code>tests/parser/expressions/invalid_diagnostics_tests.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_unclosed_paren_diagnostic() {
    let input = "(x + y";
    let result = parse_expression(input.into());
    
    assert!(result.is_err());
    // Optionally check error contains expected message
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Guidelines:</strong></p>
<ul>
<li>Keep small snapshot-style assertions</li>
<li>Check for line/column and caret presence</li>
<li>Avoid overfitting on exact wording (may change)</li>
</ul>
<h3 id="7-guard-closing-delimiters-with-cut"><a class="header" href="#7-guard-closing-delimiters-with-cut">7. Guard Closing Delimiters with <code>cut()</code></a></h3>
<p>When adding delimited constructs, ensure closing delimiters use <code>cut()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nom::combinator::cut;
use crate::syntax::parser_helpers::{bdelimited, bchar};

fn parse_parenthesized(input: &amp;str) -&gt; BResult&lt;&amp;str, Expression&gt; {
    bdelimited(
        bchar('('),
        parse_expression,
        cut(bchar(')'))  // ✅ Prevents misleading backtracking
    )(input.into())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="8-wrap-sub-parsers-with-bws"><a class="header" href="#8-wrap-sub-parsers-with-bws">8. Wrap Sub-Parsers with <code>bws()</code></a></h3>
<p>Ensure whitespace/comments are handled consistently:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::syntax::parser_helpers::bws;

fn parse_if_statement(input: &amp;str) -&gt; BResult&lt;&amp;str, Statement&gt; {
    let (input, _) = bws(keyword("if"))(input.into())?;
    let (input, _) = bws(bchar('('))(input.into())?;
    let (input, condition) = bws(parse_expression)(input.into())?;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="test-discovery-and-execution"><a class="header" href="#test-discovery-and-execution">Test Discovery and Execution</a></h2>
<h3 id="running-all-tests"><a class="header" href="#running-all-tests">Running All Tests</a></h3>
<pre><code class="language-bash">cargo test
</code></pre>
<h3 id="running-specific-test-suites"><a class="header" href="#running-specific-test-suites">Running Specific Test Suites</a></h3>
<pre><code class="language-bash"># All parser tests
cargo test --test parser

# Specific module
cargo test --test parser expression_tests

# Specific test
cargo test --test parser test_lambda_expression
</code></pre>
<h3 id="running-with-output"><a class="header" href="#running-with-output">Running with Output</a></h3>
<pre><code class="language-bash"># Show println! output
cargo test -- --nocapture

# Show test names as they run
cargo test -- --nocapture --test-threads=1
</code></pre>
<h3 id="running-with-debug-logging"><a class="header" href="#running-with-debug-logging">Running with Debug Logging</a></h3>
<pre><code class="language-bash">RUST_LOG=debug cargo test test_name -- --nocapture
</code></pre>
<hr />
<h2 id="test-fixtures"><a class="header" href="#test-fixtures">Test Fixtures</a></h2>
<h3 id="fixture-organization"><a class="header" href="#fixture-organization">Fixture Organization</a></h3>
<pre><code>tests/fixtures/
├── happy_path/           # Valid, well-formed C# projects
│   ├── testApplication/
│   │   ├── Program.cs
│   │   ├── testApplication.csproj
│   │   └── ...
│   └── testDependency/
│       └── ...
└── complex/              # Complex, real-world scenarios
    ├── testApplication/
    └── testDependency/
</code></pre>
<h3 id="using-fixtures-in-tests"><a class="header" href="#using-fixtures-in-tests">Using Fixtures in Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::path::PathBuf;

#[test]
fn test_parse_fixture() {
    let fixture_path = PathBuf::from("tests/fixtures/happy_path/testApplication/Program.cs");
    let source = fs::read_to_string(&amp;fixture_path).unwrap();
    
    let parser = Parser::new();
    let result = parser.parse(&amp;source);
    
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="fixture-guidelines"><a class="header" href="#fixture-guidelines">Fixture Guidelines</a></h3>
<ul>
<li><strong>Valid Code</strong>: Fixtures should be valid C# that compiles</li>
<li><strong>Realistic</strong>: Use real-world patterns, not contrived examples</li>
<li><strong>Documented</strong>: Add README.md explaining fixture purpose</li>
<li><strong>Minimal</strong>: Keep fixtures as small as possible while testing feature</li>
</ul>
<hr />
<h2 id="snapshot-testing"><a class="header" href="#snapshot-testing">Snapshot Testing</a></h2>
<h3 id="using-insta-for-snapshot-tests"><a class="header" href="#using-insta-for-snapshot-tests">Using <code>insta</code> for Snapshot Tests</a></h3>
<p><strong>Installation:</strong> Already included in <code>Cargo.toml</code> dev-dependencies</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use insta::assert_json_snapshot;

#[test]
fn test_class_ast_structure() {
    let input = "public class MyClass { public int Field; }";
    let result = parse_class_declaration(input.into());
    let class = expect_ok(input, result);
    
    // Creates snapshot file on first run
    assert_json_snapshot!(class);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="reviewing-snapshots"><a class="header" href="#reviewing-snapshots">Reviewing Snapshots</a></h3>
<pre><code class="language-bash"># Review snapshot changes
cargo insta review

# Accept all changes
cargo insta accept

# Reject all changes
cargo insta reject
</code></pre>
<h3 id="snapshot-guidelines"><a class="header" href="#snapshot-guidelines">Snapshot Guidelines</a></h3>
<ul>
<li><strong>Complex Structures</strong>: Use for complex AST structures</li>
<li><strong>Regression Prevention</strong>: Catch unintended changes</li>
<li><strong>Review Carefully</strong>: Always review snapshot diffs</li>
<li><strong>Commit Snapshots</strong>: Include snapshot files in git</li>
</ul>
<hr />
<h2 id="debugging-test-failures"><a class="header" href="#debugging-test-failures">Debugging Test Failures</a></h2>
<h3 id="strategy-1-use-expect_ok-error-output"><a class="header" href="#strategy-1-use-expect_ok-error-output">Strategy 1: Use <code>expect_ok()</code> Error Output</a></h3>
<p>When a test fails, <code>expect_ok()</code> shows the parse error:</p>
<pre><code>0: at line 1, in keyword "class":
public clas MyClass { }
       ^--- expected keyword "class"
</code></pre>
<h3 id="strategy-2-add-debug-logging"><a class="header" href="#strategy-2-add-debug-logging">Strategy 2: Add Debug Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_with_logging() {
    env_logger::init();  // Initialize logger
    
    let input = "complex syntax";
    log::debug!("Parsing: {}", input);
    
    let result = parse_expression(input.into());
    log::debug!("Result: {:?}", result);
    
    expect_ok(input, result);
}
<span class="boring">}</span></code></pre></pre>
<p>Run with:</p>
<pre><code class="language-bash">RUST_LOG=debug cargo test test_with_logging -- --nocapture
</code></pre>
<h3 id="strategy-3-test-smaller-components"><a class="header" href="#strategy-3-test-smaller-components">Strategy 3: Test Smaller Components</a></h3>
<p>If a complex parser fails, test its sub-parsers individually:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_method_declaration() {
    // Fails - too complex
    let input = "public async Task&lt;int&gt; Method(int x) { return x; }";
    expect_ok(input, parse_method_declaration(input.into()));
}

// Break it down:

#[test]
fn test_method_modifiers() {
    let input = "public async";
    expect_ok(input, parse_modifiers(input.into()));
}

#[test]
fn test_method_return_type() {
    let input = "Task&lt;int&gt;";
    expect_ok(input, parse_type(input.into()));
}

#[test]
fn test_method_parameters() {
    let input = "(int x)";
    expect_ok(input, parse_parameter_list(input.into()));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="strategy-4-use-parser-debugging-tools"><a class="header" href="#strategy-4-use-parser-debugging-tools">Strategy 4: Use Parser Debugging Tools</a></h3>
<pre><code class="language-bash"># Parse file and output JSON
cargo run -- parse debug_cases/test.cs --output debug.json

# Generate AST visualization
cargo run -- tree debug_cases/test.cs --output debug.svg
</code></pre>
<h3 id="strategy-5-check-error-recovery"><a class="header" href="#strategy-5-check-error-recovery">Strategy 5: Check Error Recovery</a></h3>
<p>For declaration error recovery tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_recovery_from_malformed_member() {
    let input = r#"
    public class MyClass {
        public int ValidField;
        public invalid syntax here;  // Malformed
        public int AnotherValidField;  // Should recover
    }
    "#;
    
    let result = parse_class_declaration(input.into());
    // Should parse despite error
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h2>
<h3 id="workspace-loading-tests"><a class="header" href="#workspace-loading-tests">Workspace Loading Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::workspace::WorkspaceLoader;

#[test]
fn test_load_solution() {
    let sln_path = PathBuf::from("tests/fixtures/happy_path/test.sln");
    let workspace = WorkspaceLoader::from_path(&amp;sln_path).unwrap();
    
    assert_eq!(workspace.projects.len(), 2);
    assert!(workspace.solution.is_some());
}

#[test]
fn test_load_csproj() {
    let csproj_path = PathBuf::from("tests/fixtures/happy_path/testApplication/testApplication.csproj");
    let workspace = WorkspaceLoader::from_path(&amp;csproj_path).unwrap();
    
    assert_eq!(workspace.projects.len(), 1);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="analysis-pipeline-tests"><a class="header" href="#analysis-pipeline-tests">Analysis Pipeline Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::framework::pipeline::AnalyzerPipeline;
use bsharp::analysis::framework::session::AnalysisSession;

#[test]
fn test_analysis_pipeline() {
    let source = "public class Test { public void Method() { } }";
    let parser = Parser::new();
    let cu = parser.parse(source).unwrap();
    
    let mut session = AnalysisSession::new();
    AnalyzerPipeline::run_with_defaults(&amp;cu, &amp;mut session);
    
    let report = session.into_report();
    assert!(report.diagnostics.is_empty());  // No errors
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<h3 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[ignore]  // Run with --ignored flag
fn bench_parse_large_file() {
    use std::time::Instant;
    
    let source = fs::read_to_string("tests/fixtures/large_file.cs").unwrap();
    let parser = Parser::new();
    
    let start = Instant::now();
    let result = parser.parse(&amp;source);
    let duration = start.elapsed();
    
    assert!(result.is_ok());
    println!("Parse time: {:?}", duration);
    
    // Assert reasonable performance
    assert!(duration.as_millis() &lt; 1000, "Parse took too long");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="running-performance-tests"><a class="header" href="#running-performance-tests">Running Performance Tests</a></h3>
<pre><code class="language-bash">cargo test --ignored -- bench_
</code></pre>
<hr />
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h2>
<h3 id="ci-test-strategy"><a class="header" href="#ci-test-strategy">CI Test Strategy</a></h3>
<pre><code class="language-yaml"># .github/workflows/test.yml (example)
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: Run tests
        run: cargo test --all-features
      - name: Run clippy
        run: cargo clippy -- -D warnings
      - name: Check formatting
        run: cargo fmt -- --check
</code></pre>
<hr />
<h2 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h2>
<h3 id="measuring-coverage"><a class="header" href="#measuring-coverage">Measuring Coverage</a></h3>
<pre><code class="language-bash"># Install tarpaulin
cargo install cargo-tarpaulin

# Run coverage
cargo tarpaulin --out Html --output-dir coverage
</code></pre>
<h3 id="coverage-goals"><a class="header" href="#coverage-goals">Coverage Goals</a></h3>
<ul>
<li><strong>Parser Core</strong>: 90%+ coverage</li>
<li><strong>Analysis Framework</strong>: 80%+ coverage</li>
<li><strong>CLI Commands</strong>: 70%+ coverage</li>
<li><strong>Workspace Loading</strong>: 80%+ coverage</li>
</ul>
<hr />
<h2 id="common-testing-patterns"><a class="header" href="#common-testing-patterns">Common Testing Patterns</a></h2>
<h3 id="pattern-1-positive-and-negative-tests"><a class="header" href="#pattern-1-positive-and-negative-tests">Pattern 1: Positive and Negative Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_valid_syntax() {
    let input = "valid syntax";
    expect_ok(input, parse_feature(input.into()));
}

#[test]
fn test_invalid_syntax() {
    let input = "invalid syntax";
    assert!(parse_feature(input.into()).is_err());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-2-boundary-testing"><a class="header" href="#pattern-2-boundary-testing">Pattern 2: Boundary Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_empty_input() {
    assert!(parse_feature("").is_err());
}

#[test]
fn test_minimal_input() {
    expect_ok("x", parse_feature("x"));
}

#[test]
fn test_maximal_input() {
    let input = "very complex nested structure...";
    expect_ok(input, parse_feature(input.into()));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-3-equivalence-testing"><a class="header" href="#pattern-3-equivalence-testing">Pattern 3: Equivalence Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_whitespace_insensitive() {
    let compact = "if(x){y;}";
    let spaced = "if (x) { y; }";
    
    let ast1 = expect_ok(compact, parse_if_statement(compact));
    let ast2 = expect_ok(spaced, parse_if_statement(spaced));
    
    assert_eq!(ast1, ast2);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="test-maintenance"><a class="header" href="#test-maintenance">Test Maintenance</a></h2>
<h3 id="when-to-update-tests"><a class="header" href="#when-to-update-tests">When to Update Tests</a></h3>
<ol>
<li><strong>API Changes</strong>: Update tests when parser API changes</li>
<li><strong>Bug Fixes</strong>: Add regression tests for fixed bugs</li>
<li><strong>New Features</strong>: Add tests for new language features</li>
<li><strong>Refactoring</strong>: Ensure tests still pass after refactoring</li>
</ol>
<h3 id="test-cleanup"><a class="header" href="#test-cleanup">Test Cleanup</a></h3>
<ul>
<li><strong>Remove Duplicate Tests</strong>: Consolidate similar tests</li>
<li><strong>Update Outdated Tests</strong>: Fix tests using deprecated APIs</li>
<li><strong>Remove Dead Tests</strong>: Delete tests for removed features</li>
<li><strong>Improve Names</strong>: Use descriptive test names</li>
</ul>
<h3 id="test-documentation"><a class="header" href="#test-documentation">Test Documentation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Tests that lambda expressions with multiple parameters are parsed correctly.
/// 
/// This test verifies:
/// - Parameter list parsing
/// - Arrow token recognition
/// - Expression body parsing
#[test]
fn test_lambda_with_multiple_params() {
    let input = "(x, y) =&gt; x + y";
    let expr = expect_ok(input, parse_lambda_expression(input.into()));
    // ...
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<h3 id="testing-checklist"><a class="header" href="#testing-checklist">Testing Checklist</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Tests in <code>tests/</code> directory, not inline</li>
<li><input disabled="" type="checkbox"/>
Use <code>expect_ok()</code> for readable failures</li>
<li><input disabled="" type="checkbox"/>
Keep tests focused and minimal</li>
<li><input disabled="" type="checkbox"/>
Add negative tests for ambiguity</li>
<li><input disabled="" type="checkbox"/>
Test lookahead/disambiguation boundaries</li>
<li><input disabled="" type="checkbox"/>
Test complex constructs thoroughly</li>
<li><input disabled="" type="checkbox"/>
Use <code>cut()</code> for closing delimiters</li>
<li><input disabled="" type="checkbox"/>
Wrap sub-parsers with <code>bws()</code></li>
<li><input disabled="" type="checkbox"/>
Add fixtures for integration tests</li>
<li><input disabled="" type="checkbox"/>
Use snapshot tests for complex structures</li>
<li><input disabled="" type="checkbox"/>
Document test purpose and coverage</li>
</ul>
<h3 id="resources"><a class="header" href="#resources">Resources</a></h3>
<ul>
<li><strong>Test Helpers</strong>: <code>src/syntax/test_helpers.rs</code></li>
<li><strong>Example Tests</strong>: <code>tests/parser/expressions/</code></li>
<li><strong>Fixtures</strong>: <code>tests/fixtures/</code></li>
<li><strong>Contributing Guide</strong>: <code>docs/development/contributing.md</code></li>
<li><strong>Architecture</strong>: <code>docs/development/architecture.md</code></li>
</ul>

                </main>
                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->

                    <div style="clear: both"></div>
                </nav>
            </div>

            <!-- Theme selector removed - forcing dark mode only -->
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
        </nav>
    </div>

    <!-- Livereload script (if served using the mdbook serve command) -->

    <!-- Custom JS scripts -->

    <!-- Force dark mode script -->
    <script>
        // Force dark mode and prevent theme switching
        (function() {
            // Override localStorage before mdBook loads
            var originalSetItem = localStorage.setItem;
            var originalGetItem = localStorage.getItem;
            
            localStorage.setItem = function(key, value) {
                if (key === 'mdbook-theme') {
                    value = 'dark';
                }
                return originalSetItem.call(this, key, value);
            };
            
            localStorage.getItem = function(key) {
                if (key === 'mdbook-theme') {
                    return 'dark';
                }
                return originalGetItem.call(this, key);
            };
            
            // Set dark mode immediately
            localStorage.setItem('mdbook-theme', 'dark');
            
            // Continuously enforce dark mode
            setInterval(function() {
                document.documentElement.classList.remove('light');
                document.documentElement.classList.add('dark');
            }, 10);
            
            // Override any theme switching attempts
            Object.defineProperty(window, 'mdbook', {
                get: function() {
                    return {
                        changeTheme: function() {
                            // Do nothing - prevent theme changes
                        }
                    };
                },
                set: function() {
                    // Do nothing - prevent mdbook override
                }
            });
        })();
        
        // Wait for DOM to be ready and enforce dark mode
        document.addEventListener('DOMContentLoaded', function() {
            setInterval(function() {
                document.documentElement.classList.remove('light');
                document.documentElement.classList.add('dark');
            }, 10);
        });
    </script>
</body>
</html>
