<!DOCTYPE HTML>
<html lang="en" class="dark js">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Metrics Collection - BSharp C# Parser Documentation</title>
    <meta name="robots" content="noindex">
    <!-- BSharp mdBook Custom Head -->
    <meta name="theme-color" content="#00C9B9">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <style>
      /* Additional custom styles */
      .header .left a::before {
        content: "B# ";
        color: #00C9B9;
        font-weight: 700;
      }
      
      /* Force dark theme immediately */
      html, html.light, html.dark {
        color-scheme: dark !important;
      }
      
      html body, body, .light body, .dark body {
        background: linear-gradient(66.77deg, #00C9B9 0%, #003824 100%) !important;
        background-color: transparent !important;
        color: #dfe4e3 !important;
      }
      
      .header, .light .header, .dark .header {
        background-color: rgba(15, 20, 20, 0.7) !important;
        backdrop-filter: blur(20px) !important;
        -webkit-backdrop-filter: blur(20px) !important;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1) !important;
      }
      
      .sidebar, .light .sidebar, .dark .sidebar {
        background-color: rgba(15, 20, 20, 0.7) !important;
        backdrop-filter: blur(20px) !important;
        -webkit-backdrop-filter: blur(20px) !important;
        border-right: 1px solid rgba(255, 255, 255, 0.1) !important;
      }
      
      .content, .light .content, .dark .content {
        background-color: rgba(15, 20, 20, 0.6) !important;
        backdrop-filter: blur(10px) !important;
        -webkit-backdrop-filter: blur(10px) !important;
        color: #dfe4e3 !important;
      }
      
      /* Hide theme selector */
      .theme-selector {
        display: none !important;
      }
    </style>
    <script>
      // Force dark mode and prevent theme switching
      (function() {
        // Set dark mode immediately
        document.documentElement.classList.remove('light');
        document.documentElement.classList.add('dark');
        localStorage.setItem('mdbook-theme', 'dark');
        
        // Override localStorage to always return dark
        const originalSetItem = localStorage.setItem;
        const originalGetItem = localStorage.getItem;
        
        localStorage.setItem = function(key, value) {
          if (key === 'mdbook-theme') {
            value = 'dark';
          }
          return originalSetItem.call(this, key, value);
        };
        
        localStorage.getItem = function(key) {
          if (key === 'mdbook-theme') {
            return 'dark';
          }
          return originalGetItem.call(this, key);
        };
        
        // Continuously enforce dark mode
        setInterval(function() {
          document.documentElement.classList.remove('light');
          document.documentElement.classList.add('dark');
        }, 50);
        
        // Hide theme selector if it exists
        setTimeout(function() {
          const themeSelector = document.querySelector('.theme-selector');
          if (themeSelector) {
            themeSelector.style.display = 'none';
          }
        }, 100);
      })();
    </script>
</head>
<body>
    <!-- Provide site root to javascript -->
    <script>
        var path_to_root = "../";
        var default_theme = "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script>
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script>
        var html = document.querySelector('html');
        var sidebar = null;
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
            sidebar = sidebar || 'visible';
        } else {
            sidebar = 'hidden';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scroll">
            <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Parser Architecture</li><li class="chapter-item expanded "><a href="parser/overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="parser/core-components.html"><strong aria-hidden="true">2.</strong> Core Components</a></li><li class="chapter-item expanded "><a href="parser/ast-structure.html"><strong aria-hidden="true">3.</strong> AST Structure</a></li><li class="chapter-item expanded "><a href="parser/error-handling.html"><strong aria-hidden="true">4.</strong> Error Handling</a></li><li class="chapter-item expanded affix "><li class="part-title">Parser Modules</li><li class="chapter-item expanded "><a href="parser/expressions.html"><strong aria-hidden="true">5.</strong> Expression Parsing</a></li><li class="chapter-item expanded "><a href="parser/statements.html"><strong aria-hidden="true">6.</strong> Statement Parsing</a></li><li class="chapter-item expanded "><a href="parser/declarations.html"><strong aria-hidden="true">7.</strong> Declaration Parsing</a></li><li class="chapter-item expanded "><a href="parser/types.html"><strong aria-hidden="true">8.</strong> Type System</a></li><li class="chapter-item expanded "><a href="parser/feature-completeness.html"><strong aria-hidden="true">9.</strong> Feature Completeness</a></li><li class="chapter-item expanded "><a href="parser/keywords-and-tokens.html"><strong aria-hidden="true">10.</strong> Keywords and Tokens</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Features</li><li class="chapter-item expanded "><a href="parser/navigation.html"><strong aria-hidden="true">11.</strong> Query API</a></li><li class="chapter-item expanded "><a href="parser/comments.html"><strong aria-hidden="true">12.</strong> Comment Parsing</a></li><li class="chapter-item expanded "><a href="parser/preprocessor.html"><strong aria-hidden="true">13.</strong> Preprocessor Directives</a></li><li class="chapter-item expanded affix "><li class="part-title">Syntax</li><li class="chapter-item expanded "><a href="syntax/spans.html"><strong aria-hidden="true">14.</strong> Spans</a></li><li class="chapter-item expanded "><a href="syntax/traits.html"><strong aria-hidden="true">15.</strong> Traits</a></li><li class="chapter-item expanded "><a href="syntax/derive-macros.html"><strong aria-hidden="true">16.</strong> Derive Macros</a></li><li class="chapter-item expanded "><a href="syntax/formatter.html"><strong aria-hidden="true">17.</strong> Formatter and Emitters</a></li><li class="chapter-item expanded affix "><li class="part-title">Analysis Framework</li><li class="chapter-item expanded "><a href="analysis/overview.html"><strong aria-hidden="true">18.</strong> Analysis Overview</a></li><li class="chapter-item expanded "><a href="analysis/pipeline.html"><strong aria-hidden="true">19.</strong> Analysis Pipeline</a></li><li class="chapter-item expanded "><a href="analysis/traversal-guide.html"><strong aria-hidden="true">20.</strong> Traversal Guide</a></li><li class="chapter-item expanded "><a href="analysis/control-flow.html"><strong aria-hidden="true">21.</strong> Control Flow Analysis</a></li><li class="chapter-item expanded "><a href="analysis/dependencies.html"><strong aria-hidden="true">22.</strong> Dependency Analysis</a></li><li class="chapter-item expanded "><a href="analysis/metrics.html"><strong aria-hidden="true">23.</strong> Metrics Collection</a></li><li class="chapter-item expanded "><a href="analysis/types.html"><strong aria-hidden="true">24.</strong> Type Analysis</a></li><li class="chapter-item expanded "><a href="analysis/quality.html"><strong aria-hidden="true">25.</strong> Code Quality</a></li><li class="chapter-item expanded "><a href="analysis/passes-and-rules.html"><strong aria-hidden="true">26.</strong> Passes and Rules</a></li><li class="chapter-item expanded "><a href="analysis/report-schema.html"><strong aria-hidden="true">27.</strong> Report Schema</a></li><li class="chapter-item expanded "><a href="analysis/writing-a-pass.html"><strong aria-hidden="true">28.</strong> Writing a Pass</a></li><li class="chapter-item expanded "><a href="analysis/writing-a-ruleset.html"><strong aria-hidden="true">29.</strong> Writing a Ruleset</a></li><li class="chapter-item expanded affix "><li class="part-title">CLI Tools</li><li class="chapter-item expanded "><a href="cli/overview.html"><strong aria-hidden="true">30.</strong> Command Line Interface</a></li><li class="chapter-item expanded "><a href="cli/parse.html"><strong aria-hidden="true">31.</strong> Parse Command</a></li><li class="chapter-item expanded "><a href="cli/tree.html"><strong aria-hidden="true">32.</strong> Tree Visualization</a></li><li class="chapter-item expanded "><a href="cli/analyze.html"><strong aria-hidden="true">33.</strong> Analysis Command</a></li><li class="chapter-item expanded "><a href="cli/format.html"><strong aria-hidden="true">34.</strong> Format Command</a></li><li class="chapter-item expanded "><a href="cli/errors-json.html"><strong aria-hidden="true">35.</strong> Parse Errors JSON</a></li><li class="chapter-item expanded affix "><li class="part-title">Workspace</li><li class="chapter-item expanded "><a href="workspace/overview.html"><strong aria-hidden="true">36.</strong> Workspace Loading</a></li><li class="chapter-item expanded affix "><li class="part-title">Configuration</li><li class="chapter-item expanded "><a href="configuration/overview.html"><strong aria-hidden="true">37.</strong> Configuration Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">Development</li><li class="chapter-item expanded "><a href="development/contributing.html"><strong aria-hidden="true">38.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="development/testing.html"><strong aria-hidden="true">39.</strong> Testing</a></li><li class="chapter-item expanded "><a href="development/architecture.html"><strong aria-hidden="true">40.</strong> Architecture Decisions</a></li><li class="chapter-item expanded "><a href="development/cookbooks.html"><strong aria-hidden="true">41.</strong> Cookbooks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/query-cookbook.html"><strong aria-hidden="true">41.1.</strong> Query Cookbook</a></li><li class="chapter-item expanded "><a href="development/parser-cookbook.html"><strong aria-hidden="true">41.2.</strong> Parser Cookbook</a></li></ol></li><li class="chapter-item expanded "><a href="development/writing-tests.html"><strong aria-hidden="true">42.</strong> Writing Tests</a></li><li class="chapter-item expanded "><a href="development/bsharp_tests.html"><strong aria-hidden="true">43.</strong> bsharp_tests Overview</a></li><li class="chapter-item expanded "><a href="development/extending-syntax.html"><strong aria-hidden="true">44.</strong> Extending Syntax (New Nodes)</a></li><li class="chapter-item expanded "><a href="development/writing-parsers.html"><strong aria-hidden="true">45.</strong> Writing Parsers</a></li><li class="chapter-item expanded "><a href="development/compliance/index.html"><strong aria-hidden="true">46.</strong> Compliance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/compliance/overview.html"><strong aria-hidden="true">46.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="development/compliance/compliance_guide.html"><strong aria-hidden="true">46.2.</strong> Compliance Guide</a></li><li class="chapter-item expanded "><a href="development/compliance/Generator.html"><strong aria-hidden="true">46.3.</strong> Generator</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Research &amp; Development</li><li class="chapter-item expanded "><a href="cil-runtime/index.html"><strong aria-hidden="true">47.</strong> CIL Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cil-runtime/overview.html"><strong aria-hidden="true">47.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="cil-runtime/architecture.html"><strong aria-hidden="true">47.2.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/index.html"><strong aria-hidden="true">47.3.</strong> Phases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cil-runtime/phases/00-dotscope-spike.html"><strong aria-hidden="true">47.3.1.</strong> Phase 0: Dotscope Spike</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/01-vm-mvp.html"><strong aria-hidden="true">47.3.2.</strong> Phase 1: VM MVP</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/02-control-flow-and-eh.html"><strong aria-hidden="true">47.3.3.</strong> Phase 2: Control Flow + EH</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/03-object-model-and-arrays.html"><strong aria-hidden="true">47.3.4.</strong> Phase 3: Object Model and Arrays</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/04-back-compat-polish.html"><strong aria-hidden="true">47.3.5.</strong> Phase 4: Back-Compat Polish</a></li><li class="chapter-item expanded "><a href="cil-runtime/phases/05-ast-to-il-emitter.html"><strong aria-hidden="true">47.3.6.</strong> Phase 5: AST→IL Emitter</a></li></ol></li><li class="chapter-item expanded "><a href="cil-runtime/dotscope-guide.html"><strong aria-hidden="true">47.4.</strong> dotscope Guide</a></li><li class="chapter-item expanded "><a href="cil-runtime/vm-design.html"><strong aria-hidden="true">47.5.</strong> VM Design</a></li><li class="chapter-item expanded "><a href="cil-runtime/emitter-design.html"><strong aria-hidden="true">47.6.</strong> Emitter Design</a></li><li class="chapter-item expanded "><a href="cil-runtime/testing.html"><strong aria-hidden="true">47.7.</strong> Testing &amp; Conformance</a></li><li class="chapter-item expanded "><a href="cil-runtime/roadmap.html"><strong aria-hidden="true">47.8.</strong> Roadmap</a></li><li class="chapter-item expanded "><a href="cil-runtime/open-questions.html"><strong aria-hidden="true">47.9.</strong> Open Questions</a></li><li class="chapter-item expanded "><a href="cil-runtime/glossary.html"><strong aria-hidden="true">47.10.</strong> Glossary</a></li></ol></li></ol>
        </div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">

            <div id="content" class="content">
                <main>
                    <h1 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics Collection</a></h1>
<p>The BSharp metrics system collects comprehensive code metrics during analysis to assess code complexity, size, and maintainability.</p>
<hr />
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p><strong>Location:</strong> <code>src/bsharp_analysis/src/metrics/</code></p>
<p>The metrics system provides:</p>
<ul>
<li><strong>Basic Metrics</strong> - Lines of code, statement counts, declaration counts</li>
<li><strong>Complexity Metrics</strong> - Cyclomatic complexity, cognitive complexity, nesting depth</li>
<li><strong>Maintainability Metrics</strong> - Maintainability index, Halstead metrics</li>
</ul>
<hr />
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<h3 id="core-components"><a class="header" href="#core-components">Core Components</a></h3>
<pre><code>src/bsharp_analysis/src/metrics/
├── core.rs     # AstAnalysis data structure (aggregated counts)
└── shared.rs   # Helpers: decision_points, max_nesting_of, count_statements, etc.
</code></pre>
<h3 id="how-metrics-are-produced"><a class="header" href="#how-metrics-are-produced">How metrics are produced</a></h3>
<ul>
<li><code>MetricsPass</code> runs in <code>Phase::LocalRules</code> and computes an <code>AstAnalysis</code> artifact using the Query API to enumerate declarations, plus lightweight walkers for statement counts.</li>
<li>Access <code>AstAnalysis</code> from <code>AnalysisSession</code> after running the pipeline.</li>
</ul>
<hr />
<h2 id="metric-types"><a class="header" href="#metric-types">Metric Types</a></h2>
<h3 id="1-basic-metrics"><a class="header" href="#1-basic-metrics">1. Basic Metrics</a></h3>
<p><strong>AstAnalysis Structure:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AstAnalysis {
    // Size metrics
    pub total_lines: usize,
    pub code_lines: usize,
    pub comment_lines: usize,
    pub blank_lines: usize,
    
    // Declaration counts
    pub namespace_count: usize,
    pub class_count: usize,
    pub interface_count: usize,
    pub struct_count: usize,
    pub enum_count: usize,
    pub method_count: usize,
    pub property_count: usize,
    pub field_count: usize,
    
    // Statement counts
    pub statement_count: usize,
    pub expression_count: usize,
    
    // Complexity (aggregated)
    pub total_complexity: usize,
    pub max_complexity: usize,
    pub max_nesting_depth: usize,
}
<span class="boring">}</span></code></pre></pre>
<!-- Collection via trait impl removed; metrics are produced by MetricsPass during the pipeline. -->
<h3 id="2-complexity-metrics"><a class="header" href="#2-complexity-metrics">2. Complexity Metrics</a></h3>
<h4 id="cyclomatic-complexity"><a class="header" href="#cyclomatic-complexity">Cyclomatic Complexity</a></h4>
<p><strong>Definition:</strong> Number of linearly independent paths through code</p>
<p><strong>Formula:</strong> <code>CC = E - N + 2P</code></p>
<ul>
<li>E = edges in control flow graph</li>
<li>N = nodes in control flow graph</li>
<li>P = connected components (usually 1)</li>
</ul>
<p><strong>Simplified:</strong> <code>CC = 1 + number of decision points</code></p>
<p><strong>Decision Points:</strong></p>
<ul>
<li><code>if</code>, <code>else if</code></li>
<li><code>case</code> in <code>switch</code></li>
<li><code>for</code>, <code>foreach</code>, <code>while</code>, <code>do-while</code></li>
<li><code>&amp;&amp;</code>, <code>||</code> in conditions</li>
<li><code>catch</code> clauses</li>
<li><code>?:</code> ternary operator</li>
<li><code>??</code> null-coalescing operator</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void ProcessOrder(Order order) {  // CC = 1 (base)
    if (order == null) {                 // +1 = 2
        throw new ArgumentNullException();
    }
    
    if (order.IsValid) {                 // +1 = 3
        if (order.Amount &gt; 1000) {       // +1 = 4
            ApplyDiscount(order);
        }
        SaveOrder(order);
    } else {                             // else doesn't add
        LogError(order);
    }
}
// Total CC = 4
</code></pre>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn cyclomatic_complexity(method: &amp;MethodDeclaration) -&gt; usize {
    let mut complexity = 1;  // Base complexity
    
    if let Some(body) = &amp;method.body {
        complexity += count_decision_points(body);
    }
    
    complexity
}

fn count_decision_points(stmt: &amp;Statement) -&gt; usize {
    let mut count = 0;
    
    walk_statements(stmt, &amp;mut |s| {
        match s {
            Statement::If(_) =&gt; count += 1,
            Statement::For(_) =&gt; count += 1,
            Statement::ForEach(_) =&gt; count += 1,
            Statement::While(_) =&gt; count += 1,
            Statement::DoWhile(_) =&gt; count += 1,
            Statement::Switch(sw) =&gt; {
                // Each case is a decision point
                count += sw.sections.len();
            }
            Statement::Try(try_stmt) =&gt; {
                // Each catch is a decision point
                count += try_stmt.catch_clauses.len();
            }
            _ =&gt; {}
        }
    });
    
    // Also count logical operators in expressions
    // count += count_logical_operators(stmt);
    
    count
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Thresholds:</strong></p>
<ul>
<li><strong>1-10:</strong> Simple, low risk</li>
<li><strong>11-20:</strong> Moderate complexity, moderate risk</li>
<li><strong>21-50:</strong> Complex, high risk</li>
<li><strong>50+:</strong> Very complex, very high risk - refactor recommended</li>
</ul>
<h4 id="cognitive-complexity"><a class="header" href="#cognitive-complexity">Cognitive Complexity</a></h4>
<p><strong>Definition:</strong> Measure of how difficult code is to understand</p>
<p><strong>Increments:</strong></p>
<ul>
<li><strong>+1</strong> for each: <code>if</code>, <code>else if</code>, <code>switch</code>, <code>for</code>, <code>foreach</code>, <code>while</code>, <code>do-while</code>, <code>catch</code>, <code>?:</code>, <code>??</code></li>
<li><strong>+1</strong> for each level of nesting (nested control structures)</li>
<li><strong>+1</strong> for each <code>break</code> or <code>continue</code> that jumps out of nested structure</li>
<li><strong>+1</strong> for each recursive call</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void Process(List&lt;int&gt; items) {
    if (items != null) {                 // +1 (if)
        foreach (var item in items) {    // +1 (loop) +1 (nesting) = +2
            if (item &gt; 0) {              // +1 (if) +2 (nesting) = +3
                Process(item);           // +1 (recursion) +3 (nesting) = +4
            }
        }
    }
}
// Total Cognitive Complexity = 1 + 2 + 3 + 4 = 10
</code></pre>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn cognitive_complexity(method: &amp;MethodDeclaration) -&gt; usize {
    let mut complexity = 0;
    
    if let Some(body) = &amp;method.body {
        complexity = calculate_cognitive_complexity(body, 0);
    }
    
    complexity
}

fn calculate_cognitive_complexity(stmt: &amp;Statement, nesting_level: usize) -&gt; usize {
    let mut complexity = 0;
    
    match stmt {
        Statement::If(if_stmt) =&gt; {
            complexity += 1 + nesting_level;  // if + nesting penalty
            complexity += calculate_cognitive_complexity(&amp;if_stmt.consequence, nesting_level + 1);
            if let Some(alt) = &amp;if_stmt.alternative {
                complexity += calculate_cognitive_complexity(alt, nesting_level + 1);
            }
        }
        Statement::For(for_stmt) =&gt; {
            complexity += 1 + nesting_level;
            if let Some(body) = &amp;for_stmt.body {
                complexity += calculate_cognitive_complexity(body, nesting_level + 1);
            }
        }
        // ... other statement types
        _ =&gt; {}
    }
    
    complexity
}
<span class="boring">}</span></code></pre></pre>
<h4 id="nesting-depth"><a class="header" href="#nesting-depth">Nesting Depth</a></h4>
<p><strong>Definition:</strong> Maximum depth of nested control structures</p>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public void Example() {
    if (condition1) {              // Depth 1
        while (condition2) {       // Depth 2
            if (condition3) {      // Depth 3
                for (int i = 0; i &lt; 10; i++) {  // Depth 4
                    // Code here
                }
            }
        }
    }
}
// Max Nesting Depth = 4
</code></pre>
<p><strong>Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn max_nesting_depth(method: &amp;MethodDeclaration) -&gt; usize {
    method.body.as_ref()
        .map(|body| calculate_max_nesting(body, 0))
        .unwrap_or(0)
}

fn calculate_max_nesting(stmt: &amp;Statement, current_depth: usize) -&gt; usize {
    let mut max_depth = current_depth;
    
    match stmt {
        Statement::If(if_stmt) =&gt; {
            let then_depth = calculate_max_nesting(&amp;if_stmt.consequence, current_depth + 1);
            max_depth = max_depth.max(then_depth);
            
            if let Some(alt) = &amp;if_stmt.alternative {
                let else_depth = calculate_max_nesting(alt, current_depth + 1);
                max_depth = max_depth.max(else_depth);
            }
        }
        Statement::Block(stmts) =&gt; {
            for s in stmts {
                let depth = calculate_max_nesting(s, current_depth);
                max_depth = max_depth.max(depth);
            }
        }
        // ... other nesting statements
        _ =&gt; {}
    }
    
    max_depth
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Thresholds:</strong></p>
<ul>
<li><strong>1-3:</strong> Acceptable</li>
<li><strong>4-5:</strong> Consider refactoring</li>
<li><strong>6+:</strong> Refactor recommended</li>
</ul>
<h3 id="planned-maintainability-metrics"><a class="header" href="#planned-maintainability-metrics">Planned: Maintainability Metrics</a></h3>
<h4 id="maintainability-index"><a class="header" href="#maintainability-index">Maintainability Index</a></h4>
<p><strong>Definition:</strong> Composite metric indicating code maintainability</p>
<p><strong>Formula (Microsoft version):</strong></p>
<pre><code>MI = MAX(0, (171 - 5.2 * ln(HV) - 0.23 * CC - 16.2 * ln(LOC)) * 100 / 171)
</code></pre>
<p>Where:</p>
<ul>
<li><strong>HV</strong> = Halstead Volume</li>
<li><strong>CC</strong> = Cyclomatic Complexity</li>
<li><strong>LOC</strong> = Lines of Code</li>
</ul>
<p><strong>Scale:</strong></p>
<ul>
<li><strong>85-100:</strong> Good maintainability (green)</li>
<li><strong>65-84:</strong> Moderate maintainability (yellow)</li>
<li><strong>0-64:</strong> Difficult to maintain (red)</li>
</ul>
<p>Note: Maintainability Index is not implemented in the current codebase. This section outlines potential future work.</p>
<pre><pre class="playground"><code class="language-rust">pub fn maintainability_index(
    halstead_volume: f64,
    cyclomatic_complexity: usize,
    lines_of_code: usize
) -&gt; f64 {
    let hv_term = 5.2 * halstead_volume.ln();
    let cc_term = 0.23 * (cyclomatic_complexity as f64);
    let loc_term = 16.2 * (lines_of_code as f64).ln();
    
    let mi = 171.0 - hv_term - cc_term - loc_term;
    let normalized = (mi * 100.0 / 171.0).max(0.0);
    
    normalized
}</code></pre></pre>
<h4 id="planned-halstead-metrics"><a class="header" href="#planned-halstead-metrics">Planned: Halstead Metrics</a></h4>
<p><strong>Operators and Operands:</strong></p>
<ul>
<li><strong>n1</strong> = number of distinct operators</li>
<li><strong>n2</strong> = number of distinct operands</li>
<li><strong>N1</strong> = total number of operators</li>
<li><strong>N2</strong> = total number of operands</li>
</ul>
<p><strong>Derived Metrics:</strong></p>
<ul>
<li><strong>Program Vocabulary:</strong> <code>n = n1 + n2</code></li>
<li><strong>Program Length:</strong> <code>N = N1 + N2</code></li>
<li><strong>Calculated Length:</strong> <code>N' = n1 * log2(n1) + n2 * log2(n2)</code></li>
<li><strong>Volume:</strong> <code>V = N * log2(n)</code></li>
<li><strong>Difficulty:</strong> <code>D = (n1 / 2) * (N2 / n2)</code></li>
<li><strong>Effort:</strong> <code>E = D * V</code></li>
<li><strong>Time to Program:</strong> <code>T = E / 18</code> seconds</li>
<li><strong>Bugs Delivered:</strong> <code>B = V / 3000</code></li>
</ul>
<p>Note: Halstead metrics are not implemented in the current codebase.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HalsteadMetrics {
    pub distinct_operators: usize,    // n1
    pub distinct_operands: usize,     // n2
    pub total_operators: usize,       // N1
    pub total_operands: usize,        // N2
    pub vocabulary: usize,            // n
    pub length: usize,                // N
    pub volume: f64,                  // V
    pub difficulty: f64,              // D
    pub effort: f64,                  // E
    pub time_to_program: f64,         // T
    pub bugs_delivered: f64,          // B
}

impl HalsteadMetrics {
    pub fn calculate(operators: &amp;HashSet&lt;String&gt;, operands: &amp;HashSet&lt;String&gt;,
                     op_count: usize, operand_count: usize) -&gt; Self {
        let n1 = operators.len();
        let n2 = operands.len();
        let n = n1 + n2;
        let N = op_count + operand_count;
        
        let volume = (N as f64) * (n as f64).log2();
        let difficulty = (n1 as f64 / 2.0) * (operand_count as f64 / n2 as f64);
        let effort = difficulty * volume;
        let time = effort / 18.0;
        let bugs = volume / 3000.0;
        
        HalsteadMetrics {
            distinct_operators: n1,
            distinct_operands: n2,
            total_operators: op_count,
            total_operands: operand_count,
            vocabulary: n,
            length: N,
            volume,
            difficulty,
            effort,
            time_to_program: time,
            bugs_delivered: bugs,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="metrics-collection-in-the-pipeline"><a class="header" href="#metrics-collection-in-the-pipeline">Metrics Collection in the Pipeline</a></h2>
<p><code>MetricsPass</code> is registered in the analyzer registry and runs during <code>Phase::LocalRules</code>. It enumerates classes/structs/methods via <code>Query</code> and uses helpers from <code>bsharp_analysis::metrics::shared</code> to compute statement counts, decision points (cyclomatic complexity), and nesting.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_analysis::context::AnalysisContext;
use bsharp_analysis::framework::pipeline::AnalyzerPipeline;
use bsharp_analysis::framework::session::AnalysisSession;
use bsharp_analysis::metrics::AstAnalysis;
use bsharp_parser::facade::Parser;

let source = r#"public class C { public void M() { if (true) { } } }"#;
let (cu, spans) = Parser::new().parse_with_spans(source)?;
let mut session = AnalysisSession::new(AnalysisContext::new("file.cs", source), spans);
AnalyzerPipeline::run_with_defaults(&amp;cu, &amp;mut session);
let ast = session.artifacts.get::&lt;AstAnalysis&gt;().expect("AstAnalysis");
println!("classes={}, methods={}, ifs={}", ast.total_classes, ast.total_methods, ast.total_if_statements);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="cli-usage"><a class="header" href="#cli-usage">CLI Usage</a></h2>
<h3 id="analyze-metrics"><a class="header" href="#analyze-metrics">Analyze Metrics</a></h3>
<pre><code class="language-bash"># Analyze single file
bsharp analyze MyFile.cs

# Analyze project
bsharp analyze MyProject.csproj --out metrics.json

# Analyze solution
bsharp analyze MySolution.sln --out metrics.json --format pretty-json
</code></pre>
<h3 id="example-output"><a class="header" href="#example-output">Example Output</a></h3>
<pre><code class="language-json">{
  "schema_version": 1,
  "metrics": {
    "total_lines": 1250,
    "code_lines": 980,
    "comment_lines": 150,
    "blank_lines": 120,
    "class_count": 15,
    "method_count": 87,
    "total_complexity": 245,
    "max_complexity": 18,
    "max_nesting_depth": 5
  }
}
</code></pre>
<hr />
<h2 id="thresholds-and-warnings"><a class="header" href="#thresholds-and-warnings">Thresholds and Warnings</a></h2>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<pre><code class="language-toml">[analysis.metrics]
max_cyclomatic_complexity = 10
max_cognitive_complexity = 15
max_nesting_depth = 4
max_method_length = 50
min_maintainability_index = 65
</code></pre>
<h3 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h3>
<p><strong>High Complexity Warning:</strong></p>
<pre><code>warning[MET001]: Method has high cyclomatic complexity
  --&gt; src/OrderProcessor.cs:42:17
   |
42 |     public void ProcessOrder(Order order) {
   |                 ^^^^^^^^^^^^ complexity = 18 (threshold: 10)
   |
   = help: Consider breaking this method into smaller methods
</code></pre>
<p><strong>Deep Nesting Warning:</strong></p>
<pre><code>warning[MET002]: Deep nesting detected
  --&gt; src/Validator.cs:15:9
   |
15 |         if (condition1) {
   |         ^^ nesting depth = 5 (threshold: 4)
   |
   = help: Consider extracting nested logic into separate methods
</code></pre>
<hr />
<h2 id="programmatic-usage"><a class="header" href="#programmatic-usage">Programmatic Usage</a></h2>
<h3 id="analyzing-a-method"><a class="header" href="#analyzing-a-method">Analyzing a Method</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::metrics::{cyclomatic_complexity, cognitive_complexity, max_nesting_depth};

let method = parse_method("public void MyMethod() { ... }");

let cc = cyclomatic_complexity(&amp;method);
let cog = cognitive_complexity(&amp;method);
let nesting = max_nesting_depth(&amp;method);

println!("Cyclomatic Complexity: {}", cc);
println!("Cognitive Complexity: {}", cog);
println!("Max Nesting Depth: {}", nesting);
<span class="boring">}</span></code></pre></pre>
<h3 id="analyzing-a-file-via-the-pipeline"><a class="header" href="#analyzing-a-file-via-the-pipeline">Analyzing a file via the pipeline</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (cu, spans) = Parser::new().parse_with_spans(source_code)?;
let mut session = AnalysisSession::new(AnalysisContext::new("file.cs", source_code), spans);
AnalyzerPipeline::run_with_defaults(&amp;cu, &amp;mut session);
let metrics = session.artifacts.get::&lt;AstAnalysis&gt;().expect("AstAnalysis");
println!("Classes: {}", metrics.total_classes);
println!("Methods: {}", metrics.total_methods);
println!("Cyclomatic Complexity: {}", metrics.cyclomatic_complexity);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="related-documentation"><a class="header" href="#related-documentation">Related Documentation</a></h2>
<ul>
<li><a href="./pipeline.html">Analysis Pipeline</a> - How metrics fit in the pipeline</li>
<li><a href="./control-flow.html">Control Flow Analysis</a> - Related complexity analysis</li>
<li><a href="./quality.html">Code Quality</a> - Quality assessment using metrics</li>
<li><a href="../development/architecture.html">Architecture</a> - Design decisions</li>
</ul>
<hr />
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><strong>Implementation:</strong> <code>src/bsharp_analysis/src/metrics/</code></li>
<li><strong>Pass:</strong> <code>src/bsharp_analysis/src/passes/metrics.rs</code></li>
<li><strong>Tests:</strong> <code>src/bsharp_tests/src/analysis/metrics/</code> (planned)</li>
<li><strong>Standards:</strong> ISO/IEC 25023 (Software Quality Metrics)</li>
</ul>

                </main>
                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->

                    <div style="clear: both"></div>
                </nav>
            </div>

            <!-- Theme selector removed - forcing dark mode only -->
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
        </nav>
    </div>

    <!-- Livereload script (if served using the mdbook serve command) -->

    <!-- Custom JS scripts -->

    <!-- Force dark mode script -->
    <script>
        // Force dark mode and prevent theme switching
        (function() {
            // Override localStorage before mdBook loads
            var originalSetItem = localStorage.setItem;
            var originalGetItem = localStorage.getItem;
            
            localStorage.setItem = function(key, value) {
                if (key === 'mdbook-theme') {
                    value = 'dark';
                }
                return originalSetItem.call(this, key, value);
            };
            
            localStorage.getItem = function(key) {
                if (key === 'mdbook-theme') {
                    return 'dark';
                }
                return originalGetItem.call(this, key);
            };
            
            // Set dark mode immediately
            localStorage.setItem('mdbook-theme', 'dark');
            
            // Continuously enforce dark mode
            setInterval(function() {
                document.documentElement.classList.remove('light');
                document.documentElement.classList.add('dark');
            }, 10);
            
            // Override any theme switching attempts
            Object.defineProperty(window, 'mdbook', {
                get: function() {
                    return {
                        changeTheme: function() {
                            // Do nothing - prevent theme changes
                        }
                    };
                },
                set: function() {
                    // Do nothing - prevent mdbook override
                }
            });
        })();
        
        // Wait for DOM to be ready and enforce dark mode
        document.addEventListener('DOMContentLoaded', function() {
            setInterval(function() {
                document.documentElement.classList.remove('light');
                document.documentElement.classList.add('dark');
            }, 10);
        });
    </script>
</body>
</html>
