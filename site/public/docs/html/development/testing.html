<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Testing - BSharp C# Parser Documentation</title>


        <!-- Custom HTML head -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="../custom.css">
        
        <script>
          (function() {
            function applyTheme(mode){
              const theme = mode === 'dark' ? 'coal' : 'light';
              try { localStorage.setItem('mdbook-theme', theme); } catch(e) {}
              const html = document.documentElement;
              html.classList.remove('light','rust','coal','navy','ayu','default_theme');
              html.classList.add(theme,'js');
            }
            function detectFromParent(){
              try {
                if (window.parent && window.parent !== window) {
                  const phtml = window.parent.document.documentElement;
                  if (phtml.classList.contains('dark')) return 'dark';
                  if (phtml.classList.contains('light')) return 'light';
                }
              } catch(e) {}
              return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
            }
            applyTheme(detectFromParent());
            window.addEventListener('message', (e) => {
              const d = e && e.data;
              if (!d || d.type !== 'bsharp:theme') return;
              applyTheme(d.value === 'dark' ? 'dark' : 'light');
            });
            try {
              window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => applyTheme(e.matches ? 'dark' : 'light'));
            } catch(e) {}
            window.addEventListener('DOMContentLoaded', () => {
              const themeBtn = document.getElementById('theme-toggle');
              const themeList = document.getElementById('theme-list');
              if (themeBtn) themeBtn.style.display = 'none';
              if (themeList) themeList.style.display = 'none';
            });
          })();
        </script>

        <meta name="description" content="Comprehensive documentation for the BSharp C# parser and analysis toolkit">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href=".././mdbook-admonish.css">
        <link rel="stylesheet" href="../theme/pagetoc.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">BSharp C# Parser Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/pmikstacki/bsharp" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/pmikstacki/bsharp/edit/main/docs/./development/testing.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="testing-guide"><a class="header" href="#testing-guide">Testing Guide</a></h1>
<p>This document provides comprehensive guidance on testing in the BSharp project, covering test organization, best practices, and debugging strategies.</p>
<hr />
<h2 id="test-organization-philosophy"><a class="header" href="#test-organization-philosophy">Test Organization Philosophy</a></h2>
<h3 id="external-test-structure"><a class="header" href="#external-test-structure">External Test Structure</a></h3>
<p><strong>Critical Principle:</strong> Parser tests are external to implementation modules and live in a dedicated test crate.</p>
<pre><code>src/bsharp_tests/
├── cargo.toml               # Test crate manifest
└── src/
    ├── parser/
    │   ├── expressions/
    │   │   ├── expression_tests.rs
    │   │   ├── lambda_expression_tests.rs
    │   │   ├── pattern_matching_tests.rs
    │   │   ├── ambiguity_tests.rs
    │   │   ├── lookahead_boundaries2_tests.rs
    │   │   └── ...
    │   ├── statements/
    │   │   ├── if_statement_tests.rs
    │   │   ├── for_statement_tests.rs
    │   │   ├── expression_statement_tests.rs
    │   │   └── ...
    │   ├── declarations/
    │   │   ├── class_declaration_tests.rs
    │   │   ├── interface_declaration_parser_tests.rs
    │   │   ├── recovery_tests.rs
    │   │   └── ...
    │   ├── types/
    │   │   ├── type_tests.rs
    │   │   ├── advanced_type_tests.rs
    │   │   └── ...
    │   ├── preprocessor/
    │   │   └── ...
    │   └── keyword_parsers_tests.rs
    └── fixtures/
        ├── happy_path/
        └── complex/
</code></pre>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Separation of Concerns</strong>: Test code separate from implementation</li>
<li><strong>Compilation Efficiency</strong>: Tests don't bloat production binary</li>
<li><strong>Organization</strong>: Clear structure mirrors parser organization</li>
<li><strong>Maintainability</strong>: Easy to find and update tests</li>
</ul>
<p><strong>What NOT to Do:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ NEVER do this in src/parser/ files
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_something() {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>What to Do Instead:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ Create tests/parser/expressions/my_feature_tests.rs
use bsharp::syntax::test_helpers::expect_ok;
use bsharp::parser::expressions::parse_my_feature;

#[test]
fn test_my_feature() {
    let input = "my feature syntax";
    let result = parse_my_feature(input.into());
    let ast = expect_ok(input, result);
    // assertions...
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="test-helpers"><a class="header" href="#test-helpers">Test Helpers</a></h2>
<h3 id="expect_ok---readable-test-failures"><a class="header" href="#expect_ok---readable-test-failures"><code>expect_ok()</code> - Readable Test Failures</a></h3>
<p><strong>Location:</strong> <code>src/syntax/test_helpers.rs</code></p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::syntax::test_helpers::expect_ok;

#[test]
fn test_parse_class() {
    let input = "public class MyClass { }";
    let result = parse_class_declaration(input.into());
    let class = expect_ok(input, result);
    
    assert_eq!(class.identifier.name, "MyClass");
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li><strong>Automatic Error Formatting</strong>: Pretty-prints <code>ErrorTree</code> on failure</li>
<li><strong>Readable Diagnostics</strong>: Shows parse failure context with caret</li>
<li><strong>Panic on Failure</strong>: Test fails with clear error message</li>
</ul>
<p><strong>Error Output Example:</strong></p>
<pre><code>0: at line 1, in keyword "class":
public clas MyClass { }
       ^--- expected keyword "class"

1: in context "class declaration"
</code></pre>
<h3 id="other-test-helpers"><a class="header" href="#other-test-helpers">Other Test Helpers</a></h3>
<p><strong><code>parse_input_unwrap()</code></strong> - Unwrap parse result:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_syntax::span::Span;
let (remaining, ast) = parse_input_unwrap(
    parse_expression_spanned(Span::new(input)).map(|(rest, s)| (rest, s.node))
);
assert_eq!(remaining, "");  // Verify full consumption
<span class="boring">}</span></code></pre></pre>
<p><strong><code>assert_parse_error()</code></strong> - Verify parse failures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp_syntax::span::Span;
assert_parse_error(
    parse_expression_spanned(Span::new("invalid syntax")).map(|(rest, s)| (rest, s.node))
);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="parser-testing-best-practices"><a class="header" href="#parser-testing-best-practices">Parser Testing Best Practices</a></h2>
<h3 id="1-prefer-expect_ok-for-successful-parses"><a class="header" href="#1-prefer-expect_ok-for-successful-parses">1. Prefer <code>expect_ok()</code> for Successful Parses</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_if_statement() {
    let input = "if (x &gt; 0) { return x; }";
    let stmt = expect_ok(input, parse_if_statement(input.into()));
    
    // Now assert on the AST structure
    match stmt {
        Statement::If(if_stmt) =&gt; {
            // Verify condition, consequence, etc.
        }
        _ =&gt; panic!("Expected IfStatement"),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-keep-tests-focused-and-minimal"><a class="header" href="#2-keep-tests-focused-and-minimal">2. Keep Tests Focused and Minimal</a></h3>
<p><strong>Good:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_simple_lambda() {
    let input = "x =&gt; x * 2";
    let expr = expect_ok(input, parse_lambda_expression(input.into()));
    // Test one thing
}

#[test]
fn test_lambda_with_multiple_params() {
    let input = "(x, y) =&gt; x + y";
    let expr = expect_ok(input, parse_lambda_expression(input.into()));
    // Test another thing
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Bad:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_all_lambda_forms() {
    // Testing too many things in one test
    // Hard to debug when it fails
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-add-negative-tests-for-ambiguity"><a class="header" href="#3-add-negative-tests-for-ambiguity">3. Add Negative Tests for Ambiguity</a></h3>
<p>When disambiguation is possible, add tests for both valid and invalid cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_ternary_vs_nullable() {
    // Valid ternary
    let input = "x ? y : z";
    expect_ok(input, parse_conditional_expression(input.into()));
    
    // Valid null-conditional (different test)
}

#[test]
fn test_null_conditional_operator() {
    let input = "obj?.Property";
    expect_ok(input, parse_postfix_expression(input.into()));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-test-lookaheaddisambiguation-boundaries"><a class="header" href="#4-test-lookaheaddisambiguation-boundaries">4. Test Lookahead/Disambiguation Boundaries</a></h3>
<p><strong>Location:</strong> <code>tests/parser/expressions/lookahead_boundaries2_tests.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_range_vs_dot_vs_float() {
    // Range operator
    expect_ok("1..10", parse_range_expression("1..10"));
    
    // Member access
    expect_ok("obj.Method", parse_postfix_expression("obj.Method"));
    
    // Float literal
    expect_ok("3.14", parse_literal("3.14"));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-test-complex-constructs"><a class="header" href="#5-test-complex-constructs">5. Test Complex Constructs</a></h3>
<p>For complex constructs like <code>new</code> expressions with initializers:</p>
<p><strong>Location:</strong> <code>tests/parser/expressions/new_expression_tests.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_new_with_object_initializer() {
    let input = "new Person { Name = \"John\", Age = 30 }";
    let expr = expect_ok(input, parse_new_expression(input.into()));
    // Verify structure
}

#[test]
fn test_new_with_collection_initializer() {
    let input = "new List&lt;int&gt; { 1, 2, 3 }";
    let expr = expect_ok(input, parse_new_expression(input.into()));
    // Verify structure
}

#[test]
fn test_target_typed_new() {
    let input = "new(42, \"test\")";
    let expr = expect_ok(input, parse_new_expression(input.into()));
    // Verify structure
}
<span class="boring">}</span></code></pre></pre>
<h3 id="6-test-invalid-input-diagnostics"><a class="header" href="#6-test-invalid-input-diagnostics">6. Test Invalid Input Diagnostics</a></h3>
<p><strong>Location:</strong> <code>tests/parser/expressions/invalid_diagnostics_tests.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_unclosed_paren_diagnostic() {
    use bsharp_syntax::span::Span;
    let input = "(x + y";
    let result = parse_expression_spanned(Span::new(input)).map(|(rest, s)| (rest, s.node));
    assert!(result.is_err());
    // Optionally check error contains expected message
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Guidelines:</strong></p>
<ul>
<li>Keep small snapshot-style assertions</li>
<li>Check for line/column and caret presence</li>
<li>Avoid overfitting on exact wording (may change)</li>
</ul>
<h3 id="7-guard-closing-delimiters-with-cut"><a class="header" href="#7-guard-closing-delimiters-with-cut">7. Guard Closing Delimiters with <code>cut()</code></a></h3>
<p>When adding delimited constructs, ensure closing delimiters use <code>cut()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use nom::combinator::cut;
use crate::syntax::parser_helpers::{bdelimited, bchar};

fn parse_parenthesized(input: &amp;str) -&gt; BResult&lt;&amp;str, Expression&gt; {
    bdelimited(
        bchar('('),
        parse_expression,
        cut(bchar(')'))  // ✅ Prevents misleading backtracking
    )(input.into())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="8-wrap-sub-parsers-with-bws"><a class="header" href="#8-wrap-sub-parsers-with-bws">8. Wrap Sub-Parsers with <code>bws()</code></a></h3>
<p>Ensure whitespace/comments are handled consistently:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::syntax::parser_helpers::bws;

fn parse_if_statement(input: &amp;str) -&gt; BResult&lt;&amp;str, Statement&gt; {
    let (input, _) = bws(keyword("if"))(input.into())?;
    let (input, _) = bws(bchar('('))(input.into())?;
    let (input, condition) = bws(parse_expression)(input.into())?;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="test-discovery-and-execution"><a class="header" href="#test-discovery-and-execution">Test Discovery and Execution</a></h2>
<h3 id="running-all-tests"><a class="header" href="#running-all-tests">Running All Tests</a></h3>
<pre><code class="language-bash">cargo test
</code></pre>
<h3 id="running-specific-test-suites"><a class="header" href="#running-specific-test-suites">Running Specific Test Suites</a></h3>
<pre><code class="language-bash"># All parser tests
cargo test --test parser

# Specific module
cargo test --test parser expression_tests

# Specific test
cargo test --test parser test_lambda_expression
</code></pre>
<h3 id="running-with-output"><a class="header" href="#running-with-output">Running with Output</a></h3>
<pre><code class="language-bash"># Show println! output
cargo test -- --nocapture

# Show test names as they run
cargo test -- --nocapture --test-threads=1
</code></pre>
<h3 id="running-with-debug-logging"><a class="header" href="#running-with-debug-logging">Running with Debug Logging</a></h3>
<pre><code class="language-bash">RUST_LOG=debug cargo test test_name -- --nocapture
</code></pre>
<hr />
<h2 id="test-fixtures"><a class="header" href="#test-fixtures">Test Fixtures</a></h2>
<h3 id="fixture-organization"><a class="header" href="#fixture-organization">Fixture Organization</a></h3>
<pre><code>tests/fixtures/
├── happy_path/           # Valid, well-formed C# projects
│   ├── testApplication/
│   │   ├── Program.cs
│   │   ├── testApplication.csproj
│   │   └── ...
│   └── testDependency/
│       └── ...
└── complex/              # Complex, real-world scenarios
    ├── testApplication/
    └── testDependency/
</code></pre>
<h3 id="using-fixtures-in-tests"><a class="header" href="#using-fixtures-in-tests">Using Fixtures in Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::path::PathBuf;

#[test]
fn test_parse_fixture() {
    let fixture_path = PathBuf::from("tests/fixtures/happy_path/testApplication/Program.cs");
    let source = fs::read_to_string(&amp;fixture_path).unwrap();
    
    let parser = Parser::new();
    let result = parser.parse(&amp;source);
    
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="fixture-guidelines"><a class="header" href="#fixture-guidelines">Fixture Guidelines</a></h3>
<ul>
<li><strong>Valid Code</strong>: Fixtures should be valid C# that compiles</li>
<li><strong>Realistic</strong>: Use real-world patterns, not contrived examples</li>
<li><strong>Documented</strong>: Add README.md explaining fixture purpose</li>
<li><strong>Minimal</strong>: Keep fixtures as small as possible while testing feature</li>
</ul>
<hr />
<h2 id="snapshot-testing"><a class="header" href="#snapshot-testing">Snapshot Testing</a></h2>
<h3 id="using-insta-for-snapshot-tests"><a class="header" href="#using-insta-for-snapshot-tests">Using <code>insta</code> for Snapshot Tests</a></h3>
<p><strong>Installation:</strong> Already included in <code>Cargo.toml</code> dev-dependencies</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use insta::assert_json_snapshot;

#[test]
fn test_class_ast_structure() {
    let input = "public class MyClass { public int Field; }";
    let result = parse_class_declaration(input.into());
    let class = expect_ok(input, result);
    
    // Creates snapshot file on first run
    assert_json_snapshot!(class);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="reviewing-snapshots"><a class="header" href="#reviewing-snapshots">Reviewing Snapshots</a></h3>
<pre><code class="language-bash"># Review snapshot changes
cargo insta review

# Accept all changes
cargo insta accept

# Reject all changes
cargo insta reject
</code></pre>
<h3 id="snapshot-guidelines"><a class="header" href="#snapshot-guidelines">Snapshot Guidelines</a></h3>
<ul>
<li><strong>Complex Structures</strong>: Use for complex AST structures</li>
<li><strong>Regression Prevention</strong>: Catch unintended changes</li>
<li><strong>Review Carefully</strong>: Always review snapshot diffs</li>
<li><strong>Commit Snapshots</strong>: Include snapshot files in git</li>
</ul>
<hr />
<h2 id="debugging-test-failures"><a class="header" href="#debugging-test-failures">Debugging Test Failures</a></h2>
<h3 id="strategy-1-use-expect_ok-error-output"><a class="header" href="#strategy-1-use-expect_ok-error-output">Strategy 1: Use <code>expect_ok()</code> Error Output</a></h3>
<p>When a test fails, <code>expect_ok()</code> shows the parse error:</p>
<pre><code>0: at line 1, in keyword "class":
public clas MyClass { }
       ^--- expected keyword "class"
</code></pre>
<h3 id="strategy-2-add-debug-logging"><a class="header" href="#strategy-2-add-debug-logging">Strategy 2: Add Debug Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_with_logging() {
    env_logger::init();  // Initialize logger
    
    use bsharp_syntax::span::Span;
    let input = "complex syntax";
    log::debug!("Parsing: {}", input);
    
    let result = parse_expression_spanned(Span::new(input)).map(|(rest, s)| (rest, s.node));
    log::debug!("Result: {:?}", result);
    
    expect_ok(input, result);
}
<span class="boring">}</span></code></pre></pre>
<p>Run with:</p>
<pre><code class="language-bash">RUST_LOG=debug cargo test test_with_logging -- --nocapture
</code></pre>
<h3 id="strategy-3-test-smaller-components"><a class="header" href="#strategy-3-test-smaller-components">Strategy 3: Test Smaller Components</a></h3>
<p>If a complex parser fails, test its sub-parsers individually:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_method_declaration() {
    // Fails - too complex
    let input = "public async Task&lt;int&gt; Method(int x) { return x; }";
    expect_ok(input, parse_method_declaration(input.into()));
}

// Break it down:

#[test]
fn test_method_modifiers() {
    let input = "public async";
    expect_ok(input, parse_modifiers(input.into()));
}

#[test]
fn test_method_return_type() {
    let input = "Task&lt;int&gt;";
    expect_ok(input, parse_type(input.into()));
}

#[test]
fn test_method_parameters() {
    let input = "(int x)";
    expect_ok(input, parse_parameter_list(input.into()));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="strategy-4-use-parser-debugging-tools"><a class="header" href="#strategy-4-use-parser-debugging-tools">Strategy 4: Use Parser Debugging Tools</a></h3>
<pre><code class="language-bash"># Parse file and output JSON
cargo run -- parse debug_cases/test.cs --output debug.json

# Generate AST visualization
cargo run -- tree debug_cases/test.cs --output debug.svg
</code></pre>
<h3 id="strategy-5-check-error-recovery"><a class="header" href="#strategy-5-check-error-recovery">Strategy 5: Check Error Recovery</a></h3>
<p>For declaration error recovery tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_recovery_from_malformed_member() {
    let input = r#"
    public class MyClass {
        public int ValidField;
        public invalid syntax here;  // Malformed
        public int AnotherValidField;  // Should recover
    }
    "#;
    
    let result = parse_class_declaration(input.into());
    // Should parse despite error
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h2>
<h3 id="workspace-loading-tests"><a class="header" href="#workspace-loading-tests">Workspace Loading Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::workspace::WorkspaceLoader;

#[test]
fn test_load_solution() {
    let sln_path = PathBuf::from("tests/fixtures/happy_path/test.sln");
    let workspace = WorkspaceLoader::from_path(&amp;sln_path).unwrap();
    
    assert_eq!(workspace.projects.len(), 2);
    assert!(workspace.solution.is_some());
}

#[test]
fn test_load_csproj() {
    let csproj_path = PathBuf::from("tests/fixtures/happy_path/testApplication/testApplication.csproj");
    let workspace = WorkspaceLoader::from_path(&amp;csproj_path).unwrap();
    
    assert_eq!(workspace.projects.len(), 1);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="analysis-pipeline-tests"><a class="header" href="#analysis-pipeline-tests">Analysis Pipeline Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bsharp::analysis::framework::pipeline::AnalyzerPipeline;
use bsharp::analysis::framework::session::AnalysisSession;

#[test]
fn test_analysis_pipeline() {
    let source = "public class Test { public void Method() { } }";
    let parser = Parser::new();
    let cu = parser.parse(source).unwrap();
    
    let mut session = AnalysisSession::new();
    AnalyzerPipeline::run_with_defaults(&amp;cu, &amp;mut session);
    
    let report = session.into_report();
    assert!(report.diagnostics.is_empty());  // No errors
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<h3 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[ignore]  // Run with --ignored flag
fn bench_parse_large_file() {
    use std::time::Instant;
    
    let source = fs::read_to_string("tests/fixtures/large_file.cs").unwrap();
    let parser = Parser::new();
    
    let start = Instant::now();
    let result = parser.parse(&amp;source);
    let duration = start.elapsed();
    
    assert!(result.is_ok());
    println!("Parse time: {:?}", duration);
    
    // Assert reasonable performance
    assert!(duration.as_millis() &lt; 1000, "Parse took too long");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="running-performance-tests"><a class="header" href="#running-performance-tests">Running Performance Tests</a></h3>
<pre><code class="language-bash">cargo test --ignored -- bench_
</code></pre>
<hr />
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h2>
<h3 id="ci-test-strategy"><a class="header" href="#ci-test-strategy">CI Test Strategy</a></h3>
<pre><code class="language-yaml"># .github/workflows/test.yml (example)
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: Run tests
        run: cargo test --all-features
      - name: Run clippy
        run: cargo clippy -- -D warnings
      - name: Check formatting
        run: cargo fmt -- --check
</code></pre>
<hr />
<h2 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h2>
<h3 id="measuring-coverage"><a class="header" href="#measuring-coverage">Measuring Coverage</a></h3>
<pre><code class="language-bash"># Install tarpaulin
cargo install cargo-tarpaulin

# Run coverage
cargo tarpaulin --out Html --output-dir coverage
</code></pre>
<h3 id="coverage-goals"><a class="header" href="#coverage-goals">Coverage Goals</a></h3>
<ul>
<li><strong>Parser Core</strong>: 90%+ coverage</li>
<li><strong>Analysis Framework</strong>: 80%+ coverage</li>
<li><strong>CLI Commands</strong>: 70%+ coverage</li>
<li><strong>Workspace Loading</strong>: 80%+ coverage</li>
</ul>
<hr />
<h2 id="common-testing-patterns"><a class="header" href="#common-testing-patterns">Common Testing Patterns</a></h2>
<h3 id="pattern-1-positive-and-negative-tests"><a class="header" href="#pattern-1-positive-and-negative-tests">Pattern 1: Positive and Negative Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_valid_syntax() {
    let input = "valid syntax";
    expect_ok(input, parse_feature(input.into()));
}

#[test]
fn test_invalid_syntax() {
    let input = "invalid syntax";
    assert!(parse_feature(input.into()).is_err());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-2-boundary-testing"><a class="header" href="#pattern-2-boundary-testing">Pattern 2: Boundary Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_empty_input() {
    assert!(parse_feature("").is_err());
}

#[test]
fn test_minimal_input() {
    expect_ok("x", parse_feature("x"));
}

#[test]
fn test_maximal_input() {
    let input = "very complex nested structure...";
    expect_ok(input, parse_feature(input.into()));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-3-equivalence-testing"><a class="header" href="#pattern-3-equivalence-testing">Pattern 3: Equivalence Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_whitespace_insensitive() {
    let compact = "if(x){y;}";
    let spaced = "if (x) { y; }";
    
    let ast1 = expect_ok(compact, parse_if_statement(compact));
    let ast2 = expect_ok(spaced, parse_if_statement(spaced));
    
    assert_eq!(ast1, ast2);
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="test-maintenance"><a class="header" href="#test-maintenance">Test Maintenance</a></h2>
<h3 id="when-to-update-tests"><a class="header" href="#when-to-update-tests">When to Update Tests</a></h3>
<ol>
<li><strong>API Changes</strong>: Update tests when parser API changes</li>
<li><strong>Bug Fixes</strong>: Add regression tests for fixed bugs</li>
<li><strong>New Features</strong>: Add tests for new language features</li>
<li><strong>Refactoring</strong>: Ensure tests still pass after refactoring</li>
</ol>
<h3 id="test-cleanup"><a class="header" href="#test-cleanup">Test Cleanup</a></h3>
<ul>
<li><strong>Remove Duplicate Tests</strong>: Consolidate similar tests</li>
<li><strong>Update Outdated Tests</strong>: Fix tests using deprecated APIs</li>
<li><strong>Remove Dead Tests</strong>: Delete tests for removed features</li>
<li><strong>Improve Names</strong>: Use descriptive test names</li>
</ul>
<h3 id="test-documentation"><a class="header" href="#test-documentation">Test Documentation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Tests that lambda expressions with multiple parameters are parsed correctly.
/// 
/// This test verifies:
/// - Parameter list parsing
/// - Arrow token recognition
/// - Expression body parsing
#[test]
fn test_lambda_with_multiple_params() {
    let input = "(x, y) =&gt; x + y";
    let expr = expect_ok(input, parse_lambda_expression(input.into()));
    // ...
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<h3 id="testing-checklist"><a class="header" href="#testing-checklist">Testing Checklist</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Tests in <code>tests/</code> directory, not inline</li>
<li><input disabled="" type="checkbox"/>
Use <code>expect_ok()</code> for readable failures</li>
<li><input disabled="" type="checkbox"/>
Keep tests focused and minimal</li>
<li><input disabled="" type="checkbox"/>
Add negative tests for ambiguity</li>
<li><input disabled="" type="checkbox"/>
Test lookahead/disambiguation boundaries</li>
<li><input disabled="" type="checkbox"/>
Test complex constructs thoroughly</li>
<li><input disabled="" type="checkbox"/>
Use <code>cut()</code> for closing delimiters</li>
<li><input disabled="" type="checkbox"/>
Wrap sub-parsers with <code>bws()</code></li>
<li><input disabled="" type="checkbox"/>
Add fixtures for integration tests</li>
<li><input disabled="" type="checkbox"/>
Use snapshot tests for complex structures</li>
<li><input disabled="" type="checkbox"/>
Document test purpose and coverage</li>
</ul>
<h3 id="resources"><a class="header" href="#resources">Resources</a></h3>
<ul>
<li><strong>Test Helpers</strong>: <code>src/syntax/test_helpers.rs</code></li>
<li><strong>Example Tests</strong>: <code>tests/parser/expressions/</code></li>
<li><strong>Fixtures</strong>: <code>tests/fixtures/</code></li>
<li><strong>Contributing Guide</strong>: <code>docs/development/contributing.md</code></li>
<li><strong>Architecture</strong>: <code>docs/development/architecture.md</code></li>
</ul>
<footer class="gitinfo-footer" style="font-size:0.8em;padding:4px;margin:0 0 2em 0;text-align:center;display:block;">2025-10-29 21:23:59 • commit: 63cde56</footer>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../development/contributing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../development/architecture.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../development/contributing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../development/architecture.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>
        <script src="../theme/pagetoc.js"></script>



    </div>
    </body>
</html>
